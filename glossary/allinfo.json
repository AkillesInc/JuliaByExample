[
  {
    "name": "Base",
    "items": 
    [
      {
        "name": "!",
        "summary": "Function",
        "help": "Base.!(x)\n\n   Boolean not\n",
        "methods": 
        [
          "!(x::Bool) at bool.jl:19",
          "!(B::BitArray{N}) at bitarray.jl:846",
          "!(A::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at array.jl:684"
        ]
      },
      {
        "name": "!=",
        "summary": "Function",
        "help": "Base.!=(x, y)\n\n   Not-equals comparison operator. Always gives the opposite answer as\n   \"==\". New types should generally not implement this, and rely on\n   the fallback definition \"!=(x,y) = !(x==y)\" instead.\n",
        "methods": 
        [
          "!=(x::Float32,y::Float32) at float.jl:146",
          "!=(x::Float64,y::Float64) at float.jl:147",
          "!=(A::BitArray{N},B::BitArray{N}) at bitarray.jl:1065",
          "!=(x,y) at operators.jl:26"
        ]
      },
      {
        "name": "!==",
        "summary": "Function",
        "help": "Base.!==(x, y)\n\n   Equivalent to \"!is(x, y)\"\n",
        "methods": 
        [
          "!==(x,y) at operators.jl:29"
        ]
      },
      {
        "name": "$",
        "summary": "Function",
        "help": "Base.$(x, y)\n\n   Bitwise exclusive or\n",
        "methods": 
        [
          "$(x::Bool,y::Bool) at bool.jl:24",
          "$(x::Int8,y::Int8) at int.jl:146",
          "$(x::Int16,y::Int16) at int.jl:147",
          "$(x::Int32,y::Int32) at int.jl:148",
          "$(x::Int64,y::Int64) at int.jl:149",
          "$(x::Int128,y::Int128) at int.jl:150",
          "$(x::Uint8,y::Uint8) at int.jl:152",
          "$(x::Uint16,y::Uint16) at int.jl:153",
          "$(x::Uint32,y::Uint32) at int.jl:154",
          "$(x::Uint64,y::Uint64) at int.jl:155",
          "$(x::Uint128,y::Uint128) at int.jl:156",
          "$(A::BitArray{N},B::BitArray{N}) at bitarray.jl:963",
          "$(A::DenseArray{Bool,N},B::BitArray{N}) at bitarray.jl:974",
          "$(B::BitArray{N},A::DenseArray{Bool,N}) at bitarray.jl:975",
          "${S,T}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:724",
          "$(x::Char,y::Char) at char.jl:35",
          "$(x::BigInt,y::BigInt) at gmp.jl:193",
          "$(a::BigInt,b::BigInt,c::BigInt) at gmp.jl:216",
          "$(a::BigInt,b::BigInt,c::BigInt,d::BigInt) at gmp.jl:222",
          "$(a::BigInt,b::BigInt,c::BigInt,d::BigInt,e::BigInt) at gmp.jl:229",
          "${T<:Integer}(x::T<:Integer,y::T<:Integer) at promotion.jl:196",
          "$(x::Integer,y::Integer) at promotion.jl:166",
          "$(x::Bool,B::BitArray{N}) at bitarray.jl:958",
          "$(x::Integer) at operators.jl:75",
          "${S,T<:Real}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Range{T<:Real}) at array.jl:732",
          "${S<:Real,T}(A::Range{S<:Real},B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:741",
          "$(x::Number,B::BitArray{N}) at bitarray.jl:976",
          "${T}(A::Number,B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:754",
          "$(B::BitArray{N},x::Bool) at bitarray.jl:956",
          "$(B::BitArray{N},x::Number) at bitarray.jl:977",
          "${T}(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Number) at array.jl:761",
          "$(s1::IntSet,s2::IntSet) at deprecated.jl:26",
          "$(a,b,c) at operators.jl:82",
          "$(a,b,c,xs...) at operators.jl:83"
        ]
      },
      {
        "name": "%",
        "summary": "Function",
        "help": "Base.%(x, m)\n\n   Remainder after division. The operator form of \"rem\".\n",
        "methods": 
        [
          "rem(x::Bool,y::Bool) at bool.jl:59",
          "rem(x::Signed,y::Unsigned) at int.jl:82",
          "rem(x::Unsigned,y::Signed) at int.jl:83",
          "rem{T<:Union(Int8,Int64,Int16,Int32)}(x::T<:Union(Int8,Int64,Int16,Int32),y::T<:Union(Int8,Int64,Int16,Int32)) at int.jl:99",
          "rem{T<:Union(Uint16,Uint8,Uint32,Uint64)}(x::T<:Union(Uint16,Uint8,Uint32,Uint64),y::T<:Union(Uint16,Uint8,Uint32,Uint64)) at int.jl:100",
          "rem(x::Int128,y::Int128) at int.jl:595",
          "rem(x::Uint128,y::Uint128) at int.jl:596",
          "rem(x::Float32,y::Float32) at float.jl:137",
          "rem(x::Float64,y::Float64) at float.jl:138",
          "rem(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:113",
          "rem(x::BigInt,y::BigInt) at gmp.jl:193",
          "rem(x::BigFloat,y::BigFloat) at mpfr.jl:527",
          "rem(x::Real,y::Real) at promotion.jl:174",
          "rem{T}(A::Number,B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:754",
          "rem{T}(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Number) at array.jl:761"
        ]
      },
      {
        "name": "&",
        "summary": "Function",
        "help": "Base.&(x, y)\n\n   Bitwise and\n\nBase.Graphics.&(bb1::BoundingBox, bb2::BoundingBox) -> BoundingBox\n\n   Returns the intersection, the largest box contained in both boxes\n",
        "methods": 
        [
          "&(x::Bool,y::Bool) at bool.jl:22",
          "&(x::Int8,y::Int8) at int.jl:122",
          "&(x::Int16,y::Int16) at int.jl:123",
          "&(x::Int32,y::Int32) at int.jl:124",
          "&(x::Int64,y::Int64) at int.jl:125",
          "&(x::Int128,y::Int128) at int.jl:126",
          "&(x::Uint8,y::Uint8) at int.jl:128",
          "&(x::Uint16,y::Uint16) at int.jl:129",
          "&(x::Uint32,y::Uint32) at int.jl:130",
          "&(x::Uint64,y::Uint64) at int.jl:131",
          "&(x::Uint128,y::Uint128) at int.jl:132",
          "&(A::BitArray{N},B::BitArray{N}) at bitarray.jl:963",
          "&(A::DenseArray{Bool,N},B::BitArray{N}) at bitarray.jl:974",
          "&(B::BitArray{N},A::DenseArray{Bool,N}) at bitarray.jl:975",
          "&{S,T}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:724",
          "&(x::Char,y::Char) at char.jl:33",
          "&(x::BigInt,y::BigInt) at gmp.jl:193",
          "&(a::BigInt,b::BigInt,c::BigInt) at gmp.jl:216",
          "&(a::BigInt,b::BigInt,c::BigInt,d::BigInt) at gmp.jl:222",
          "&(a::BigInt,b::BigInt,c::BigInt,d::BigInt,e::BigInt) at gmp.jl:229",
          "&{T<:Integer}(x::T<:Integer,y::T<:Integer) at promotion.jl:194",
          "&(x::Integer,y::Integer) at promotion.jl:164",
          "&(x::Bool,B::BitArray{N}) at bitarray.jl:948",
          "&(x::Integer) at operators.jl:73",
          "&{S,T<:Real}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Range{T<:Real}) at array.jl:732",
          "&{S<:Real,T}(A::Range{S<:Real},B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:741",
          "&(x::Number,B::BitArray{N}) at bitarray.jl:976",
          "&{T}(A::Number,B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:754",
          "&(B::BitArray{N},x::Bool) at bitarray.jl:946",
          "&(B::BitArray{N},x::Number) at bitarray.jl:977",
          "&{T}(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Number) at array.jl:761",
          "&(left::AbstractCmd,right::AbstractCmd) at process.jl:147",
          "&(s::Set{T}...) at deprecated.jl:26",
          "&(s::IntSet,s2::IntSet) at deprecated.jl:26",
          "&(bb1::BoundingBox,bb2::BoundingBox) at graphics.jl:130",
          "&(a,b,c) at operators.jl:82",
          "&(a,b,c,xs...) at operators.jl:83"
        ]
      },
      {
        "name": "*",
        "summary": "Function",
        "help": "Base.*(s, t)\n\n   Concatenate strings. The \"*\" operator is an alias to this\n   function.\n\n   **Example**:\n\n      julia> \"Hello \" * \"world\"\n      \"Hello world\"\n\nBase.*(x, y)\n\n   Binary multiplication operator.\n\nBase.*(A, B)\n\n   Matrix multiplication\n\nBase.Graphics.*(obj, s::Real)\n\n   Scale the width and height of a graphics object, keeping the center\n   fixed\n",
        "methods": 
        [
          "*(x::Bool,y::Bool) at bool.jl:41",
          "*(x::Bool,z::Complex{T<:Real}) at complex.jl:116",
          "*{T<:Number}(x::Bool,y::T<:Number) at bool.jl:52",
          "*(z::Complex{T<:Real},x::Bool) at complex.jl:117",
          "*(y::Number,x::Bool) at bool.jl:55",
          "*{T,S}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{S,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,2})) at linalg/matmul.jl:116",
          "*(A::Union(Symmetric{T},Hermitian{T}),B::Union(Symmetric{T},Hermitian{T})) at linalg/symmetric.jl:35",
          "*(A::Union(Symmetric{T},Hermitian{T}),B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/symmetric.jl:36",
          "*(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(Symmetric{T},Hermitian{T})) at linalg/symmetric.jl:37",
          "*(A::Tridiagonal{T},B::Triangular{T<:Number}) at linalg/triangular.jl:105",
          "*(A::Triangular{T<:Number},B::Triangular{T<:Number}) at linalg/triangular.jl:111",
          "*(Da::Diagonal{T},Db::Diagonal{T}) at linalg/diagonal.jl:44",
          "*(A::Union(Tridiagonal{T},Bidiagonal{T},Triangular{T<:Number},SymTridiagonal{T},Diagonal{T}),B::Union(Tridiagonal{T},Bidiagonal{T},Triangular{T<:Number},SymTridiagonal{T},Diagonal{T})) at linalg/bidiag.jl:113",
          "*{T<:Union(Int8,Int16,Int32)}(x::T<:Union(Int8,Int16,Int32),y::T<:Union(Int8,Int16,Int32)) at int.jl:18",
          "*{T<:Union(Uint16,Uint8,Uint32)}(x::T<:Union(Uint16,Uint8,Uint32),y::T<:Union(Uint16,Uint8,Uint32)) at int.jl:22",
          "*(x::Int64,y::Int64) at int.jl:47",
          "*(x::Uint64,y::Uint64) at int.jl:48",
          "*(x::Int128,y::Int128) at int.jl:589",
          "*(x::Uint128,y::Uint128) at int.jl:590",
          "*(x::Float32,y::Float32) at float.jl:128",
          "*(x::Float64,y::Float64) at float.jl:129",
          "*(z::Complex{T<:Real},w::Complex{T<:Real}) at complex.jl:112",
          "*(x::Real,z::Complex{T<:Real}) at complex.jl:118",
          "*(z::Complex{T<:Real},x::Real) at complex.jl:119",
          "*(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:118",
          "*(a::Float16,b::Float16) at float16.jl:125",
          "*(x::BigInt,y::BigInt) at gmp.jl:193",
          "*(a::BigInt,b::BigInt,c::BigInt) at gmp.jl:216",
          "*(a::BigInt,b::BigInt,c::BigInt,d::BigInt) at gmp.jl:222",
          "*(a::BigInt,b::BigInt,c::BigInt,d::BigInt,e::BigInt) at gmp.jl:229",
          "*(x::BigInt,c::Uint64) at gmp.jl:267",
          "*(c::Uint64,x::BigInt) at gmp.jl:271",
          "*(c::Union(Uint16,Uint8,Uint32,Uint64),x::BigInt) at gmp.jl:272",
          "*(x::BigInt,c::Union(Uint16,Uint8,Uint32,Uint64)) at gmp.jl:273",
          "*(x::BigInt,c::Int64) at gmp.jl:275",
          "*(c::Int64,x::BigInt) at gmp.jl:279",
          "*(x::BigInt,c::Union(Int8,Int64,Int16,Int32)) at gmp.jl:280",
          "*(c::Union(Int8,Int64,Int16,Int32),x::BigInt) at gmp.jl:281",
          "*(x::BigFloat,c::Uint64) at mpfr.jl:232",
          "*(c::Uint64,x::BigFloat) at mpfr.jl:236",
          "*(c::Union(Uint16,Uint8,Uint32,Uint64),x::BigFloat) at mpfr.jl:237",
          "*(x::BigFloat,c::Union(Uint16,Uint8,Uint32,Uint64)) at mpfr.jl:238",
          "*(x::BigFloat,c::Int64) at mpfr.jl:242",
          "*(c::Int64,x::BigFloat) at mpfr.jl:246",
          "*(x::BigFloat,c::Union(Int8,Int64,Int16,Int32)) at mpfr.jl:247",
          "*(c::Union(Int8,Int64,Int16,Int32),x::BigFloat) at mpfr.jl:248",
          "*(x::BigFloat,c::Float64) at mpfr.jl:252",
          "*(c::Float64,x::BigFloat) at mpfr.jl:256",
          "*(c::Float32,x::BigFloat) at mpfr.jl:257",
          "*(x::BigFloat,c::Float32) at mpfr.jl:258",
          "*(x::BigFloat,c::BigInt) at mpfr.jl:262",
          "*(c::BigInt,x::BigFloat) at mpfr.jl:266",
          "*(x::BigFloat,y::BigFloat) at mpfr.jl:321",
          "*(a::BigFloat,b::BigFloat,c::BigFloat) at mpfr.jl:332",
          "*(a::BigFloat,b::BigFloat,c::BigFloat,d::BigFloat) at mpfr.jl:338",
          "*(a::BigFloat,b::BigFloat,c::BigFloat,d::BigFloat,e::BigFloat) at mpfr.jl:345",
          "*(x::MathConst{sym},y::MathConst{sym}) at constants.jl:23",
          "*{T<:Number}(x::T<:Number,y::T<:Number) at promotion.jl:189",
          "*(x::Number,y::Number) at promotion.jl:159",
          "*{T<:Number}(x::T<:Number,D::Diagonal{T}) at linalg/diagonal.jl:41",
          "*(s::Real,p::Vec2) at graphics.jl:64",
          "*(s::Real,bb::BoundingBox) at graphics.jl:151",
          "*(x::Number) at operators.jl:72",
          "*{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),x::Union(DenseArray{S,1},SubArray{S,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:67",
          "*(A::SymTridiagonal{T},B::Number) at linalg/tridiag.jl:46",
          "*(A::Tridiagonal{T},B::Number) at linalg/tridiag.jl:207",
          "*{TX,TvA,TiA}(X::Tridiagonal{TX},A::SparseMatrixCSC{TvA,TiA}) at linalg/sparse.jl:128",
          "*(A::Tridiagonal{T},B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/tridiag.jl:249",
          "*{TA,Tb}(A::Union(QRPackedQ{TA},QRCompactWYQ{TA}),b::Union(DenseArray{Tb,1},SubArray{Tb,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:267",
          "*{TA,TB}(A::Union(QRPackedQ{TA},QRCompactWYQ{TA}),B::Union(DenseArray{TB,2},SubArray{TB,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:273",
          "*{TA,TQ,N}(A::Union(SubArray{TA,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{TA,N}),Q::Union(QRCompactWYQ{TQ},QRPackedQ{TQ})) at linalg/factorization.jl:335",
          "*{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Triangular{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},b::Array{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1}) at linalg/triangular.jl:23",
          "*{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Triangular{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/triangular.jl:28",
          "*{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Triangular{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/triangular.jl:29",
          "*{TvA,TiA}(X::Triangular{T<:Number},A::SparseMatrixCSC{TvA,TiA}) at linalg/sparse.jl:129",
          "*(A::Triangular{T<:Number},B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/triangular.jl:112",
          "*(W::Woodbury{T},B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2},SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/woodbury.jl:70",
          "*{T<:Number}(D::Diagonal{T},x::T<:Number) at linalg/diagonal.jl:42",
          "*(D::Diagonal{T},V::Array{T,1}) at linalg/diagonal.jl:45",
          "*(A::Array{T,2},D::Diagonal{T}) at linalg/diagonal.jl:46",
          "*(D::Diagonal{T},A::Array{T,2}) at linalg/diagonal.jl:47",
          "*(A::Bidiagonal{T},B::Number) at linalg/bidiag.jl:107",
          "*{T}(A::Bidiagonal{T},B::AbstractArray{T,1}) at linalg/bidiag.jl:118",
          "*(B::BitArray{2},J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:68",
          "*(S::SparseMatrixCSC{Tv,Ti<:Integer},J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:70",
          "*{T}(G1::Givens{T},G2::Givens{T}) at linalg/givens.jl:197",
          "*(G::Givens{T},B::BitArray{2}) at linalg/givens.jl:198",
          "*{TBf,TBi}(G::Givens{T},B::SparseMatrixCSC{TBf,TBi}) at linalg/givens.jl:199",
          "*(R::Union(Givens{T},Rotation{T}),A::AbstractArray{T,2}) at linalg/givens.jl:200",
          "*{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti},B::SparseMatrixCSC{Tv,Ti}) at linalg/sparse.jl:143",
          "*{TvA,TiA,TvB,TiB}(A::SparseMatrixCSC{TvA,TiA},B::SparseMatrixCSC{TvB,TiB}) at linalg/sparse.jl:4",
          "*{TvA,TiA}(A::SparseMatrixCSC{TvA,TiA},X::BitArray{1}) at linalg/sparse.jl:11",
          "*{TvA,TiA}(A::SparseMatrixCSC{TvA,TiA},X::BitArray{2}) at linalg/sparse.jl:109",
          "*{TA,S,Tx}(A::SparseMatrixCSC{TA,S},x::AbstractArray{Tx,1}) at linalg/sparse.jl:32",
          "*(X::BitArray{1},A::SparseMatrixCSC{Tv,Ti<:Integer}) at linalg/sparse.jl:95",
          "*{TvA,TiA,TX}(A::SparseMatrixCSC{TvA,TiA},X::AbstractArray{TX,2}) at linalg/sparse.jl:111",
          "*{TvA,TiA}(X::BitArray{2},A::SparseMatrixCSC{TvA,TiA}) at linalg/sparse.jl:126",
          "*{T<:AbstractCalendarDuration}(d::Array{T<:AbstractCalendarDuration,N},i::Integer) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:351",
          "*{T<:Number}(x::AbstractArray{T<:Number,N}) at abstractarray.jl:347",
          "*(B::Number,A::SymTridiagonal{T}) at linalg/tridiag.jl:47",
          "*(B::Number,A::Tridiagonal{T}) at linalg/tridiag.jl:208",
          "*(B::Number,A::Bidiagonal{T}) at linalg/bidiag.jl:108",
          "*(A::Number,B::AbstractArray{T,N}) at abstractarray.jl:351",
          "*(A::AbstractArray{T,N},B::Number) at abstractarray.jl:352",
          "*(s::String...) at string.jl:76",
          "*(A::AbstractArray{T,2},B::Triangular{T<:Number}) at linalg/triangular.jl:113",
          "*{TX,TvA,TiA}(X::AbstractArray{TX,2},A::SparseMatrixCSC{TvA,TiA}) at linalg/sparse.jl:131",
          "*{T,S}(A::AbstractArray{T,2},x::AbstractArray{S,1}) at linalg/matmul.jl:71",
          "*{T1,T2}(X::AbstractArray{T1,1},A::SparseMatrixCSC{T2,Ti<:Integer}) at linalg/sparse.jl:99",
          "*(A::AbstractArray{T,1},B::AbstractArray{T,2}) at linalg/matmul.jl:74",
          "*(J1::UniformScaling{T<:Number},J2::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:67",
          "*(J::UniformScaling{T<:Number},B::BitArray{2}) at linalg/uniformscaling.jl:69",
          "*{Tv,Ti}(J::UniformScaling{T<:Number},S::SparseMatrixCSC{Tv,Ti}) at linalg/uniformscaling.jl:71",
          "*(A::AbstractArray{T,2},J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:72",
          "*(J::UniformScaling{T<:Number},A::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/uniformscaling.jl:73",
          "*(x::Number,J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:75",
          "*(J::UniformScaling{T<:Number},x::Number) at linalg/uniformscaling.jl:76",
          "*{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32},B::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:478",
          "*{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64},B::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:478",
          "*{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},B::CholmodDense{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/cholmod.jl:835",
          "*{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},B::Union(Array{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},Array{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2})) at linalg/cholmod.jl:836",
          "*(p::Vec2,s::Real) at graphics.jl:62",
          "*(bb::BoundingBox,s::Real) at graphics.jl:147",
          "*(d::CalendarDuration,i::Integer) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:349",
          "*(d::FixedCalendarDuration,x::Real) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:350",
          "*{I<:Integer}(d::AbstractCalendarDuration,i::Array{I<:Integer,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:353",
          "*(x,d::AbstractCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:355",
          "*(a,b,c) at operators.jl:82",
          "*(a,b,c,xs...) at operators.jl:83"
        ]
      },
      {
        "name": "+",
        "summary": "Function",
        "help": "Base.+(x, y)\n\n   Binary addition operator.\n\nBase.Graphics.+(bb1::BoundingBox, bb2::BoundingBox) -> BoundingBox\n\n   Returns the smallest box containing both boxes\n",
        "methods": 
        [
          "+(x::Bool) at bool.jl:36",
          "+(x::Bool,y::Bool) at bool.jl:39",
          "+(y::FloatingPoint,x::Bool) at bool.jl:49",
          "+(A::BitArray{N},B::BitArray{N}) at bitarray.jl:852",
          "+(x::Array{CalendarTime,N},y::Array{CalendarDuration,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:340",
          "+(x::Array{CalendarTime,N},y::Array{FixedCalendarDuration,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:341",
          "+(y::Array{CalendarDuration,N},x::Array{CalendarTime,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:342",
          "+(y::Array{FixedCalendarDuration,N},x::Array{CalendarTime,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:343",
          "+(A::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at array.jl:792",
          "+{S,T}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:724",
          "+{T<:Union(Int8,Int16,Int32)}(x::T<:Union(Int8,Int16,Int32),y::T<:Union(Int8,Int16,Int32)) at int.jl:16",
          "+{T<:Union(Uint16,Uint8,Uint32)}(x::T<:Union(Uint16,Uint8,Uint32),y::T<:Union(Uint16,Uint8,Uint32)) at int.jl:20",
          "+(x::Int64,y::Int64) at int.jl:33",
          "+(x::Uint64,y::Uint64) at int.jl:34",
          "+(x::Int128,y::Int128) at int.jl:35",
          "+(x::Uint128,y::Uint128) at int.jl:36",
          "+(x::Float32,y::Float32) at float.jl:124",
          "+(x::Float64,y::Float64) at float.jl:125",
          "+(z::Complex{T<:Real},w::Complex{T<:Real}) at complex.jl:110",
          "+(x::Real,z::Complex{T<:Real}) at complex.jl:120",
          "+(z::Complex{T<:Real},x::Real) at complex.jl:121",
          "+(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:113",
          "+(x::Char,y::Char) at char.jl:23",
          "+(x::Char,y::Integer) at char.jl:26",
          "+(x::Integer,y::Char) at char.jl:27",
          "+(a::Float16,b::Float16) at float16.jl:125",
          "+(x::BigInt,y::BigInt) at gmp.jl:193",
          "+(a::BigInt,b::BigInt,c::BigInt) at gmp.jl:216",
          "+(a::BigInt,b::BigInt,c::BigInt,d::BigInt) at gmp.jl:222",
          "+(a::BigInt,b::BigInt,c::BigInt,d::BigInt,e::BigInt) at gmp.jl:229",
          "+(x::BigInt,c::Uint64) at gmp.jl:241",
          "+(c::Uint64,x::BigInt) at gmp.jl:245",
          "+(c::Union(Uint16,Uint8,Uint32,Uint64),x::BigInt) at gmp.jl:246",
          "+(x::BigInt,c::Union(Uint16,Uint8,Uint32,Uint64)) at gmp.jl:247",
          "+(x::BigInt,c::Union(Int8,Int64,Int16,Int32)) at gmp.jl:248",
          "+(c::Union(Int8,Int64,Int16,Int32),x::BigInt) at gmp.jl:249",
          "+(x::BigFloat,c::Uint64) at mpfr.jl:140",
          "+(c::Uint64,x::BigFloat) at mpfr.jl:144",
          "+(c::Union(Uint16,Uint8,Uint32,Uint64),x::BigFloat) at mpfr.jl:145",
          "+(x::BigFloat,c::Union(Uint16,Uint8,Uint32,Uint64)) at mpfr.jl:146",
          "+(x::BigFloat,c::Int64) at mpfr.jl:150",
          "+(c::Int64,x::BigFloat) at mpfr.jl:154",
          "+(x::BigFloat,c::Union(Int8,Int64,Int16,Int32)) at mpfr.jl:155",
          "+(c::Union(Int8,Int64,Int16,Int32),x::BigFloat) at mpfr.jl:156",
          "+(x::BigFloat,c::Float64) at mpfr.jl:160",
          "+(c::Float64,x::BigFloat) at mpfr.jl:164",
          "+(c::Float32,x::BigFloat) at mpfr.jl:165",
          "+(x::BigFloat,c::Float32) at mpfr.jl:166",
          "+(x::BigFloat,c::BigInt) at mpfr.jl:170",
          "+(c::BigInt,x::BigFloat) at mpfr.jl:174",
          "+(x::BigFloat,y::BigFloat) at mpfr.jl:321",
          "+(a::BigFloat,b::BigFloat,c::BigFloat) at mpfr.jl:332",
          "+(a::BigFloat,b::BigFloat,c::BigFloat,d::BigFloat) at mpfr.jl:338",
          "+(a::BigFloat,b::BigFloat,c::BigFloat,d::BigFloat,e::BigFloat) at mpfr.jl:345",
          "+(x::MathConst{sym},y::MathConst{sym}) at constants.jl:23",
          "+{T<:Number}(x::T<:Number,y::T<:Number) at promotion.jl:188",
          "+{T<:FloatingPoint}(x::Bool,y::T<:FloatingPoint) at bool.jl:46",
          "+(x::Number,y::Number) at promotion.jl:158",
          "+(x::Real,r::UnitRange{T<:Real}) at range.jl:419",
          "+(x::Real,r::FloatRange{T<:FloatingPoint}) at range.jl:422",
          "+(x::Real,r::Range{T}) at range.jl:420",
          "+(r::Range{T},x::Real) at range.jl:423",
          "+(x::Integer,y::Ptr{T}) at pointer.jl:70",
          "+(x::Bool,A::Array{Bool,N}) at deprecated.jl:26",
          "+(x::Number) at operators.jl:71",
          "+(r1::OrdinalRange{T,S},r2::OrdinalRange{T,S}) at operators.jl:320",
          "+{T<:FloatingPoint}(r1::FloatRange{T<:FloatingPoint},r2::FloatRange{T<:FloatingPoint}) at operators.jl:326",
          "+(r1::FloatRange{T<:FloatingPoint},r2::FloatRange{T<:FloatingPoint}) at operators.jl:343",
          "+(r1::FloatRange{T<:FloatingPoint},r2::OrdinalRange{T,S}) at operators.jl:344",
          "+(r1::OrdinalRange{T,S},r2::FloatRange{T<:FloatingPoint}) at operators.jl:345",
          "+(x::Ptr{T},y::Integer) at pointer.jl:68",
          "+{S,T<:Real}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Range{T<:Real}) at array.jl:732",
          "+{S<:Real,T}(A::Range{S<:Real},B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:741",
          "+{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti},B::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:514",
          "+{TvA,TiA,TvB,TiB}(A::SparseMatrixCSC{TvA,TiA},B::SparseMatrixCSC{TvB,TiB}) at sparse/sparsematrix.jl:506",
          "+(A::SparseMatrixCSC{Tv,Ti<:Integer},B::Union(Number,Array{T,N})) at sparse/sparsematrix.jl:604",
          "+(A::Union(Number,Array{T,N}),B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:605",
          "+(A::SymTridiagonal{T},B::SymTridiagonal{T}) at linalg/tridiag.jl:44",
          "+(A::Tridiagonal{T},B::Tridiagonal{T}) at linalg/tridiag.jl:205",
          "+(A::Tridiagonal{T},B::SymTridiagonal{T}) at linalg/special.jl:98",
          "+(A::SymTridiagonal{T},B::Tridiagonal{T}) at linalg/special.jl:97",
          "+(Da::Diagonal{T},Db::Diagonal{T}) at linalg/diagonal.jl:38",
          "+(A::Bidiagonal{T},B::Bidiagonal{T}) at linalg/bidiag.jl:91",
          "+{T}(B::BitArray{2},J::UniformScaling{T}) at linalg/uniformscaling.jl:26",
          "+(A::Diagonal{T},B::Bidiagonal{T}) at linalg/special.jl:88",
          "+(A::Bidiagonal{T},B::Diagonal{T}) at linalg/special.jl:89",
          "+(A::Diagonal{T},B::Tridiagonal{T}) at linalg/special.jl:88",
          "+(A::Tridiagonal{T},B::Diagonal{T}) at linalg/special.jl:89",
          "+(A::Diagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:88",
          "+(A::Triangular{T<:Number},B::Diagonal{T}) at linalg/special.jl:89",
          "+(A::Diagonal{T},B::Array{T,2}) at linalg/special.jl:88",
          "+(A::Array{T,2},B::Diagonal{T}) at linalg/special.jl:89",
          "+(A::Bidiagonal{T},B::Tridiagonal{T}) at linalg/special.jl:88",
          "+(A::Tridiagonal{T},B::Bidiagonal{T}) at linalg/special.jl:89",
          "+(A::Bidiagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:88",
          "+(A::Triangular{T<:Number},B::Bidiagonal{T}) at linalg/special.jl:89",
          "+(A::Bidiagonal{T},B::Array{T,2}) at linalg/special.jl:88",
          "+(A::Array{T,2},B::Bidiagonal{T}) at linalg/special.jl:89",
          "+(A::Tridiagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:88",
          "+(A::Triangular{T<:Number},B::Tridiagonal{T}) at linalg/special.jl:89",
          "+(A::Tridiagonal{T},B::Array{T,2}) at linalg/special.jl:88",
          "+(A::Array{T,2},B::Tridiagonal{T}) at linalg/special.jl:89",
          "+(A::Triangular{T<:Number},B::Array{T,2}) at linalg/special.jl:88",
          "+(A::Array{T,2},B::Triangular{T<:Number}) at linalg/special.jl:89",
          "+(A::SymTridiagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:97",
          "+(A::Triangular{T<:Number},B::SymTridiagonal{T}) at linalg/special.jl:98",
          "+(A::SymTridiagonal{T},B::Array{T,2}) at linalg/special.jl:97",
          "+(A::Array{T,2},B::SymTridiagonal{T}) at linalg/special.jl:98",
          "+(A::Diagonal{T},B::SymTridiagonal{T}) at linalg/special.jl:106",
          "+(A::SymTridiagonal{T},B::Diagonal{T}) at linalg/special.jl:107",
          "+(A::Bidiagonal{T},B::SymTridiagonal{T}) at linalg/special.jl:106",
          "+(A::SymTridiagonal{T},B::Bidiagonal{T}) at linalg/special.jl:107",
          "+(A::Array{Bool,N},x::Bool) at deprecated.jl:26",
          "+(A::Array{T,N},x::Number) at deprecated.jl:26",
          "+{T<:Number}(x::AbstractArray{T<:Number,N}) at abstractarray.jl:346",
          "+(J1::UniformScaling{T<:Number},J2::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:25",
          "+(J::UniformScaling{T<:Number},B::BitArray{2}) at linalg/uniformscaling.jl:27",
          "+(J::UniformScaling{T<:Number},A::AbstractArray{T,2}) at linalg/uniformscaling.jl:28",
          "+(J::UniformScaling{T<:Number},x::Number) at linalg/uniformscaling.jl:29",
          "+(x::Number,J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:30",
          "+{TA,TJ}(A::AbstractArray{TA,2},J::UniformScaling{TJ}) at linalg/uniformscaling.jl:33",
          "+(x::Number,A::Array{T,N}) at deprecated.jl:26",
          "+{T}(a::HierarchicalValue{T},b::HierarchicalValue{T}) at pkg/resolve/versionweight.jl:19",
          "+(a::VWPreBuildItem,b::VWPreBuildItem) at pkg/resolve/versionweight.jl:82",
          "+(a::VWPreBuild,b::VWPreBuild) at pkg/resolve/versionweight.jl:120",
          "+(a::VersionWeight,b::VersionWeight) at pkg/resolve/versionweight.jl:164",
          "+(a::FieldValue,b::FieldValue) at pkg/resolve/fieldvalue.jl:41",
          "+(a::Vec2,b::Vec2) at graphics.jl:60",
          "+(bb1::BoundingBox,bb2::BoundingBox) at graphics.jl:123",
          "+(d1::CalendarDuration,d2::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:298",
          "+(d::CalendarDuration,f::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:304",
          "+(f::FixedCalendarDuration,d::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:310",
          "+(d1::FixedCalendarDuration,d2::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:316",
          "+(t::CalendarTime,d::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:320",
          "+(t::CalendarTime,d::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:332",
          "+(d::AbstractCalendarDuration,t::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:335",
          "+{T1<:Union(CalendarTime,AbstractCalendarDuration),T2<:Union(CalendarTime,AbstractCalendarDuration)}(::T1<:Union(CalendarTime,AbstractCalendarDuration),::AbstractArray{T2<:Union(CalendarTime,AbstractCalendarDuration),N}) at operators.jl:365",
          "+{T1<:Union(CalendarTime,AbstractCalendarDuration),T2<:Union(CalendarTime,AbstractCalendarDuration)}(::AbstractArray{T1<:Union(CalendarTime,AbstractCalendarDuration),N},::T2<:Union(CalendarTime,AbstractCalendarDuration)) at operators.jl:367",
          "+{T1<:Union(CalendarTime,AbstractCalendarDuration),T2<:Union(CalendarTime,AbstractCalendarDuration)}(::AbstractArray{T1<:Union(CalendarTime,AbstractCalendarDuration),N},::AbstractArray{T2<:Union(CalendarTime,AbstractCalendarDuration),N}) at operators.jl:371",
          "+(a,b,c) at operators.jl:82",
          "+(a,b,c,xs...) at operators.jl:83"
        ]
      },
      {
        "name": "-",
        "summary": "Function",
        "help": "Base.-(x)\n\n   Unary minus operator.\n\nBase.-(x, y)\n\n   Binary subtraction operator.\n",
        "methods": 
        [
          "-(x::Bool) at bool.jl:37",
          "-(x::Bool,y::Bool) at bool.jl:40",
          "-(x::Union(Int8,Int16,Int32)) at int.jl:13",
          "-(x::Union(Uint16,Uint8,Uint32)) at int.jl:14",
          "-(B::BitArray{2},J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:44",
          "-(B::BitArray{N}) at bitarray.jl:793",
          "-(A::BitArray{N},B::BitArray{N}) at bitarray.jl:852",
          "-(x::Int64) at int.jl:26",
          "-(x::Uint64) at int.jl:27",
          "-(x::Int128) at int.jl:28",
          "-(x::Uint128) at int.jl:29",
          "-(x::Float32) at float.jl:121",
          "-(x::Float64) at float.jl:122",
          "-(z::Complex{T<:Real}) at complex.jl:109",
          "-(x::Rational{T<:Integer}) at rational.jl:109",
          "-(x::Float16) at float16.jl:122",
          "-(x::BigInt) at gmp.jl:287",
          "-(x::BigFloat) at mpfr.jl:356",
          "-(x::MathConst{sym}) at constants.jl:21",
          "-(A::Union(Number,Array{T,N}),B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:608",
          "-(A::Array{T,2},B::Diagonal{T}) at linalg/special.jl:89",
          "-(A::Array{T,2},B::Bidiagonal{T}) at linalg/special.jl:89",
          "-(A::Array{T,2},B::Tridiagonal{T}) at linalg/special.jl:89",
          "-(A::Array{T,2},B::Triangular{T<:Number}) at linalg/special.jl:89",
          "-(A::Array{T,2},B::SymTridiagonal{T}) at linalg/special.jl:98",
          "-(A::Array{Bool,N},x::Bool) at deprecated.jl:26",
          "-(A::Array{T,N},x::Number) at deprecated.jl:26",
          "-(x::Array{CalendarTime,N},y::Array{CalendarDuration,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:340",
          "-(x::Array{CalendarTime,N},y::Array{FixedCalendarDuration,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:341",
          "-(y::Array{CalendarDuration,N},x::Array{CalendarTime,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:342",
          "-(y::Array{FixedCalendarDuration,N},x::Array{CalendarTime,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:343",
          "-(A::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at array.jl:676",
          "-(A::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at array.jl:792",
          "-(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:667",
          "-{S,T}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:724",
          "-{T<:Union(Int8,Int16,Int32)}(x::T<:Union(Int8,Int16,Int32),y::T<:Union(Int8,Int16,Int32)) at int.jl:17",
          "-{T<:Union(Uint16,Uint8,Uint32)}(x::T<:Union(Uint16,Uint8,Uint32),y::T<:Union(Uint16,Uint8,Uint32)) at int.jl:21",
          "-(x::Int64,y::Int64) at int.jl:40",
          "-(x::Uint64,y::Uint64) at int.jl:41",
          "-(x::Int128,y::Int128) at int.jl:42",
          "-(x::Uint128,y::Uint128) at int.jl:43",
          "-(x::Float32,y::Float32) at float.jl:126",
          "-(x::Float64,y::Float64) at float.jl:127",
          "-(z::Complex{T<:Real},w::Complex{T<:Real}) at complex.jl:111",
          "-(x::Real,z::Complex{T<:Real}) at complex.jl:122",
          "-(z::Complex{T<:Real},x::Real) at complex.jl:123",
          "-(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:113",
          "-(x::Char,y::Char) at char.jl:28",
          "-(x::Char,y::Integer) at char.jl:29",
          "-(a::Float16,b::Float16) at float16.jl:125",
          "-(x::BigInt,y::BigInt) at gmp.jl:193",
          "-(x::BigInt,c::Uint64) at gmp.jl:252",
          "-(c::Uint64,x::BigInt) at gmp.jl:257",
          "-(x::BigInt,c::Union(Uint16,Uint8,Uint32,Uint64)) at gmp.jl:261",
          "-(c::Union(Uint16,Uint8,Uint32,Uint64),x::BigInt) at gmp.jl:262",
          "-(x::BigInt,c::Union(Int8,Int64,Int16,Int32)) at gmp.jl:263",
          "-(c::Union(Int8,Int64,Int16,Int32),x::BigInt) at gmp.jl:264",
          "-(x::BigFloat,c::Uint64) at mpfr.jl:178",
          "-(c::Uint64,x::BigFloat) at mpfr.jl:183",
          "-(x::BigFloat,c::Union(Uint16,Uint8,Uint32,Uint64)) at mpfr.jl:187",
          "-(c::Union(Uint16,Uint8,Uint32,Uint64),x::BigFloat) at mpfr.jl:188",
          "-(x::BigFloat,c::Int64) at mpfr.jl:192",
          "-(c::Int64,x::BigFloat) at mpfr.jl:197",
          "-(x::BigFloat,c::Union(Int8,Int64,Int16,Int32)) at mpfr.jl:201",
          "-(c::Union(Int8,Int64,Int16,Int32),x::BigFloat) at mpfr.jl:202",
          "-(x::BigFloat,c::Float64) at mpfr.jl:206",
          "-(c::Float64,x::BigFloat) at mpfr.jl:211",
          "-(x::BigFloat,c::Float32) at mpfr.jl:215",
          "-(c::Float32,x::BigFloat) at mpfr.jl:216",
          "-(x::BigFloat,c::BigInt) at mpfr.jl:220",
          "-(c::BigInt,x::BigFloat) at mpfr.jl:225",
          "-(x::BigFloat,y::BigFloat) at mpfr.jl:321",
          "-(x::MathConst{sym},y::MathConst{sym}) at constants.jl:23",
          "-{T<:Number}(x::T<:Number,y::T<:Number) at promotion.jl:190",
          "-(x::Number,y::Number) at promotion.jl:160",
          "-(r::UnitRange{T<:Real},x::Real) at range.jl:428",
          "-(r::StepRange{T,S},x::Real) at range.jl:429",
          "-(r::OrdinalRange{T,S}) at range.jl:416",
          "-(r::FloatRange{T<:FloatingPoint}) at range.jl:417",
          "-(x::Real,r::FloatRange{T<:FloatingPoint}) at range.jl:427",
          "-(x::Real,r::Range{T}) at range.jl:426",
          "-(r::FloatRange{T<:FloatingPoint},x::Real) at range.jl:430",
          "-(r1::OrdinalRange{T,S},r2::OrdinalRange{T,S}) at operators.jl:320",
          "-{T<:FloatingPoint}(r1::FloatRange{T<:FloatingPoint},r2::FloatRange{T<:FloatingPoint}) at operators.jl:326",
          "-(r1::FloatRange{T<:FloatingPoint},r2::FloatRange{T<:FloatingPoint}) at operators.jl:343",
          "-(r1::FloatRange{T<:FloatingPoint},r2::OrdinalRange{T,S}) at operators.jl:344",
          "-(r1::OrdinalRange{T,S},r2::FloatRange{T<:FloatingPoint}) at operators.jl:345",
          "-(x::Ptr{T},y::Ptr{T}) at pointer.jl:66",
          "-(x::Ptr{T},y::Integer) at pointer.jl:69",
          "-{S,T<:Real}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Range{T<:Real}) at array.jl:732",
          "-{S<:Real,T}(A::Range{S<:Real},B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:741",
          "-(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:464",
          "-{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti},B::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:514",
          "-{TvA,TiA,TvB,TiB}(A::SparseMatrixCSC{TvA,TiA},B::SparseMatrixCSC{TvB,TiB}) at sparse/sparsematrix.jl:506",
          "-(A::SparseMatrixCSC{Tv,Ti<:Integer},B::Union(Number,Array{T,N})) at sparse/sparsematrix.jl:607",
          "-(A::SymTridiagonal{T},B::SymTridiagonal{T}) at linalg/tridiag.jl:45",
          "-(A::Tridiagonal{T},B::Tridiagonal{T}) at linalg/tridiag.jl:206",
          "-(A::Tridiagonal{T},B::SymTridiagonal{T}) at linalg/special.jl:98",
          "-(A::SymTridiagonal{T},B::Tridiagonal{T}) at linalg/special.jl:97",
          "-(Da::Diagonal{T},Db::Diagonal{T}) at linalg/diagonal.jl:39",
          "-(A::Bidiagonal{T},B::Bidiagonal{T}) at linalg/bidiag.jl:99",
          "-(A::Bidiagonal{T}) at linalg/bidiag.jl:106",
          "-(J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:42",
          "-(J1::UniformScaling{T<:Number},J2::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:43",
          "-(J::UniformScaling{T<:Number},B::BitArray{2}) at linalg/uniformscaling.jl:45",
          "-(J::UniformScaling{T<:Number},x::Number) at linalg/uniformscaling.jl:46",
          "-(x::Number,J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:47",
          "-{T<:AbstractCalendarDuration}(::AbstractArray{T<:AbstractCalendarDuration,2}) at operators.jl:355",
          "-{TA,TJ<:Number}(A::AbstractArray{TA,2},J::UniformScaling{TJ<:Number}) at linalg/uniformscaling.jl:50",
          "-{TA,TJ<:Number}(J::UniformScaling{TJ<:Number},A::AbstractArray{TA,2}) at linalg/uniformscaling.jl:59",
          "-(A::Diagonal{T},B::Bidiagonal{T}) at linalg/special.jl:88",
          "-(A::Bidiagonal{T},B::Diagonal{T}) at linalg/special.jl:89",
          "-(A::Diagonal{T},B::Tridiagonal{T}) at linalg/special.jl:88",
          "-(A::Tridiagonal{T},B::Diagonal{T}) at linalg/special.jl:89",
          "-(A::Diagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:88",
          "-(A::Triangular{T<:Number},B::Diagonal{T}) at linalg/special.jl:89",
          "-(A::Diagonal{T},B::Array{T,2}) at linalg/special.jl:88",
          "-(A::Bidiagonal{T},B::Tridiagonal{T}) at linalg/special.jl:88",
          "-(A::Tridiagonal{T},B::Bidiagonal{T}) at linalg/special.jl:89",
          "-(A::Bidiagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:88",
          "-(A::Triangular{T<:Number},B::Bidiagonal{T}) at linalg/special.jl:89",
          "-(A::Bidiagonal{T},B::Array{T,2}) at linalg/special.jl:88",
          "-(A::Tridiagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:88",
          "-(A::Triangular{T<:Number},B::Tridiagonal{T}) at linalg/special.jl:89",
          "-(A::Tridiagonal{T},B::Array{T,2}) at linalg/special.jl:88",
          "-(A::Triangular{T<:Number},B::Array{T,2}) at linalg/special.jl:88",
          "-(A::SymTridiagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:97",
          "-(A::Triangular{T<:Number},B::SymTridiagonal{T}) at linalg/special.jl:98",
          "-(A::SymTridiagonal{T},B::Array{T,2}) at linalg/special.jl:97",
          "-(A::Diagonal{T},B::SymTridiagonal{T}) at linalg/special.jl:106",
          "-(A::SymTridiagonal{T},B::Diagonal{T}) at linalg/special.jl:107",
          "-(A::Bidiagonal{T},B::SymTridiagonal{T}) at linalg/special.jl:106",
          "-(A::SymTridiagonal{T},B::Bidiagonal{T}) at linalg/special.jl:107",
          "-(a::Set{T},b::Set{T}) at deprecated.jl:26",
          "-(a::IntSet,b::IntSet) at deprecated.jl:26",
          "-(x::Bool,A::Array{Bool,N}) at deprecated.jl:26",
          "-(x::Number,A::Array{T,N}) at deprecated.jl:26",
          "-{T}(a::HierarchicalValue{T},b::HierarchicalValue{T}) at pkg/resolve/versionweight.jl:19",
          "-{T}(a::HierarchicalValue{T}) at pkg/resolve/versionweight.jl:41",
          "-(a::VWPreBuildItem,b::VWPreBuildItem) at pkg/resolve/versionweight.jl:81",
          "-(a::VWPreBuildItem) at pkg/resolve/versionweight.jl:84",
          "-(a::VWPreBuild,b::VWPreBuild) at pkg/resolve/versionweight.jl:119",
          "-(a::VWPreBuild) at pkg/resolve/versionweight.jl:122",
          "-(a::VersionWeight,b::VersionWeight) at pkg/resolve/versionweight.jl:159",
          "-(a::VersionWeight) at pkg/resolve/versionweight.jl:169",
          "-(a::FieldValue,b::FieldValue) at pkg/resolve/fieldvalue.jl:40",
          "-(a::Vec2,b::Vec2) at graphics.jl:61",
          "-(d1::CalendarDuration,d2::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:298",
          "-(d::CalendarDuration,f::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:304",
          "-(f::FixedCalendarDuration,d::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:310",
          "-(d1::FixedCalendarDuration,d2::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:316",
          "-(t::CalendarTime,d::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:320",
          "-(t::CalendarTime,d::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:332",
          "-(d::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:362",
          "-(d::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:363",
          "-(d::AbstractCalendarDuration,t::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:335",
          "-{T1<:CalendarTime,T2<:CalendarTime}(::T1<:CalendarTime,::AbstractArray{T2<:CalendarTime,N}) at operators.jl:365",
          "-{T1<:Union(CalendarTime,AbstractCalendarDuration),T2<:Union(CalendarTime,AbstractCalendarDuration)}(::T1<:Union(CalendarTime,AbstractCalendarDuration),::AbstractArray{T2<:Union(CalendarTime,AbstractCalendarDuration),N}) at operators.jl:365",
          "-{T1<:CalendarTime,T2<:CalendarTime}(::AbstractArray{T1<:CalendarTime,N},::T2<:CalendarTime) at operators.jl:367",
          "-{T<:AbstractCalendarDuration}(::AbstractArray{T<:AbstractCalendarDuration,1}) at operators.jl:354",
          "-{T<:AbstractCalendarDuration}(::AbstractArray{T<:AbstractCalendarDuration,N}) at operators.jl:357",
          "-{T1<:Union(CalendarTime,AbstractCalendarDuration),T2<:Union(CalendarTime,AbstractCalendarDuration)}(::AbstractArray{T1<:Union(CalendarTime,AbstractCalendarDuration),N},::T2<:Union(CalendarTime,AbstractCalendarDuration)) at operators.jl:367",
          "-{T1<:CalendarTime,T2<:CalendarTime}(::AbstractArray{T1<:CalendarTime,N},::AbstractArray{T2<:CalendarTime,N}) at operators.jl:371",
          "-{T1<:Union(CalendarTime,AbstractCalendarDuration),T2<:Union(CalendarTime,AbstractCalendarDuration)}(::AbstractArray{T1<:Union(CalendarTime,AbstractCalendarDuration),N},::AbstractArray{T2<:Union(CalendarTime,AbstractCalendarDuration),N}) at operators.jl:371",
          "-(t1::CalendarTime,t2::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:359"
        ]
      },
      {
        "name": ".!=",
        "summary": "Function",
        "help": "Base..!=(x, y)\n\n   Element-wise not-equals comparison operator.\n",
        "methods": 
        [
          ".!=(x::Number,y::Number) at operators.jl:101",
          ".!=(A::AbstractArray{Bool,N},B::AbstractArray{Bool,N}) at broadcast.jl:325",
          ".!=(A::AbstractArray{T,N},B::AbstractArray{T,N}) at broadcast.jl:322",
          ".!=(A,B::AbstractArray{T,N}) at broadcast.jl:374",
          ".!=(A::AbstractArray{T,N},B) at broadcast.jl:374"
        ]
      },
      {
        "name": ".*",
        "summary": "Function",
        "help": "Base..*(x, y)\n\n   Element-wise binary multiplication operator.\n",
        "methods": 
        [
          ".*(x::Real,r::OrdinalRange{T,S}) at range.jl:432",
          ".*(x::Real,r::FloatRange{T<:FloatingPoint}) at range.jl:433",
          ".*(r::FloatRange{T<:FloatingPoint},x::Real) at range.jl:435",
          ".*(r::Range{T},x::Real) at range.jl:434",
          ".*(x::Number,y::Number) at operators.jl:95",
          ".*(x::Bool,B::BitArray{N}) at bitarray.jl:1048",
          ".*(x::Number,B::BitArray{N}) at bitarray.jl:1050",
          ".*{T}(A::Number,B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:754",
          ".*(B::BitArray{N},x::Bool) at bitarray.jl:1049",
          ".*(B::BitArray{N},x::Number) at bitarray.jl:1051",
          ".*{T<:AbstractCalendarDuration}(d::Array{T<:AbstractCalendarDuration,N},i::Integer) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:351",
          ".*{T}(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Number) at array.jl:761",
          ".*{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti},B::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:514",
          ".*{TvA,TiA,TvB,TiB}(A::SparseMatrixCSC{TvA,TiA},B::SparseMatrixCSC{TvB,TiB}) at sparse/sparsematrix.jl:506",
          ".*(A::SparseMatrixCSC{Tv,Ti<:Integer},B::Number) at sparse/sparsematrix.jl:610",
          ".*(A::Number,B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:611",
          ".*(A::SparseMatrixCSC{Tv,Ti<:Integer},B::Array{T,N}) at sparse/sparsematrix.jl:612",
          ".*(A::Array{T,N},B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:613",
          ".*(x::Number,J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:91",
          ".*(J::UniformScaling{T<:Number},x::Number) at linalg/uniformscaling.jl:92",
          ".*(A::BitArray{N},B::BitArray{N}) at broadcast.jl:435",
          ".*(A::AbstractArray{Bool,N},B::BitArray{N}) at broadcast.jl:435",
          ".*(A::BitArray{N},B::AbstractArray{Bool,N}) at broadcast.jl:435",
          ".*(As::AbstractArray{T,N}...) at broadcast.jl:278",
          ".*(d::CalendarDuration,i::Integer) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:349",
          ".*(d::FixedCalendarDuration,x::Real) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:350",
          ".*{I<:Integer}(d::AbstractCalendarDuration,i::Array{I<:Integer,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:353",
          ".*(x,d::AbstractCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:355"
        ]
      },
      {
        "name": ".+",
        "summary": "Function",
        "help": "Base..+(x, y)\n\n   Element-wise binary addition operator.\n",
        "methods": 
        [
          ".+(x::Bool,B::BitArray{N}) at bitarray.jl:871",
          ".+(A::Bool,B::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at array.jl:774",
          ".+(x::Number,B::BitArray{N}) at bitarray.jl:871",
          ".+{T}(A::Number,B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:754",
          ".+(B::BitArray{N},x::Bool) at bitarray.jl:871",
          ".+(A::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Bool) at array.jl:781",
          ".+(B::BitArray{N},x::Number) at bitarray.jl:871",
          ".+{T}(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Number) at array.jl:761",
          ".+(As::AbstractArray{T,N}...) at broadcast.jl:284",
          ".+(x,y) at operators.jl:97"
        ]
      },
      {
        "name": ".-",
        "summary": "Function",
        "help": "Base..-(x, y)\n\n   Element-wise binary subtraction operator.\n",
        "methods": 
        [
          ".-(x::Bool,B::BitArray{N}) at bitarray.jl:871",
          ".-(A::Bool,B::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at array.jl:774",
          ".-(x::Number,B::BitArray{N}) at bitarray.jl:871",
          ".-{T}(A::Number,B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:754",
          ".-(B::BitArray{N},x::Bool) at bitarray.jl:871",
          ".-(A::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Bool) at array.jl:781",
          ".-(B::BitArray{N},x::Number) at bitarray.jl:871",
          ".-{T}(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Number) at array.jl:761",
          ".-(A::AbstractArray{T,N},B::AbstractArray{T,N}) at broadcast.jl:290",
          ".-(x,y) at operators.jl:98"
        ]
      },
      {
        "name": "./",
        "summary": "Function",
        "help": "Base../(x, y)\n\n   Element-wise binary left division operator.\n",
        "methods": 
        [
          "./(r::OrdinalRange{T,S},x::Real) at range.jl:437",
          "./(r::FloatRange{T<:FloatingPoint},x::Real) at range.jl:438",
          "./(x::Number,r::Range{T}) at range.jl:454",
          "./(r::Range{T},y::Number) at range.jl:455",
          "./(x::Number,y::Number) at operators.jl:93",
          "./{T<:Integer}(x::Integer,y::Union(SubArray{T<:Integer,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Integer,N})) at array.jl:699",
          "./{T<:Integer}(x::Union(SubArray{T<:Integer,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Integer,N}),y::Integer) at array.jl:701",
          "./{T<:Integer}(x::Integer,y::Union(DenseArray{Complex{T<:Integer},N},SubArray{Complex{T<:Integer},N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at array.jl:704",
          "./{T<:Integer}(x::Union(DenseArray{Complex{T<:Integer},N},SubArray{Complex{T<:Integer},N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),y::Integer) at array.jl:706",
          "./{S<:Integer,T<:Integer}(x::Complex{S<:Integer},y::Union(SubArray{T<:Integer,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Integer,N})) at array.jl:708",
          "./{S<:Integer,T<:Integer}(x::Union(DenseArray{S<:Integer,N},SubArray{S<:Integer,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),y::Complex{T<:Integer}) at array.jl:710",
          "./{T}(A::Number,B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:754",
          "./{T}(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Number) at array.jl:761",
          "./(A::SparseMatrixCSC{Tv,Ti<:Integer},B::Number) at sparse/sparsematrix.jl:615",
          "./(A::Number,B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:616",
          "./(A::SparseMatrixCSC{Tv,Ti<:Integer},B::Array{T,N}) at sparse/sparsematrix.jl:617",
          "./(A::Array{T,N},B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:618",
          "./(A::SparseMatrixCSC{Tv,Ti<:Integer},B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:619",
          "./(J::UniformScaling{T<:Number},x::Number) at linalg/uniformscaling.jl:94",
          "./(A::AbstractArray{T,N},B::AbstractArray{T,N}) at broadcast.jl:300"
        ]
      },
      {
        "name": ".<",
        "summary": "Function",
        "help": "Base..<(x, y)\n\n   Element-wise less-than comparison operator.\n",
        "methods": 
        [
          ".<(x::Real,y::Real) at operators.jl:102",
          ".<{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti},B::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:514",
          ".<{TvA,TiA,TvB,TiB}(A::SparseMatrixCSC{TvA,TiA},B::SparseMatrixCSC{TvB,TiB}) at sparse/sparsematrix.jl:506",
          ".<(A::SparseMatrixCSC{Tv,Ti<:Integer},B::Number) at sparse/sparsematrix.jl:634",
          ".<(A::Number,B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:635",
          ".<(A::AbstractArray{Bool,N},B::AbstractArray{Bool,N}) at broadcast.jl:325",
          ".<(A::AbstractArray{T,N},B::AbstractArray{T,N}) at broadcast.jl:322",
          ".<(A,B::AbstractArray{T,N}) at broadcast.jl:374",
          ".<(A::AbstractArray{T,N},B) at broadcast.jl:374"
        ]
      },
      {
        "name": ".<=",
        "summary": "Function",
        "help": "Base..<=(x, y)\n\n   Element-wise less-than-or-equals comparison operator.\n",
        "methods": 
        [
          ".<=(x::Real,y::Real) at operators.jl:103",
          ".<=(A::AbstractArray{Bool,N},B::AbstractArray{Bool,N}) at broadcast.jl:325",
          ".<=(A::AbstractArray{T,N},B::AbstractArray{T,N}) at broadcast.jl:322",
          ".<=(A,B::AbstractArray{T,N}) at broadcast.jl:374",
          ".<=(A::AbstractArray{T,N},B) at broadcast.jl:374"
        ]
      },
      {
        "name": ".==",
        "summary": "Function",
        "help": "Base..==(x, y)\n\n   Element-wise equality comparison operator.\n",
        "methods": 
        [
          ".==(x::Number,y::Number) at operators.jl:100",
          ".==(A::AbstractArray{Bool,N},B::AbstractArray{Bool,N}) at broadcast.jl:325",
          ".==(A::AbstractArray{T,N},B::AbstractArray{T,N}) at broadcast.jl:322",
          ".==(A,B::AbstractArray{T,N}) at broadcast.jl:374",
          ".==(A::AbstractArray{T,N},B) at broadcast.jl:374"
        ]
      },
      {
        "name": ".>",
        "summary": "Function",
        "help": "Base..>(x, y)\n\n   Element-wise greater-than comparison operator.\n\nBase..>(command, filename)\n\n   Redirect the standard error stream of a process.\n",
        "methods": 
        [
          ".>(src::AbstractCmd,dest::AbstractCmd) at process.jl:149",
          ".>(src::AbstractCmd,dest::Union(AsyncStream,File,RawFD,IOStream,FileRedirect)) at process.jl:154",
          ".>(src::AbstractCmd,dest::String) at process.jl:159",
          ".>(x,y) at operators.jl:38"
        ]
      },
      {
        "name": ".>=",
        "summary": "Function",
        "help": "Base..>=(x, y)\n\n   Element-wise greater-than-or-equals comparison operator.\n",
        "methods": 
        [
          ".>=(x,y) at operators.jl:39"
        ]
      },
      {
        "name": ".\\",
        "summary": "Function",
        "help": "Base..\\(x, y)\n\n   Element-wise binary right division operator.\n",
        "methods": 
        [
          ".\\(x::Number,y::Number) at operators.jl:94",
          ".\\{T}(A::Number,B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:754",
          ".\\{T}(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Number) at array.jl:761",
          ".\\(A::SparseMatrixCSC{Tv,Ti<:Integer},B::Number) at sparse/sparsematrix.jl:621",
          ".\\(A::Number,B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:622",
          ".\\(A::SparseMatrixCSC{Tv,Ti<:Integer},B::Array{T,N}) at sparse/sparsematrix.jl:623",
          ".\\(A::Array{T,N},B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:624",
          ".\\(A::SparseMatrixCSC{Tv,Ti<:Integer},B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:625",
          ".\\(A::AbstractArray{T,N},B::AbstractArray{T,N}) at broadcast.jl:304"
        ]
      },
      {
        "name": ".^",
        "summary": "Function",
        "help": "Base..^(x, y)\n\n   Element-wise binary exponentiation operator.\n",
        "methods": 
        [
          ".^(::MathConst{:e},x::Range{T}) at constants.jl:77",
          ".^(x::Number,r::Range{T}) at range.jl:457",
          ".^(r::Range{T},y::Number) at range.jl:458",
          ".^(x::Number,y::Number) at operators.jl:96",
          ".^(x::Bool,B::BitArray{N}) at bitarray.jl:985",
          ".^(::MathConst{:e},x::BitArray{N}) at constants.jl:77",
          ".^(x::Number,B::BitArray{N}) at bitarray.jl:988",
          ".^(::MathConst{:e},x::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at constants.jl:77",
          ".^(x::Number,y::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:715",
          ".^(B::BitArray{N},x::Bool) at bitarray.jl:982",
          ".^(B::BitArray{N},x::Integer) at bitarray.jl:993",
          ".^{T<:Number}(B::BitArray{N},x::T<:Number) at bitarray.jl:1002",
          ".^(x::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),y::Number) at array.jl:718",
          ".^(A::SparseMatrixCSC{Tv,Ti<:Integer},B::Number) at sparse/sparsematrix.jl:627",
          ".^(::MathConst{:e},x::SparseMatrixCSC{Tv,Ti<:Integer}) at constants.jl:77",
          ".^(A::Number,B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:630",
          ".^(A::SparseMatrixCSC{Tv,Ti<:Integer},B::Array{T,N}) at sparse/sparsematrix.jl:631",
          ".^(A::Array{T,N},B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:632",
          ".^{T<:Integer}(A::BitArray{N},B::Array{T<:Integer,N}) at broadcast.jl:409",
          ".^(A::BitArray{N},B::AbstractArray{Bool,N}) at broadcast.jl:394",
          ".^(A::AbstractArray{Bool,N},B::AbstractArray{Bool,N}) at broadcast.jl:395",
          ".^(A::AbstractArray{T,N},B::AbstractArray{T,N}) at broadcast.jl:312",
          ".^(::MathConst{:e},x::AbstractArray{T,N}) at constants.jl:77"
        ]
      },
      {
        "name": ".≠",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          ".!=(x::Number,y::Number) at operators.jl:101",
          ".!=(A::AbstractArray{Bool,N},B::AbstractArray{Bool,N}) at broadcast.jl:325",
          ".!=(A::AbstractArray{T,N},B::AbstractArray{T,N}) at broadcast.jl:322",
          ".!=(A,B::AbstractArray{T,N}) at broadcast.jl:374",
          ".!=(A::AbstractArray{T,N},B) at broadcast.jl:374"
        ]
      },
      {
        "name": ".≤",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          ".<=(x::Real,y::Real) at operators.jl:103",
          ".<=(A::AbstractArray{Bool,N},B::AbstractArray{Bool,N}) at broadcast.jl:325",
          ".<=(A::AbstractArray{T,N},B::AbstractArray{T,N}) at broadcast.jl:322",
          ".<=(A,B::AbstractArray{T,N}) at broadcast.jl:374",
          ".<=(A::AbstractArray{T,N},B) at broadcast.jl:374"
        ]
      },
      {
        "name": ".≥",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          ".>=(x,y) at operators.jl:39"
        ]
      },
      {
        "name": "/",
        "summary": "Function",
        "help": "Base./(x, y)\n\n   Binary left-division operator.\n",
        "methods": 
        [
          "/(x::Integer,y::Integer) at int.jl:50",
          "/(x::Float32,y::Float32) at float.jl:130",
          "/(x::Float64,y::Float64) at float.jl:131",
          "/(x::Rational{T<:Integer},z::Complex{T<:Real}) at rational.jl:120",
          "/(a::Real,w::Complex{T<:Real}) at complex.jl:126",
          "/(z::Complex{Float64},w::Complex{Float64}) at complex.jl:162",
          "/(a::Complex{T<:Real},b::Complex{T<:Real}) at complex.jl:130",
          "/(z::Number,w::Complex{T<:Real}) at complex.jl:125",
          "/(z::Complex{T<:Real},x::Real) at complex.jl:127",
          "/(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:119",
          "/(a::Float16,b::Float16) at float16.jl:125",
          "/(x::BigFloat,c::Uint64) at mpfr.jl:270",
          "/(c::Uint64,x::BigFloat) at mpfr.jl:275",
          "/(x::BigFloat,c::Union(Uint16,Uint8,Uint32,Uint64)) at mpfr.jl:279",
          "/(c::Union(Uint16,Uint8,Uint32,Uint64),x::BigFloat) at mpfr.jl:280",
          "/(x::BigFloat,c::Int64) at mpfr.jl:284",
          "/(c::Int64,x::BigFloat) at mpfr.jl:289",
          "/(x::BigFloat,c::Union(Int8,Int64,Int16,Int32)) at mpfr.jl:293",
          "/(c::Union(Int8,Int64,Int16,Int32),x::BigFloat) at mpfr.jl:294",
          "/(x::BigFloat,c::Float64) at mpfr.jl:298",
          "/(c::Float64,x::BigFloat) at mpfr.jl:303",
          "/(x::BigFloat,c::Float32) at mpfr.jl:307",
          "/(c::Float32,x::BigFloat) at mpfr.jl:308",
          "/(x::BigFloat,c::BigInt) at mpfr.jl:312",
          "/(x::BigFloat,y::BigFloat) at mpfr.jl:321",
          "/{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Triangular{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/triangular.jl:50",
          "/(A::Triangular{T<:Number},B::Triangular{T<:Number}) at linalg/triangular.jl:111",
          "/(A::Triangular{T<:Number},B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/triangular.jl:112",
          "/(A::AbstractArray{T,2},B::Triangular{T<:Number}) at linalg/triangular.jl:113",
          "/(Da::Diagonal{T},Db::Diagonal{T}) at linalg/diagonal.jl:53",
          "/{T}(A::Bidiagonal{T},B::AbstractArray{T,1}) at linalg/bidiag.jl:118",
          "/(A::Union(AbstractArray{T,2},AbstractArray{T,1}),B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/generic.jl:237",
          "/(x::MathConst{sym},y::MathConst{sym}) at constants.jl:23",
          "/{T<:Number}(x::T<:Number,y::T<:Number) at promotion.jl:191",
          "/(x::Number,y::Number) at promotion.jl:161",
          "/(B::BitArray{N},x::Number) at bitarray.jl:888",
          "/(A::SymTridiagonal{T},B::Number) at linalg/tridiag.jl:48",
          "/(A::Tridiagonal{T},B::Number) at linalg/tridiag.jl:209",
          "/{T<:Number}(D::Diagonal{T},x::T<:Number) at linalg/diagonal.jl:43",
          "/(A::Bidiagonal{T},B::Number) at linalg/bidiag.jl:109",
          "/(A::AbstractArray{T,N},B::Number) at abstractarray.jl:354",
          "/(A::BitArray{N},B::BitArray{N}) at bitarray.jl:885",
          "/(x::Number,B::BitArray{N}) at bitarray.jl:889",
          "/(B::AbstractArray{T,2},A::LU{T,S<:AbstractArray{T,2}}) at linalg/lu.jl:314",
          "/(J1::UniformScaling{T<:Number},J2::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:78",
          "/(J::UniformScaling{T<:Number},A::AbstractArray{T,2}) at linalg/uniformscaling.jl:79",
          "/(A::AbstractArray{T,2},J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:80",
          "/(J::UniformScaling{T<:Number},x::Number) at linalg/uniformscaling.jl:82",
          "/(x::Number,A::Array{T,N}) at deprecated.jl:26",
          "/(p::Vec2,s::Real) at graphics.jl:63"
        ]
      },
      {
        "name": "//",
        "summary": "Function",
        "help": "Base.//(num, den)\n\n   Rational division\n",
        "methods": 
        [
          "//(n::Integer,d::Integer) at rational.jl:17",
          "//(x::Rational{T<:Integer},y::Integer) at rational.jl:18",
          "//(x::Integer,y::Rational{T<:Integer}) at rational.jl:19",
          "//(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:20",
          "//(x::Complex{T<:Real},y::Real) at rational.jl:21",
          "//(x::Real,y::Complex{T<:Real}) at rational.jl:22",
          "//(x::Complex{T<:Real},y::Complex{T<:Real}) at rational.jl:25"
        ]
      },
      {
        "name": ":",
        "summary": "Colon",
        "help": "Base.:(start[, step], stop)\n\n   Range operator. \"a:b\" constructs a range from \"a\" to \"b\" with\n   a step size of 1, and \"a:s:b\" is similar but uses a step size of\n   \"s\". These syntaxes call the function \"colon\". The colon is\n   also used in indexing to select whole dimensions.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "<",
        "summary": "Function",
        "help": "Base.<(x, y)\n\n   Less-than comparison operator. New numeric types should implement\n   this function for two arguments of the new type. Because of the\n   behavior of floating-point NaN values, \"<\" implements a partial\n   order. Types with a canonical partial order should implement \"<\",\n   and types with a canonical total order should implement \"isless\".\n",
        "methods": 
        [
          "<(x::Bool,y::Bool) at bool.jl:31",
          "<(x::Int8,y::Int8) at int.jl:244",
          "<(x::Int16,y::Int16) at int.jl:245",
          "<(x::Int32,y::Int32) at int.jl:246",
          "<(x::Int64,y::Int64) at int.jl:247",
          "<(x::Int128,y::Int128) at int.jl:248",
          "<(x::Uint8,y::Uint8) at int.jl:250",
          "<(x::Uint16,y::Uint16) at int.jl:251",
          "<(x::Uint32,y::Uint32) at int.jl:252",
          "<(x::Uint64,y::Uint64) at int.jl:253",
          "<(x::Uint128,y::Uint128) at int.jl:254",
          "<(x::Signed,y::Unsigned) at int.jl:270",
          "<(x::Unsigned,y::Signed) at int.jl:271",
          "<(x::Float32,y::Float32) at float.jl:148",
          "<(x::Float64,y::Float64) at float.jl:149",
          "<(x::Float64,y::Int64) at float.jl:183",
          "<(x::Float64,y::Uint64) at float.jl:184",
          "<(x::Int64,y::Float64) at float.jl:185",
          "<(x::Uint64,y::Float64) at float.jl:186",
          "<(x::Float32,y::Int64) at float.jl:188",
          "<(x::Float32,y::Uint64) at float.jl:189",
          "<(x::Int64,y::Float32) at float.jl:190",
          "<(x::Uint64,y::Float32) at float.jl:191",
          "<(x::Float32,y::Union(Uint32,Int32)) at float.jl:206",
          "<(x::Union(Uint32,Int32),y::Float32) at float.jl:207",
          "<(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:134",
          "<(x::Rational{T<:Integer},y::Integer) at rational.jl:136",
          "<(x::Rational{T<:Integer},y::Real) at rational.jl:137",
          "<(x::Integer,y::Rational{T<:Integer}) at rational.jl:138",
          "<(x::Real,y::Rational{T<:Integer}) at rational.jl:139",
          "<(x::Char,y::Char) at char.jl:43",
          "<(a::Float16,b::Float16) at float16.jl:128",
          "<(x::BigInt,y::BigInt) at gmp.jl:412",
          "<(x::BigFloat,y::BigFloat) at mpfr.jl:580",
          "<{T<:Real}(x::T<:Real,y::T<:Real) at promotion.jl:199",
          "<(x::Real,y::Real) at promotion.jl:169",
          "<(a::IntSet,b::IntSet) at intset.jl:290",
          "<(l::Set{T},r::Set{T}) at set.jl:83",
          "<(a::AbstractCmd,b::String) at deprecated.jl:26",
          "<(l::OrderedSet{T},r::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:83",
          "<(t1::CalendarTime,t2::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:184",
          "<(d1::FixedCalendarDuration,d2::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:368",
          "<(x,y) at operators.jl:32"
        ]
      },
      {
        "name": "<:",
        "summary": "Function",
        "help": "Base.<:(T1, T2)\n\n   Subtype operator, equivalent to \"issubtype(T1,T2)\".\n",
        "methods": 
        [

        ]
      },
      {
        "name": "<<",
        "summary": "Function",
        "help": "Base.<<(x, n)\n\n   Left shift operator.\n",
        "methods": 
        [
          "<<(x::Int8,y::Int32) at int.jl:158",
          "<<(x::Int16,y::Int32) at int.jl:159",
          "<<(x::Int32,y::Int32) at int.jl:160",
          "<<(x::Int64,y::Int32) at int.jl:161",
          "<<(x::Int128,y::Int32) at int.jl:162",
          "<<(x::Uint8,y::Int32) at int.jl:164",
          "<<(x::Uint16,y::Int32) at int.jl:165",
          "<<(x::Uint32,y::Int32) at int.jl:166",
          "<<(x::Uint64,y::Int32) at int.jl:167",
          "<<(x::Uint128,y::Int32) at int.jl:168",
          "<<(B::BitArray{1},i::Int32) at bitarray.jl:1202",
          "<<(x::Char,y::Int32) at char.jl:39",
          "<<(x::BigInt,c::Int32) at gmp.jl:295",
          "<<(x,y::Int32) at operators.jl:108",
          "<<(B::BitArray{1},i::Int64) at bitarray.jl:1196",
          "<<(B::BitArray{1},i::Integer) at bitarray.jl:1203",
          "<<(x,y::Integer) at operators.jl:111"
        ]
      },
      {
        "name": "<=",
        "summary": "Function",
        "help": "Base.<=(x, y)\n\n   Less-than-or-equals comparison operator.\n",
        "methods": 
        [
          "<=(x::Bool,y::Bool) at bool.jl:32",
          "<=(x::Int8,y::Int8) at int.jl:256",
          "<=(x::Int16,y::Int16) at int.jl:257",
          "<=(x::Int32,y::Int32) at int.jl:258",
          "<=(x::Int64,y::Int64) at int.jl:259",
          "<=(x::Int128,y::Int128) at int.jl:260",
          "<=(x::Uint8,y::Uint8) at int.jl:262",
          "<=(x::Uint16,y::Uint16) at int.jl:263",
          "<=(x::Uint32,y::Uint32) at int.jl:264",
          "<=(x::Uint64,y::Uint64) at int.jl:265",
          "<=(x::Uint128,y::Uint128) at int.jl:266",
          "<=(x::Signed,y::Unsigned) at int.jl:272",
          "<=(x::Unsigned,y::Signed) at int.jl:273",
          "<=(x::Float32,y::Float32) at float.jl:150",
          "<=(x::Float64,y::Float64) at float.jl:151",
          "<=(x::Float64,y::Int64) at float.jl:193",
          "<=(x::Float64,y::Uint64) at float.jl:194",
          "<=(x::Int64,y::Float64) at float.jl:195",
          "<=(x::Uint64,y::Float64) at float.jl:196",
          "<=(x::Float32,y::Int64) at float.jl:198",
          "<=(x::Float32,y::Uint64) at float.jl:199",
          "<=(x::Int64,y::Float32) at float.jl:200",
          "<=(x::Uint64,y::Float32) at float.jl:201",
          "<=(x::Float32,y::Union(Uint32,Int32)) at float.jl:209",
          "<=(x::Union(Uint32,Int32),y::Float32) at float.jl:210",
          "<=(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:141",
          "<=(x::Rational{T<:Integer},y::Integer) at rational.jl:143",
          "<=(x::Rational{T<:Integer},y::Real) at rational.jl:144",
          "<=(x::Integer,y::Rational{T<:Integer}) at rational.jl:145",
          "<=(x::Real,y::Rational{T<:Integer}) at rational.jl:146",
          "<=(x::Char,y::Char) at char.jl:44",
          "<=(a::Float16,b::Float16) at float16.jl:128",
          "<=(x::BigInt,y::BigInt) at gmp.jl:410",
          "<=(x::BigFloat,y::BigFloat) at mpfr.jl:578",
          "<=(x::Real,y::Real) at promotion.jl:170",
          "<=(a::IntSet,b::IntSet) at intset.jl:291",
          "<=(l::Set{T},r::Set{T}) at set.jl:84",
          "<=(l::OrderedSet{T},r::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:84",
          "<=(x,y) at operators.jl:34"
        ]
      },
      {
        "name": "==",
        "summary": "Function",
        "help": "Base.==(x, y)\n\n   Generic equality operator, giving a single \"Bool\" result. Falls\n   back to \"===\". Should be implemented for all types with a notion\n   of equality, based on the abstract value that an instance\n   represents. For example, all numeric types are compared by numeric\n   value, ignoring type. Strings are compared as sequences of\n   characters, ignoring encoding.\n\n   Follows IEEE semantics for floating-point numbers.\n\n   Collections should generally implement \"==\" by calling \"==\"\n   recursively on all contents.\n\n   New numeric types should implement this function for two arguments\n   of the new type, and handle comparison to other types via promotion\n   rules where possible.\n",
        "methods": 
        [
          "==(w::WeakRef,v::WeakRef) at base.jl:111",
          "==(w::WeakRef,v) at base.jl:112",
          "==(w,v::WeakRef) at base.jl:113",
          "==(x::Signed,y::Unsigned) at int.jl:268",
          "==(x::Unsigned,y::Signed) at int.jl:269",
          "==(x::Float32,y::Float32) at float.jl:144",
          "==(x::Float64,y::Float64) at float.jl:145",
          "==(x::Float64,y::Int64) at float.jl:173",
          "==(x::Float64,y::Uint64) at float.jl:174",
          "==(x::Int64,y::Float64) at float.jl:175",
          "==(x::Uint64,y::Float64) at float.jl:176",
          "==(x::Float32,y::Int64) at float.jl:178",
          "==(x::Float32,y::Uint64) at float.jl:179",
          "==(x::Int64,y::Float32) at float.jl:180",
          "==(x::Uint64,y::Float32) at float.jl:181",
          "==(x::Float32,y::Union(Uint32,Int32)) at float.jl:203",
          "==(x::Union(Uint32,Int32),y::Float32) at float.jl:204",
          "==(z::Complex{T<:Real},w::Complex{T<:Real}) at complex.jl:96",
          "==(z::Complex{T<:Real},x::Rational{T<:Integer}) at rational.jl:127",
          "==(z::Complex{T<:Real},x::Real) at complex.jl:97",
          "==(x::Rational{T<:Integer},z::Complex{T<:Real}) at rational.jl:128",
          "==(x::Real,z::Complex{T<:Real}) at complex.jl:98",
          "==(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:122",
          "==(x::Rational{T<:Integer},y::Integer) at rational.jl:123",
          "==(x::Integer,y::Rational{T<:Integer}) at rational.jl:124",
          "==(x::FloatingPoint,q::Rational{T<:Integer}) at rational.jl:130",
          "==(q::Rational{T<:Integer},x::FloatingPoint) at rational.jl:131",
          "==(a::Union(UTF8String,ASCIIString),b::Union(UTF8String,ASCIIString)) at string.jl:523",
          "==(x::Float16,y::Float16) at float16.jl:111",
          "==(x::BigInt,y::BigInt) at gmp.jl:409",
          "==(x::BigFloat,y::BigFloat) at mpfr.jl:577",
          "=={s}(::MathConst{s},::MathConst{s}) at constants.jl:16",
          "==(::MathConst{sym},::MathConst{sym}) at constants.jl:17",
          "=={T<:Number}(x::T<:Number,y::T<:Number) at promotion.jl:198",
          "==(x::Number,y::Number) at promotion.jl:168",
          "==(T::(Type{T<:Top}...,),S::(Type{T<:Top}...,)) at operators.jl:21",
          "==(t1::(Any...,),t2::(Any...,)) at tuple.jl:77",
          "=={T<:Range{T}}(r::T<:Range{T},s::T<:Range{T}) at range.jl:276",
          "==(r::Range{T},s::Range{T}) at range.jl:279",
          "==(x::Expr,y::Expr) at expr.jl:42",
          "==(x::QuoteNode,y::QuoteNode) at expr.jl:43",
          "==(T::Type{T<:Top},S::Type{T<:Top}) at operators.jl:22",
          "==(x::Ptr{T},y::Ptr{T}) at pointer.jl:65",
          "==(A::BitArray{N},B::BitArray{N}) at bitarray.jl:1060",
          "==(A::SymTridiagonal{T},B::SymTridiagonal{T}) at linalg/tridiag.jl:49",
          "==(A::Tridiagonal{T},B::Tridiagonal{T}) at linalg/tridiag.jl:211",
          "==(A::Tridiagonal{T},B::SymTridiagonal{T}) at linalg/tridiag.jl:212",
          "==(A::SymTridiagonal{T},B::Tridiagonal{T}) at linalg/tridiag.jl:213",
          "==(Da::Diagonal{T},Db::Diagonal{T}) at linalg/diagonal.jl:36",
          "==(A::Bidiagonal{T},B::Bidiagonal{T}) at linalg/bidiag.jl:110",
          "==(A::AbstractArray{T,N},B::AbstractArray{T,N}) at abstractarray.jl:861",
          "==(s1::IntSet,s2::IntSet) at intset.jl:262",
          "==(l::Associative{K,V},r::Associative{K,V}) at dict.jl:111",
          "==(l::Set{T},r::Set{T}) at set.jl:82",
          "==(a::String,b::String) at string.jl:485",
          "==(r::RemoteRef,s::RemoteRef) at multi.jl:452",
          "==(a::VersionNumber,b::VersionNumber) at version.jl:119",
          "==(J1::UniformScaling{T<:Number},J2::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:96",
          "==(a::VersionInterval,b::VersionInterval) at pkg/types.jl:17",
          "==(A::VersionSet,B::VersionSet) at pkg/types.jl:46",
          "==(a::Available,b::Available) at pkg/types.jl:67",
          "==(a::Fixed,b::Fixed) at pkg/types.jl:79",
          "==(a::Line,b::Line) at pkg/reqs.jl:49",
          "=={T}(a::HierarchicalValue{T},b::HierarchicalValue{T}) at pkg/resolve/versionweight.jl:64",
          "==(a::VWPreBuildItem,b::VWPreBuildItem) at pkg/resolve/versionweight.jl:92",
          "==(a::VWPreBuild,b::VWPreBuild) at pkg/resolve/versionweight.jl:129",
          "==(a::VersionWeight,b::VersionWeight) at pkg/resolve/versionweight.jl:183",
          "==(a::FieldValue,b::FieldValue) at pkg/resolve/fieldvalue.jl:58",
          "==(a::LineInfo,b::LineInfo) at profile.jl:70",
          "==(t1::CalendarTime,t2::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:184",
          "==(d1::FixedCalendarDuration,d2::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:368",
          "==(a::URI,b::URI) at /home/samuel/.julia/v0.3/URIParser/src/parser.jl:24",
          "==(x,y) at operators.jl:9"
        ]
      },
      {
        "name": ">",
        "summary": "Function",
        "help": "Base.>(x, y)\n\n   Greater-than comparison operator. Generally, new types should\n   implement \"<\" instead of this function, and rely on the fallback\n   definition \">(x,y) = y<x\".\n",
        "methods": 
        [
          ">(x::BigInt,y::BigInt) at gmp.jl:413",
          ">(x::BigFloat,y::BigFloat) at mpfr.jl:581",
          ">(a::Union(AsyncStream,File,RawFD,IOStream,FileRedirect),b::AbstractCmd) at deprecated.jl:26",
          ">(a::String,b::AbstractCmd) at deprecated.jl:26",
          ">(a::AbstractCmd,b::Union(AsyncStream,File,RawFD,IOStream,FileRedirect)) at deprecated.jl:26",
          ">(a::AbstractCmd,b::String) at deprecated.jl:26",
          ">(x,y) at operators.jl:33"
        ]
      },
      {
        "name": ">=",
        "summary": "Function",
        "help": "Base.>=(x, y)\n\n   Greater-than-or-equals comparison operator.\n",
        "methods": 
        [
          ">=(x::BigInt,y::BigInt) at gmp.jl:411",
          ">=(x::BigFloat,y::BigFloat) at mpfr.jl:579",
          ">=(x,y) at operators.jl:36"
        ]
      },
      {
        "name": ">>",
        "summary": "Function",
        "help": "Base.>>(x, n)\n\n   Right shift operator.\n\nBase.>>(command, filename)\n\n   Redirect standard output of a process, appending to the destination\n   file.\n",
        "methods": 
        [
          ">>(x::Int8,y::Int32) at int.jl:170",
          ">>(x::Int16,y::Int32) at int.jl:171",
          ">>(x::Int32,y::Int32) at int.jl:172",
          ">>(x::Int64,y::Int32) at int.jl:173",
          ">>(x::Int128,y::Int32) at int.jl:174",
          ">>(x::Uint8,y::Int32) at int.jl:176",
          ">>(x::Uint16,y::Int32) at int.jl:177",
          ">>(x::Uint32,y::Int32) at int.jl:178",
          ">>(x::Uint64,y::Int32) at int.jl:179",
          ">>(x::Uint128,y::Int32) at int.jl:180",
          ">>(B::BitArray{1},i::Int32) at bitarray.jl:1215",
          ">>(x::Char,y::Int32) at char.jl:40",
          ">>(x::BigInt,c::Int32) at gmp.jl:303",
          ">>(x,y::Int32) at operators.jl:109",
          ">>(B::BitArray{1},i::Integer) at bitarray.jl:1216",
          ">>(x,y::Integer) at operators.jl:112",
          ">>(src::AbstractCmd,dest::String) at process.jl:160"
        ]
      },
      {
        "name": ">>>",
        "summary": "Function",
        "help": "Base.>>>(x, n)\n\n   Unsigned right shift operator.\n",
        "methods": 
        [
          ">>>(x::Int8,y::Int32) at int.jl:182",
          ">>>(x::Int16,y::Int32) at int.jl:183",
          ">>>(x::Int32,y::Int32) at int.jl:184",
          ">>>(x::Int64,y::Int32) at int.jl:185",
          ">>>(x::Int128,y::Int32) at int.jl:186",
          ">>>(x::Uint8,y::Int32) at int.jl:188",
          ">>>(x::Uint16,y::Int32) at int.jl:189",
          ">>>(x::Uint32,y::Int32) at int.jl:190",
          ">>>(x::Uint64,y::Int32) at int.jl:191",
          ">>>(x::Uint128,y::Int32) at int.jl:192",
          ">>>(B::BitArray{1},i::Int32) at bitarray.jl:1212",
          ">>>(x::Char,y::Int32) at char.jl:41",
          ">>>(x::BigInt,c::Int32) at gmp.jl:310",
          ">>>(x,y::Int32) at operators.jl:110",
          ">>>(B::BitArray{1},i::Int64) at bitarray.jl:1206",
          ">>>(B::BitArray{1},i::Integer) at bitarray.jl:1213",
          ">>>(x,y::Integer) at operators.jl:113"
        ]
      },
      {
        "name": "@MIME",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@MIME_str",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@__FILE__",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@allocated",
        "summary": "Function",
        "help": "Base.@allocated()\n\n   A macro to evaluate an expression, discarding the resulting value,\n   instead returning the total number of bytes allocated during\n   evaluation of the expression.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@assert",
        "summary": "Function",
        "help": "Base.@assert()\n\n   Raise an error if \"cond\" is false. Preferred syntax for writings\n   assertions.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@async",
        "summary": "Function",
        "help": "Base.@async()\n\n   Schedule an expression to run on the local machine, also adding it\n   to the set of items that the nearest enclosing \"@sync\" waits for.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@b_str",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@bigint_str",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@boundscheck",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@cmd",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@code_llvm",
        "summary": "Function",
        "help": "Base.@code_llvm()\n\n   Evaluates the arguments to the function call, determines their\n   types, and calls the \"code_llvm\" function on the resulting\n   expression\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@code_lowered",
        "summary": "Function",
        "help": "Base.@code_lowered()\n\n   Evaluates the arguments to the function call, determines their\n   types, and calls the \"code_lowered\" function on the resulting\n   expression\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@code_native",
        "summary": "Function",
        "help": "Base.@code_native()\n\n   Evaluates the arguments to the function call, determines their\n   types, and calls the \"code_native\" function on the resulting\n   expression\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@code_typed",
        "summary": "Function",
        "help": "Base.@code_typed()\n\n   Evaluates the arguments to the function call, determines their\n   types, and calls the \"code_typed\" function on the resulting\n   expression\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@deprecate",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@edit",
        "summary": "Function",
        "help": "Base.@edit()\n\n   Evaluates the arguments to the function call, determines their\n   types, and calls the \"edit\" function on the resulting expression\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@elapsed",
        "summary": "Function",
        "help": "Base.@elapsed()\n\n   A macro to evaluate an expression, discarding the resulting value,\n   instead returning the number of seconds it took to execute as a\n   floating-point number.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@eval",
        "summary": "Function",
        "help": "Base.@eval()\n\n   Evaluate an expression and return the value.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@everywhere",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@fetch",
        "summary": "Function",
        "help": "Base.@fetch()\n\n   Equivalent to \"fetch(@spawn expr)\".\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@fetchfrom",
        "summary": "Function",
        "help": "Base.@fetchfrom()\n\n   Equivalent to \"fetch(@spawnat p expr)\".\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@gensym",
        "summary": "Function",
        "help": "Base.@gensym()\n\n   Generates a gensym symbol for a variable. For example, *@gensym x\n   y* is transformed into *x = gensym(\"x\"); y = gensym(\"y\")*.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@inbounds",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@int128_str",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@ip_str",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@less",
        "summary": "Function",
        "help": "Base.@less()\n\n   Evaluates the arguments to the function call, determines their\n   types, and calls the \"less\" function on the resulting expression\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@linux",
        "summary": "Function",
        "help": "Base.@linux()\n\n   Given \"@linux? a : b\", do \"a\" on Linux and \"b\" elsewhere. See\n   documentation for Handling Platform Variations in the Calling C and\n   Fortran Code section of the manual.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@linux_only",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@mstr",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@osx",
        "summary": "Function",
        "help": "Base.@osx()\n\n   Given \"@osx? a : b\", do \"a\" on OS X and \"b\" elsewhere. See\n   documentation for Handling Platform Variations in the Calling C and\n   Fortran Code section of the manual.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@osx_only",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@parallel",
        "summary": "Function",
        "help": "Base.@parallel()\n\n   A parallel for loop of the form\n\n      @parallel [reducer] for var = range\n          body\n      end\n\n   The specified range is partitioned and locally executed across all\n   workers. In case an optional reducer function is specified,\n   @parallel performs local reductions on each worker with a final\n   reduction on the calling process.\n\n   Note that without a reducer function, @parallel executes\n   asynchronously, i.e. it spawns independent tasks on all available\n   workers and returns immediately without waiting for completion. To\n   wait for completion, prefix the call with \"@sync\", like\n\n      @sync @parallel for var = range\n          body\n      end\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@printf",
        "summary": "Function",
        "help": "Base.@printf([io::IOStream], \"%Fmt\", args...)\n\n   Print arg(s) using C \"printf()\" style format specification\n   string. Optionally, an IOStream may be passed as the first argument\n   to redirect output.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@profile",
        "summary": "Function",
        "help": "Base.@profile()\n\n   \"@profile <expression>\" runs your expression while taking\n   periodic backtraces.  These are appended to an internal buffer of\n   backtraces.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@r_mstr",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@r_str",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@schedule",
        "summary": "Function",
        "help": "Base.@schedule()\n\n   Wrap an expression in a Task and add it to the scheduler's queue.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@show",
        "summary": "Function",
        "help": "Base.@show()\n\n   Show an expression and result, returning the result\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@simd",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@spawn",
        "summary": "Function",
        "help": "Base.@spawn()\n\n   Execute an expression on an automatically-chosen process, returning\n   a \"RemoteRef\" to the result.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@spawnat",
        "summary": "Function",
        "help": "Base.@spawnat()\n\n   Accepts two arguments, \"p\" and an expression, and runs the\n   expression asynchronously on process \"p\", returning a\n   \"RemoteRef\" to the result.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@sprintf",
        "summary": "Function",
        "help": "Base.@sprintf(\"%Fmt\", args...)\n\n   Return \"@printf\" formatted output as string.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@sync",
        "summary": "Function",
        "help": "Base.@sync()\n\n   Wait until all dynamically-enclosed uses of \"@async\", \"@spawn\",\n   \"@spawnat\" and \"@parallel\" are complete.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@task",
        "summary": "Function",
        "help": "Base.@task()\n\n   Wrap an expression in a Task executing it, and return the Task.\n   This only creates a task, and does not run it.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@thunk",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@time",
        "summary": "Function",
        "help": "Base.@time()\n\n   A macro to execute an expression, printing the time it took to\n   execute and the total number of bytes its execution caused to be\n   allocated, before returning the value of the expression.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@timed",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@uint128_str",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@unexpected",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@unix",
        "summary": "Function",
        "help": "Base.@unix()\n\n   Given \"@unix? a : b\", do \"a\" on Unix systems (including Linux\n   and OS X) and \"b\" elsewhere. See documentation for Handling\n   Platform Variations in the Calling C and Fortran Code section of\n   the manual.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@unix_only",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@v_str",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@vectorize_1arg",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@vectorize_2arg",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@which",
        "summary": "Function",
        "help": "Base.@which()\n\n   Evaluates the arguments to the function call, determines their\n   types, and calls the \"which\" function on the resulting expression\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@windows",
        "summary": "Function",
        "help": "Base.@windows()\n\n   Given \"@windows? a : b\", do \"a\" on Windows and \"b\" elsewhere.\n   See documentation for Handling Platform Variations in the Calling C\n   and Fortran Code section of the manual.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@windows_only",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "ARGS",
        "summary": "0-element Array{UTF8String,1}",
        "help": "Base.ARGS\n\n   An array of the command line arguments passed to Julia, as strings.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "A_ldiv_B!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "A_ldiv_B!(A::Tridiagonal{T},B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/tridiag.jl:251",
          "A_ldiv_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(C::Cholesky{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:85",
          "A_ldiv_B!(C::Cholesky{T},B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2},SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/factorization.jl:86",
          "A_ldiv_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(C::CholeskyPivoted{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:89",
          "A_ldiv_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(C::CholeskyPivoted{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:93",
          "A_ldiv_B!(C::CholeskyPivoted{T},B::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/factorization.jl:104",
          "A_ldiv_B!(C::CholeskyPivoted{T},B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/factorization.jl:105",
          "A_ldiv_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(QRPivoted{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},QRCompactWY{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}),B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),rcond::Real) at linalg/factorization.jl:372",
          "A_ldiv_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(QRPivoted{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},QRCompactWY{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}),B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:397",
          "A_ldiv_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(QRPivoted{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},QRCompactWY{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}),B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:398",
          "A_ldiv_B!{T}(A::QR{T},B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/factorization.jl:400",
          "A_ldiv_B!(A::QR{T},B::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/factorization.jl:450",
          "A_ldiv_B!(A::QRPivoted{T},B::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/factorization.jl:451",
          "A_ldiv_B!(A::QRPivoted{T},B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/factorization.jl:452",
          "A_ldiv_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})}(A::LU{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})},B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/lu.jl:110",
          "A_ldiv_B!{T,S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})}(A::LU{T,S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})},b::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/lu.jl:111",
          "A_ldiv_B!{T,S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})}(A::LU{T,S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})},B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/lu.jl:112",
          "A_ldiv_B!{T}(A::LU{T,Tridiagonal{T}},B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/lu.jl:221",
          "A_ldiv_B!{T<:Union(Float64,Float32)}(B::BunchKaufman{T<:Union(Float64,Float32)},R::Union(SubArray{T<:Union(Float64,Float32),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),1},SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2})) at linalg/bunchkaufman.jl:42",
          "A_ldiv_B!{T<:Union(Complex{Float64},Complex{Float32})}(B::BunchKaufman{T<:Union(Complex{Float64},Complex{Float32})},R::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),1},DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/bunchkaufman.jl:44",
          "A_ldiv_B!(W::Woodbury{T},B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/woodbury.jl:80",
          "A_ldiv_B!{T}(D::Diagonal{T},v::AbstractArray{T,1}) at linalg/diagonal.jl:55",
          "A_ldiv_B!{T}(D::Diagonal{T},V::AbstractArray{T,2}) at linalg/diagonal.jl:64",
          "A_ldiv_B!(A::Union(Bidiagonal{T},Triangular{T<:Number}),b::AbstractArray{T,1}) at linalg/bidiag.jl:133",
          "A_ldiv_B!(A::Union(Bidiagonal{T},Triangular{T<:Number}),B::AbstractArray{T,2}) at linalg/bidiag.jl:138",
          "A_ldiv_B!{T}(S::LDLt{T,SymTridiagonal{T}},B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/ldlt.jl:32",
          "A_ldiv_B!(A::SparseMatrixCSC{Tv,Ti<:Integer},b::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/sparse.jl:200",
          "A_ldiv_B!{T<:Union(Float64,Complex{Float64})}(lu::UmfpackLU{T<:Union(Float64,Complex{Float64}),Ti<:Union(Int64,Int32)},b::Union(Array{T<:Union(Float64,Complex{Float64}),1},Array{T<:Union(Float64,Complex{Float64}),2})) at linalg/umfpack.jl:302",
          "A_ldiv_B!{Tlu<:Real,Tb<:Complex{T<:Real}}(lu::UmfpackLU{Tlu<:Real,Ti<:Union(Int64,Int32)},b::Array{Tb<:Complex{T<:Real},1}) at linalg/umfpack.jl:304",
          "A_ldiv_B!{Tlu<:Union(Float64,Complex{Float64}),Tb<:Number}(lu::UmfpackLU{Tlu<:Union(Float64,Complex{Float64}),Ti<:Union(Int64,Int32)},b::Union(SubArray{Tb<:Number,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Tb<:Number,1},DenseArray{Tb<:Number,2},SubArray{Tb<:Number,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/umfpack.jl:308",
          "A_ldiv_B!{Tlu<:Union(Float64,Complex{Float64}),Tb<:Number}(lu::UmfpackLU{Tlu<:Union(Float64,Complex{Float64}),Ti<:Union(Int64,Int32)},b::Union(AbstractArray{Tb<:Number,1},AbstractArray{Tb<:Number,2})) at linalg/umfpack.jl:309"
        ]
      },
      {
        "name": "A_ldiv_Bc",
        "summary": "Function",
        "help": "Base.A_ldiv_Bc(a, b)\n\n   Matrix operator A \\ B^H\n",
        "methods": 
        [
          "A_ldiv_Bc(a,b) at operators.jl:150"
        ]
      },
      {
        "name": "A_ldiv_Bt",
        "summary": "Function",
        "help": "Base.A_ldiv_Bt(a, b)\n\n   Matrix operator A \\ B^T\n",
        "methods": 
        [
          "A_ldiv_Bt(a,b) at operators.jl:153"
        ]
      },
      {
        "name": "A_mul_B",
        "summary": "Function",
        "help": "Base.A_mul_B(...)\n\n   Matrix operator A B\n",
        "methods": 
        [
          "A_mul_B(A,B,C) at deprecated.jl:26"
        ]
      },
      {
        "name": "A_mul_B!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "A_mul_B!(y::Union(SubArray{Complex{Float32},1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float32},1}),A::Union(SubArray{Complex{Float32},2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float32},2}),x::Union(SubArray{Float32,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Float32,1})) at linalg/matmul.jl:80",
          "A_mul_B!(y::Union(DenseArray{Complex{Float64},1},SubArray{Complex{Float64},1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),A::Union(SubArray{Complex{Float64},2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float64},2}),x::Union(SubArray{Float64,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Float64,1})) at linalg/matmul.jl:80",
          "A_mul_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(y::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),x::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:76",
          "A_mul_B!(y::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1}),A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),x::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/matmul.jl:87",
          "A_mul_B!(C::Union(SubArray{Complex{Float32},2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float32},2}),A::Union(SubArray{Complex{Float32},2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float32},2}),B::Union(SubArray{Float32,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Float32,2})) at linalg/matmul.jl:123",
          "A_mul_B!(C::Union(SubArray{Complex{Float64},2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float64},2}),A::Union(SubArray{Complex{Float64},2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float64},2}),B::Union(SubArray{Float64,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Float64,2})) at linalg/matmul.jl:123",
          "A_mul_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(C::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:119",
          "A_mul_B!(C::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/matmul.jl:130",
          "A_mul_B!(C::Union(AbstractArray{T,2},AbstractArray{T,1}),A::Tridiagonal{T},B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/tridiag.jl:233",
          "A_mul_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::QRCompactWYQ{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:242",
          "A_mul_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::QRPackedQ{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:243",
          "A_mul_B!{T}(A::QRPackedQ{T},B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/factorization.jl:245",
          "A_mul_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::QRCompactWYQ{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/factorization.jl:310",
          "A_mul_B!{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),Q::QRPackedQ{T}) at linalg/factorization.jl:313",
          "A_mul_B!(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2},SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1}),B::QRPackedQ{T}) at linalg/factorization.jl:311",
          "A_mul_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Triangular{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},B::Array{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2}) at linalg/triangular.jl:30",
          "A_mul_B!(A::Diagonal{T},B::AbstractArray{T,2}) at linalg/diagonal.jl:49",
          "A_mul_B!(G1::Givens{T},G2::Givens{T}) at linalg/givens.jl:207",
          "A_mul_B!(G::Givens{T},A::AbstractArray{T,2}) at linalg/givens.jl:209",
          "A_mul_B!(G::Givens{T},R::Rotation{T}) at linalg/givens.jl:227",
          "A_mul_B!(R::Rotation{T},A::AbstractArray{T,2}) at linalg/givens.jl:231",
          "A_mul_B!(α::Number,A::SparseMatrixCSC{Tv,Ti<:Integer},x::AbstractArray{T,1},β::Number,y::AbstractArray{T,1}) at linalg/sparse.jl:14",
          "A_mul_B!(y::AbstractArray{T,1},A::SparseMatrixCSC{Tv,Ti<:Integer},x::AbstractArray{T,1}) at linalg/sparse.jl:29"
        ]
      },
      {
        "name": "A_mul_Bc",
        "summary": "Function",
        "help": "Base.A_mul_Bc(...)\n\n   Matrix operator A B^H\n",
        "methods": 
        [
          "A_mul_Bc{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S<:Union(Float64,Float32)}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(SubArray{S<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S<:Union(Float64,Float32),2})) at linalg/matmul.jl:172",
          "A_mul_Bc{T,S}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{S,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,2})) at linalg/matmul.jl:175",
          "A_mul_Bc{TB}(A::Triangular{T<:Number},B::Union(QRPackedQ{TB},QRCompactWYQ{TB})) at linalg/triangular.jl:106",
          "A_mul_Bc{TA,TB,N}(A::AbstractArray{TA,N},B::Union(QRPackedQ{TB},QRCompactWYQ{TB})) at linalg/factorization.jl:366",
          "A_mul_Bc(A::Triangular{T<:Number},B::Triangular{T<:Number}) at linalg/triangular.jl:111",
          "A_mul_Bc(A::Triangular{T<:Number},B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/triangular.jl:112",
          "A_mul_Bc(A::AbstractArray{T,2},B::Triangular{T<:Number}) at linalg/triangular.jl:113",
          "A_mul_Bc{T}(A::Bidiagonal{T},B::AbstractArray{T,1}) at linalg/bidiag.jl:118",
          "A_mul_Bc(A::AbstractArray{T,2},R::Rotation{T}) at linalg/givens.jl:202",
          "A_mul_Bc{Tv<:Union(Float64,Float32)}(A::CholmodSparse{Tv<:Union(Float64,Float32),Int32},B::CholmodSparse{Tv<:Union(Float64,Float32),Int32}) at linalg/cholmod.jl:485",
          "A_mul_Bc{Tv<:Union(Float64,Float32)}(A::CholmodSparse{Tv<:Union(Float64,Float32),Int64},B::CholmodSparse{Tv<:Union(Float64,Float32),Int64}) at linalg/cholmod.jl:485",
          "A_mul_Bc(a,b) at operators.jl:135",
          "A_mul_Bc(A,B,C) at deprecated.jl:26"
        ]
      },
      {
        "name": "A_mul_Bc!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "A_mul_Bc!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S<:Union(Float64,Float32)}(C::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(SubArray{S<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S<:Union(Float64,Float32),2})) at linalg/matmul.jl:173",
          "A_mul_Bc!{T<:Union(Complex{Float64},Complex{Float32})}(C::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),A::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:178",
          "A_mul_Bc!(C::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/matmul.jl:179",
          "A_mul_Bc!{T<:Union(Float64,Float32)}(A::Union(SubArray{T<:Union(Float64,Float32),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),1},SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2}),B::QRCompactWYQ{T<:Union(Float64,Float32)}) at linalg/factorization.jl:339",
          "A_mul_Bc!{T<:Union(Complex{Float64},Complex{Float32})}(A::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),1},DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::QRCompactWYQ{T<:Union(Complex{Float64},Complex{Float32})}) at linalg/factorization.jl:340",
          "A_mul_Bc!{T<:Union(Float64,Float32)}(A::Union(SubArray{T<:Union(Float64,Float32),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),1},SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2}),B::QRPackedQ{T<:Union(Float64,Float32)}) at linalg/factorization.jl:341",
          "A_mul_Bc!{T<:Union(Complex{Float64},Complex{Float32})}(A::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),1},DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::QRPackedQ{T<:Union(Complex{Float64},Complex{Float32})}) at linalg/factorization.jl:342",
          "A_mul_Bc!{T}(A::AbstractArray{T,2},Q::QRPackedQ{T}) at linalg/factorization.jl:344",
          "A_mul_Bc!{T<:Union(Complex{Float64},Complex{Float32})}(A::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Triangular{T<:Union(Complex{Float64},Complex{Float32})}) at linalg/triangular.jl:33",
          "A_mul_Bc!{T<:Union(Float64,Float32)}(A::Union(SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2}),B::Triangular{T<:Union(Float64,Float32)}) at linalg/triangular.jl:34",
          "A_mul_Bc!(A::AbstractArray{T,2},G::Givens{T}) at linalg/givens.jl:218",
          "A_mul_Bc!(A::AbstractArray{T,2},R::Rotation{T}) at linalg/givens.jl:237"
        ]
      },
      {
        "name": "A_mul_Bt",
        "summary": "Function",
        "help": "Base.A_mul_Bt(...)\n\n   Matrix operator A B^T\n",
        "methods": 
        [
          "A_mul_Bt{T,S}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{S,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,2})) at linalg/matmul.jl:140",
          "A_mul_Bt{Tv<:Union(Float64,Float32),Ti<:Union(Int64,Int32)}(A::CholmodSparse{Tv<:Union(Float64,Float32),Ti<:Union(Int64,Int32)},B::CholmodSparse{Tv<:Union(Float64,Float32),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:849",
          "A_mul_Bt(a,b) at operators.jl:138",
          "A_mul_Bt(A,B,C) at deprecated.jl:26"
        ]
      },
      {
        "name": "A_mul_Bt!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "A_mul_Bt!(C::Union(SubArray{Complex{Float32},2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float32},2}),A::Union(SubArray{Complex{Float32},2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float32},2}),B::Union(SubArray{Float32,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Float32,2})) at linalg/matmul.jl:147",
          "A_mul_Bt!(C::Union(SubArray{Complex{Float64},2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float64},2}),A::Union(SubArray{Complex{Float64},2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float64},2}),B::Union(SubArray{Float64,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Float64,2})) at linalg/matmul.jl:147",
          "A_mul_Bt!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(C::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:143",
          "A_mul_Bt!(C::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2},SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1}),A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/matmul.jl:154"
        ]
      },
      {
        "name": "A_rdiv_Bc",
        "summary": "Function",
        "help": "Base.A_rdiv_Bc(...)\n\n   Matrix operator A / B^H\n",
        "methods": 
        [
          "A_rdiv_Bc{T<:Union(Float64,Float32)}(A::Union(SubArray{T<:Union(Float64,Float32),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),1},SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2}),B::Triangular{T<:Union(Float64,Float32)}) at linalg/triangular.jl:51",
          "A_rdiv_Bc{T<:Union(Complex{Float64},Complex{Float32})}(A::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),1},DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Triangular{T<:Union(Complex{Float64},Complex{Float32})}) at linalg/triangular.jl:52",
          "A_rdiv_Bc(A::Triangular{T<:Number},B::Triangular{T<:Number}) at linalg/triangular.jl:111",
          "A_rdiv_Bc(A::Triangular{T<:Number},B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/triangular.jl:112",
          "A_rdiv_Bc(A::AbstractArray{T,2},B::Triangular{T<:Number}) at linalg/triangular.jl:113",
          "A_rdiv_Bc{T}(A::Bidiagonal{T},B::AbstractArray{T,1}) at linalg/bidiag.jl:118",
          "A_rdiv_Bc(a,b) at operators.jl:143"
        ]
      },
      {
        "name": "A_rdiv_Bt",
        "summary": "Function",
        "help": "Base.A_rdiv_Bt(a, b)\n\n   Matrix operator A / B^T\n",
        "methods": 
        [
          "A_rdiv_Bt(a,b) at operators.jl:146"
        ]
      },
      {
        "name": "AbstractMatrix",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "AbstractRNG",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "AbstractSparseArray",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "AbstractSparseMatrix",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "AbstractSparseVector",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "AbstractVecOrMat",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "AbstractVector",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Ac_ldiv_B",
        "summary": "Function",
        "help": "Base.Ac_ldiv_B(...)\n\n   Matrix operator A^H \\ B\n",
        "methods": 
        [
          "Ac_ldiv_B{T<:Union(Complex{Float64},Complex{Float32}),S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})}(A::LU{T<:Union(Complex{Float64},Complex{Float32}),S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})},B::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),1},DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/lu.jl:114",
          "Ac_ldiv_B{TF<:Number,TB<:Number,N}(F::Factorization{TF<:Number},B::AbstractArray{TB<:Number,N}) at linalg/factorization.jl:800",
          "Ac_ldiv_B{T<:Union(Float64,Float32)}(A::Triangular{T<:Union(Float64,Float32)},B::Union(SubArray{T<:Union(Float64,Float32),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),1},SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2})) at linalg/triangular.jl:47",
          "Ac_ldiv_B{T<:Union(Complex{Float64},Complex{Float32})}(A::Triangular{T<:Union(Complex{Float64},Complex{Float32})},B::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),1},DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/triangular.jl:48",
          "Ac_ldiv_B{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},B::CholmodDense{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/cholmod.jl:852",
          "Ac_ldiv_B{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},B::Union(Array{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},Array{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1})) at linalg/cholmod.jl:853",
          "Ac_ldiv_B{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},B::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:855",
          "Ac_ldiv_B{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},B::SparseMatrixCSC{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:858",
          "Ac_ldiv_B(a,b) at operators.jl:149"
        ]
      },
      {
        "name": "Ac_ldiv_Bc",
        "summary": "Function",
        "help": "Base.Ac_ldiv_Bc(...)\n\n   Matrix operator A^H \\ B^H\n",
        "methods": 
        [
          "Ac_ldiv_Bc{T<:Union(Complex{Float64},Complex{Float32}),S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})}(A::LU{T<:Union(Complex{Float64},Complex{Float32}),S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})},B::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),1},DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/lu.jl:116",
          "Ac_ldiv_Bc(a,b) at operators.jl:151"
        ]
      },
      {
        "name": "Ac_mul_B",
        "summary": "Function",
        "help": "Base.Ac_mul_B(...)\n\n   Matrix operator A^H B\n",
        "methods": 
        [
          "Ac_mul_B(x::Array{T,1},y::Array{T,1}) at linalg/matmul.jl:61",
          "Ac_mul_B{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),x::Union(DenseArray{S,1},SubArray{S,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:101",
          "Ac_mul_B{T,S}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),x::Union(DenseArray{S,1},SubArray{S,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:105",
          "Ac_mul_B{T<:Union(Float64,Float32)}(A::Union(SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2}),B::Union(SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2})) at linalg/matmul.jl:163",
          "Ac_mul_B{T,S}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{S,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,2})) at linalg/matmul.jl:166",
          "Ac_mul_B{TQ<:Number,TB<:Number,N}(Q::Union(QRCompactWYQ{TQ<:Number},QRPackedQ{TQ<:Number}),B::Union(DenseArray{TB<:Number,N},SubArray{TB<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:306",
          "Ac_mul_B{T<:Union(Complex{Float64},Complex{Float32})}(A::Triangular{T<:Union(Complex{Float64},Complex{Float32})},b::Array{T<:Union(Complex{Float64},Complex{Float32}),1}) at linalg/triangular.jl:24",
          "Ac_mul_B(A::Triangular{T<:Number},B::Triangular{T<:Number}) at linalg/triangular.jl:111",
          "Ac_mul_B(A::Triangular{T<:Number},B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/triangular.jl:112",
          "Ac_mul_B(A::AbstractArray{T,2},B::Triangular{T<:Number}) at linalg/triangular.jl:113",
          "Ac_mul_B{T}(A::Bidiagonal{T},B::AbstractArray{T,1}) at linalg/bidiag.jl:118",
          "Ac_mul_B{TA,S,Tx}(A::SparseMatrixCSC{TA,S},x::AbstractArray{Tx,1}) at linalg/sparse.jl:87",
          "Ac_mul_B{Tv<:Union(Float64,Float32)}(A::CholmodSparse{Tv<:Union(Float64,Float32),Int32},B::CholmodSparse{Tv<:Union(Float64,Float32),Int32}) at linalg/cholmod.jl:538",
          "Ac_mul_B{Tv<:Union(Float64,Float32)}(A::CholmodSparse{Tv<:Union(Float64,Float32),Int64},B::CholmodSparse{Tv<:Union(Float64,Float32),Int64}) at linalg/cholmod.jl:538",
          "Ac_mul_B{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},B::CholmodDense{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/cholmod.jl:862",
          "Ac_mul_B{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},B::Union(Array{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},Array{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2})) at linalg/cholmod.jl:865",
          "Ac_mul_B(a,b) at operators.jl:134",
          "Ac_mul_B(A,B,C) at deprecated.jl:26"
        ]
      },
      {
        "name": "Ac_mul_B!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "Ac_mul_B!{T<:Union(Float64,Float32)}(y::Union(SubArray{T<:Union(Float64,Float32),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),1}),A::Union(SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2}),x::Union(SubArray{T<:Union(Float64,Float32),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),1})) at linalg/matmul.jl:109",
          "Ac_mul_B!{T<:Union(Complex{Float64},Complex{Float32})}(y::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),1},SubArray{T<:Union(Complex{Float64},Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),A::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),x::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),1},SubArray{T<:Union(Complex{Float64},Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:110",
          "Ac_mul_B!(y::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1}),A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),x::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/matmul.jl:111",
          "Ac_mul_B!{T<:Union(Float64,Float32)}(C::Union(SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2}),A::Union(SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2}),B::Union(SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2})) at linalg/matmul.jl:164",
          "Ac_mul_B!{T<:Union(Complex{Float64},Complex{Float32})}(C::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),A::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:169",
          "Ac_mul_B!(C::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/matmul.jl:170",
          "Ac_mul_B!{T<:Union(Float64,Float32)}(A::QRCompactWYQ{T<:Union(Float64,Float32)},B::Union(SubArray{T<:Union(Float64,Float32),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),1},SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2})) at linalg/factorization.jl:279",
          "Ac_mul_B!{T<:Union(Complex{Float64},Complex{Float32})}(A::QRCompactWYQ{T<:Union(Complex{Float64},Complex{Float32})},B::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),1},DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:280",
          "Ac_mul_B!{T<:Union(Float64,Float32)}(A::QRPackedQ{T<:Union(Float64,Float32)},B::Union(SubArray{T<:Union(Float64,Float32),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),1},SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2})) at linalg/factorization.jl:281",
          "Ac_mul_B!{T<:Union(Complex{Float64},Complex{Float32})}(A::QRPackedQ{T<:Union(Complex{Float64},Complex{Float32})},B::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),1},DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:282",
          "Ac_mul_B!{T}(A::QRPackedQ{T},B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/factorization.jl:284",
          "Ac_mul_B!{T<:Union(Complex{Float64},Complex{Float32})}(A::Triangular{T<:Union(Complex{Float64},Complex{Float32})},B::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/triangular.jl:31",
          "Ac_mul_B!{T<:Union(Float64,Float32)}(A::Triangular{T<:Union(Float64,Float32)},B::Union(SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2})) at linalg/triangular.jl:32",
          "Ac_mul_B!(A::Diagonal{T},B::AbstractArray{T,2}) at linalg/diagonal.jl:51",
          "Ac_mul_B!(α::Number,A::SparseMatrixCSC{Tv,Ti<:Integer},x::AbstractArray{T,1},β::Number,y::AbstractArray{T,1}) at linalg/sparse.jl:37",
          "Ac_mul_B!(y::AbstractArray{T,1},A::SparseMatrixCSC{Tv,Ti<:Integer},x::AbstractArray{T,1}) at linalg/sparse.jl:60"
        ]
      },
      {
        "name": "Ac_mul_Bc",
        "summary": "Function",
        "help": "Base.Ac_mul_Bc(...)\n\n   Matrix operator A^H B^H\n",
        "methods": 
        [
          "Ac_mul_Bc{T,S}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{S,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,2})) at linalg/matmul.jl:181",
          "Ac_mul_Bc(a,b) at operators.jl:136",
          "Ac_mul_Bc(A,B,C) at deprecated.jl:26"
        ]
      },
      {
        "name": "Ac_mul_Bc!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "Ac_mul_Bc!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(C::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:182",
          "Ac_mul_Bc!(C::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/matmul.jl:183"
        ]
      },
      {
        "name": "Ac_mul_Bt",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "Ac_mul_Bt(A,B,C) at deprecated.jl:26"
        ]
      },
      {
        "name": "Ac_rdiv_B",
        "summary": "Function",
        "help": "Base.Ac_rdiv_B(a, b)\n\n   Matrix operator A^H / B\n",
        "methods": 
        [
          "Ac_rdiv_B(a,b) at operators.jl:142"
        ]
      },
      {
        "name": "Ac_rdiv_Bc",
        "summary": "Function",
        "help": "Base.Ac_rdiv_Bc(a, b)\n\n   Matrix operator A^H / B^H\n",
        "methods": 
        [
          "Ac_rdiv_Bc(a,b) at operators.jl:144"
        ]
      },
      {
        "name": "ArgumentError",
        "summary": "DataType",
        "help": "Base.ArgumentError\n\n   The parameters given to a function call are not valid.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Array",
        "summary": "DataType",
        "help": "Base.Array(type, dims)\n\n   Construct an uninitialized dense array. \"dims\" may be a tuple or\n   a series of integer arguments.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Associative",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "At_ldiv_B",
        "summary": "Function",
        "help": "Base.At_ldiv_B(...)\n\n   Matrix operator A^T \\ B\n",
        "methods": 
        [
          "At_ldiv_B{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})}(A::LU{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})},B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/lu.jl:113",
          "At_ldiv_B{TF<:Number,TB<:Number,N}(F::Factorization{TF<:Number},B::AbstractArray{TB<:Number,N}) at linalg/factorization.jl:805",
          "At_ldiv_B(a,b) at operators.jl:152"
        ]
      },
      {
        "name": "At_ldiv_Bt",
        "summary": "Function",
        "help": "Base.At_ldiv_Bt(...)\n\n   Matrix operator A^T \\ B^T\n",
        "methods": 
        [
          "At_ldiv_Bt{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})}(A::LU{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})},B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/lu.jl:115",
          "At_ldiv_Bt(a,b) at operators.jl:154"
        ]
      },
      {
        "name": "At_mul_B",
        "summary": "Function",
        "help": "Base.At_mul_B(...)\n\n   Matrix operator A^T B\n",
        "methods": 
        [
          "At_mul_B{T<:Real}(x::Array{T<:Real,1},y::Array{T<:Real,1}) at linalg/matmul.jl:62",
          "At_mul_B{T<:Union(Complex{Float64},Complex{Float32})}(x::Array{T<:Union(Complex{Float64},Complex{Float32}),1},y::Array{T<:Union(Complex{Float64},Complex{Float32}),1}) at linalg/matmul.jl:63",
          "At_mul_B{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),x::Union(DenseArray{S,1},SubArray{S,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:90",
          "At_mul_B{T,S}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),x::Union(DenseArray{S,1},SubArray{S,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:94",
          "At_mul_B{T,S}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{S,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,2})) at linalg/matmul.jl:133",
          "At_mul_B{T<:Union(Float64,Float32)}(A::Triangular{T<:Union(Float64,Float32)},b::Array{T<:Union(Float64,Float32),1}) at linalg/triangular.jl:25",
          "At_mul_B{TA,S,Tx}(A::SparseMatrixCSC{TA,S},x::AbstractArray{Tx,1}) at linalg/sparse.jl:91",
          "At_mul_B{Tv<:Union(Float64,Float32),Ti<:Union(Int64,Int32)}(A::CholmodSparse{Tv<:Union(Float64,Float32),Ti<:Union(Int64,Int32)},B::CholmodSparse{Tv<:Union(Float64,Float32),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:870",
          "At_mul_B(a,b) at operators.jl:137",
          "At_mul_B(A,B,C) at deprecated.jl:26"
        ]
      },
      {
        "name": "At_mul_B!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "At_mul_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(y::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),x::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:97",
          "At_mul_B!(y::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1}),A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),x::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/matmul.jl:98",
          "At_mul_B!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(C::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:136",
          "At_mul_B!(C::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/matmul.jl:137",
          "At_mul_B!(A::Diagonal{T},B::AbstractArray{T,2}) at linalg/diagonal.jl:50",
          "At_mul_B!(α::Number,A::SparseMatrixCSC{Tv,Ti<:Integer},x::AbstractArray{T,1},β::Number,y::AbstractArray{T,1}) at linalg/sparse.jl:62",
          "At_mul_B!(y::AbstractArray{T,1},A::SparseMatrixCSC{Tv,Ti<:Integer},x::AbstractArray{T,1}) at linalg/sparse.jl:85"
        ]
      },
      {
        "name": "At_mul_Bt",
        "summary": "Function",
        "help": "Base.At_mul_Bt(...)\n\n   Matrix operator A^T B^T\n",
        "methods": 
        [
          "At_mul_Bt{T,S}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{S,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,2})) at linalg/matmul.jl:157",
          "At_mul_Bt(a,b) at operators.jl:139",
          "At_mul_Bt(A,B,C) at deprecated.jl:26"
        ]
      },
      {
        "name": "At_mul_Bt!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "At_mul_Bt!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(C::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/matmul.jl:160",
          "At_mul_Bt!(C::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/matmul.jl:161"
        ]
      },
      {
        "name": "At_rdiv_B",
        "summary": "Function",
        "help": "Base.At_rdiv_B(a, b)\n\n   Matrix operator A^T / B\n",
        "methods": 
        [
          "At_rdiv_B(a,b) at operators.jl:145"
        ]
      },
      {
        "name": "At_rdiv_Bt",
        "summary": "Function",
        "help": "Base.At_rdiv_Bt(a, b)\n\n   Matrix operator A^T / B^T\n",
        "methods": 
        [
          "At_rdiv_Bt(a,b) at operators.jl:147"
        ]
      },
      {
        "name": "BLAS",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Base",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Base64Pipe",
        "summary": "DataType",
        "help": "Base.Base64Pipe(ostream)\n\n   Returns a new write-only I/O stream, which converts any bytes\n   written to it into base64-encoded ASCII bytes written to\n   \"ostream\".  Calling \"close\" on the \"Base64Pipe\" stream is\n   necessary to complete the encoding (but does not close\n   \"ostream\").\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Bidiagonal",
        "summary": "DataType",
        "help": "Base.Bidiagonal(dv, ev, isupper)\n\n   Constructs an upper (\"isupper=true\") or lower (\"isupper=false\")\n   bidiagonal matrix using the given diagonal (\"dv\") and off-\n   diagonal (\"ev\") vectors.  The result is of type \"Bidiagonal\"\n   and provides efficient specialized linear solvers, but may be\n   converted into a regular matrix with \"full()\".\n",
        "methods": 
        [

        ]
      },
      {
        "name": "BigFloat",
        "summary": "DataType",
        "help": "Base.BigFloat(x)\n\n   Create an arbitrary precision floating point number. \"x\" may be\n   an \"Integer\", a \"Float64\", a \"String\" or a \"BigInt\". The\n   usual mathematical operators are defined for this type, and results\n   are promoted to a \"BigFloat\". Note that because floating-point\n   numbers are not exactly-representable in decimal notation,\n   \"BigFloat(2.1)\" may not yield what you expect. You may prefer to\n   initialize constants using strings, e.g., \"BigFloat(\"2.1\")\".\n",
        "methods": 
        [

        ]
      },
      {
        "name": "BigInt",
        "summary": "DataType",
        "help": "Base.BigInt(x)\n\n   Create an arbitrary precision integer. \"x\" may be an \"Int\" (or\n   anything that can be converted to an \"Int\") or a \"String\". The\n   usual mathematical operators are defined for this type, and results\n   are promoted to a \"BigInt\".\n",
        "methods": 
        [

        ]
      },
      {
        "name": "BitArray",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "BitMatrix",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "BitVector",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "CFILE",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "CPU_CORES",
        "summary": "Int64",
        "help": "Base.CPU_CORES\n\n   The number of CPU cores in the system.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "C_NULL",
        "summary": "Ptr{None}",
        "help": "Base.C_NULL\n\n   The C null pointer constant, sometimes used when calling external\n   code.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Cchar",
        "summary": "DataType",
        "help": "Base.Cchar\n\n   Equivalent to the native \"char\" c-type\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Cdouble",
        "summary": "DataType",
        "help": "Base.Cdouble\n\n   Equivalent to the native \"double\" c-type (Float64)\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Cfloat",
        "summary": "DataType",
        "help": "Base.Cfloat\n\n   Equivalent to the native \"float\" c-type (Float32)\n",
        "methods": 
        [

        ]
      },
      {
        "name": "CharString",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Cint",
        "summary": "DataType",
        "help": "Base.Cint\n\n   Equivalent to the native \"signed int\" c-type (Int32)\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Clong",
        "summary": "DataType",
        "help": "Base.Clong\n\n   Equivalent to the native \"signed long\" c-type\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Clonglong",
        "summary": "DataType",
        "help": "Base.Clonglong\n\n   Equivalent to the native \"signed long long\" c-type (Int64)\n",
        "methods": 
        [

        ]
      },
      {
        "name": "ClusterManager",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Cmd",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Coff_t",
        "summary": "DataType",
        "help": "Base.Coff_t\n\n   Equivalent to the native \"off_t\" c-type\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Collections",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Colon",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Complex",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Complex128",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Complex32",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Complex64",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "ComplexPair",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Condition",
        "summary": "DataType",
        "help": "Base.Condition()\n\n   Create an edge-triggered event source that tasks can wait for.\n   Tasks that call \"wait\" on a \"Condition\" are suspended and\n   queued. Tasks are woken up when \"notify\" is later called on the\n   \"Condition\". Edge triggering means that only tasks waiting at the\n   time \"notify\" is called can be woken up. For level-triggered\n   notifications, you must keep extra state to keep track of whether a\n   notification has happened. The \"RemoteRef\" type does this, and so\n   can be used for level-triggered events.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Cptrdiff_t",
        "summary": "DataType",
        "help": "Base.Cptrdiff_t\n\n   Equivalent to the native \"ptrdiff_t\" c-type (Int)\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Cshort",
        "summary": "DataType",
        "help": "Base.Cshort\n\n   Equivalent to the native \"signed short\" c-type (Int16)\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Csize_t",
        "summary": "DataType",
        "help": "Base.Csize_t\n\n   Equivalent to the native \"size_t\" c-type (Uint)\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Cssize_t",
        "summary": "DataType",
        "help": "Base.Cssize_t\n\n   Equivalent to the native \"ssize_t\" c-type\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Cuchar",
        "summary": "DataType",
        "help": "Base.Cuchar\n\n   Equivalent to the native \"unsigned char\" c-type (Uint8)\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Cuint",
        "summary": "DataType",
        "help": "Base.Cuint\n\n   Equivalent to the native \"unsigned int\" c-type (Uint32)\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Culong",
        "summary": "DataType",
        "help": "Base.Culong\n\n   Equivalent to the native \"unsigned long\" c-type\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Culonglong",
        "summary": "DataType",
        "help": "Base.Culonglong\n\n   Equivalent to the native \"unsigned long long\" c-type (Uint64)\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Cushort",
        "summary": "DataType",
        "help": "Base.Cushort\n\n   Equivalent to the native \"unsigned short\" c-type (Uint16)\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Cwchar_t",
        "summary": "DataType",
        "help": "Base.Cwchar_t\n\n   Equivalent to the native \"wchar_t\" c-type (Int32)\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DArray",
        "summary": "DataType",
        "help": "Base.DArray(init, dims[, procs, dist])\n\n   Construct a distributed array. The parameter \"init\" is a function\n   that accepts a tuple of index ranges. This function should allocate\n   a local chunk of the distributed array and initialize it for the\n   specified indices. \"dims\" is the overall size of the distributed\n   array. \"procs\" optionally specifies a vector of process IDs to\n   use. If unspecified, the array is distributed over all worker\n   processes only. Typically, when runnning in distributed mode, i.e.,\n   \"nprocs() > 1\", this would mean that no chunk of the distributed\n   array exists on the process hosting the interactive julia prompt.\n   \"dist\" is an integer vector specifying how many chunks the\n   distributed array should be divided into in each dimension.\n\n   For example, the \"dfill\" function that creates a distributed\n   array and fills it with a value \"v\" is implemented as:\n\n   \"dfill(v, args...) = DArray(I->fill(v, map(length,I)), args...)\"\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DL_LOAD_PATH",
        "summary": "0-element Array{Union(UTF8String,ASCIIString),1}",
        "help": "Base.DL_LOAD_PATH\n\n   When calling \"dlopen\", the paths in this list will be searched\n   first, in order, before searching the system locations for a valid\n   library handle.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DenseMatrix",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DenseVecOrMat",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DenseVector",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DevNull",
        "summary": "DevNullStream",
        "help": "Base.DevNull\n\n   Used in a stream redirect to discard all data written to it.\n   Essentially equivalent to /dev/null on Unix or NUL on Windows.\n   Usage: \"run(`cat test.txt` |> DevNull)\"\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Diagonal",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Dict",
        "summary": "DataType",
        "help": "Base.Dict()\n\n   \"Dict{K,V}()\" constructs a hashtable with keys of type K and\n   values of type V. The literal syntax is \"{\"A\"=>1, \"B\"=>2}\"\n   for a \"Dict{Any,Any}\", or \"[\"A\"=>1, \"B\"=>2]\" for a \"Dict\"\n   of inferred type.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DimensionMismatch",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Dims",
        "summary": "(DataType,)",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Display",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DivideByZeroError",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "DivideByZeroError(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "ENDIAN_BOM",
        "summary": "Uint32",
        "help": "Base.ENDIAN_BOM\n\n   The 32-bit byte-order-mark indicates the native byte order of the\n   host machine. Little-endian machines will contain the value\n   0x04030201. Big-endian machines will contain the value 0x01020304.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "ENV",
        "summary": "EnvHash",
        "help": "Base.ENV\n\n   Reference to the singleton \"EnvHash\", providing a dictionary\n   interface to system environment variables.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "EOFError",
        "summary": "DataType",
        "help": "Base.EOFError\n\n   No more data was available to read from a file or stream.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "EachLine",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Enumerate",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "ErrorException",
        "summary": "DataType",
        "help": "Base.ErrorException\n\n   Generic error type. The error message, in the *.msg* field, may\n   provide more specific details.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "FFTW",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Factorization",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "FileMonitor",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "FileOffset",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Filter",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "FloatRange",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Graphics",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Hermitian",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "I",
        "summary": "UniformScaling{Int64}",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "IO",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "IOBuffer",
        "summary": "DataType",
        "help": "Base.IOBuffer() -> IOBuffer\n\n   Create an in-memory I/O stream.\n\nBase.IOBuffer(size::Int)\n\n   Create a fixed size IOBuffer. The buffer will not grow dynamically.\n\nBase.IOBuffer(string)\n\n   Create a read-only IOBuffer on the data underlying the given string\n\nBase.IOBuffer([data][, readable, writable[, maxsize]])\n\n   Create an IOBuffer, which may optionally operate on a pre-existing\n   array. If the readable/writable arguments are given, they restrict\n   whether or not the buffer may be read from or written to\n   respectively. By default the buffer is readable but not writable.\n   The last argument optionally specifies a size beyond which the\n   buffer may not be grown.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "IOStream",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "IPv4",
        "summary": "DataType",
        "help": "Base.IPv4(host::Integer) -> IPv4\n\n   Returns IPv4 object from ip address formatted as Integer\n",
        "methods": 
        [

        ]
      },
      {
        "name": "IPv6",
        "summary": "DataType",
        "help": "Base.IPv6(host::Integer) -> IPv6\n\n   Returns IPv6 object from ip address formatted as Integer\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Inf",
        "summary": "Float64",
        "help": "Base.Inf\n\n   Positive infinity of type Float64\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Inf16",
        "summary": "Float16",
        "help": "Base.Inf16\n\n   Positive infinity of type Float16\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Inf32",
        "summary": "Float32",
        "help": "Base.Inf32\n\n   Positive infinity of type Float32\n",
        "methods": 
        [

        ]
      },
      {
        "name": "InsertionSort",
        "summary": "InsertionSortAlg",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "IntSet",
        "summary": "DataType",
        "help": "Base.IntSet([itr])\n\n   Construct a sorted set of the integers generated by the given\n   iterable object, or an empty set. Implemented as a bit string, and\n   therefore designed for dense integer sets. If the set will be\n   sparse (for example holding a single very large integer), use\n   \"Set\" instead.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "KeyError",
        "summary": "DataType",
        "help": "Base.KeyError\n\n   An indexing operation into an \"Associative\" (\"Dict\") or \"Set\"\n   like object tried to access or delete a non-existent element.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "LAPACK",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "LOAD_PATH",
        "summary": "2-element Array{Union(UTF8String,ASCIIString),1}",
        "help": "Base.LOAD_PATH\n\n   An array of paths (as strings) where the \"require\" function looks\n   for code.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "LoadError",
        "summary": "DataType",
        "help": "Base.LoadError\n\n   An error occurred while *including*, *requiring*, or *using* a\n   file. The error specifics should be available in the *.error*\n   field.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "LocalProcess",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "MIME",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "MS_ASYNC",
        "summary": "Int64",
        "help": "Base.MS_ASYNC\n\n   Enum constant for msync. See your platform man page for details.\n   (not available on Windows).\n",
        "methods": 
        [

        ]
      },
      {
        "name": "MS_INVALIDATE",
        "summary": "Int64",
        "help": "Base.MS_INVALIDATE\n\n   Enum constant for msync. See your platform man page for details.\n   (not available on Windows).\n",
        "methods": 
        [

        ]
      },
      {
        "name": "MS_SYNC",
        "summary": "Int64",
        "help": "Base.MS_SYNC\n\n   Enum constant for msync. See your platform man page for details.\n   (not available on Windows).\n",
        "methods": 
        [

        ]
      },
      {
        "name": "MathConst",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Matrix",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "MergeSort",
        "summary": "MergeSortAlg",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "MersenneTwister",
        "summary": "DataType",
        "help": "Base.MersenneTwister([seed])\n\n   Create a \"MersenneTwister\" RNG object. Different RNG objects can\n   have their own seeds, which may be useful for generating different\n   streams of random numbers.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Meta",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "MethodError",
        "summary": "DataType",
        "help": "Base.MethodError\n\n   A method with the required type signature does not exist in the\n   given generic function.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "NaN",
        "summary": "Float64",
        "help": "Base.NaN\n\n   A not-a-number value of type Float64\n",
        "methods": 
        [

        ]
      },
      {
        "name": "NaN16",
        "summary": "Float16",
        "help": "Base.NaN16\n\n   A not-a-number value of type Float16\n",
        "methods": 
        [

        ]
      },
      {
        "name": "NaN32",
        "summary": "Float32",
        "help": "Base.NaN32\n\n   A not-a-number value of type Float32\n",
        "methods": 
        [

        ]
      },
      {
        "name": "OS_NAME",
        "summary": "Symbol",
        "help": "Base.OS_NAME\n\n   A symbol representing the name of the operating system. Possible\n   values are \":Linux\", \":Darwin\" (OS X), or \":Windows\".\n",
        "methods": 
        [

        ]
      },
      {
        "name": "ObjectIdDict",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Operators",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "OrdinalRange",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "ParseError",
        "summary": "DataType",
        "help": "Base.ParseError\n\n   The expression passed to the *parse* function could not be\n   interpreted as a valid Julia expression.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PipeBuffer",
        "summary": "Function",
        "help": "Base.PipeBuffer()\n\n   An IOBuffer that allows reading and performs writes by appending.\n   Seeking and truncating are not supported. See IOBuffer for the\n   available constructors.\n\nBase.PipeBuffer(data::Vector{Uint8}[, maxsize])\n\n   Create a PipeBuffer to operate on a data vector, optionally\n   specifying a size beyond which the underlying Array may not be\n   grown.\n",
        "methods": 
        [
          "PipeBuffer(data::Array{Uint8,1},maxsize::Int64) at iobuffer.jl:26",
          "PipeBuffer(data::Array{Uint8,1}) at iobuffer.jl:27",
          "PipeBuffer() at iobuffer.jl:28",
          "PipeBuffer(maxsize::Int64) at iobuffer.jl:29"
        ]
      },
      {
        "name": "Pkg",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PollingFileWatcher",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "ProcessExitedException",
        "summary": "DataType",
        "help": "Base.ProcessExitedException\n\n   After a client Julia process has exited, further attempts to\n   reference the dead child will throw this exception.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "ProcessGroup",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Profile",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "QuickSort",
        "summary": "QuickSortAlg",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RTLD_DEEPBIND",
        "summary": "Uint32",
        "help": "Base.RTLD_DEEPBIND\n\n   Enum constant for dlopen. See your platform man page for details,\n   if applicable.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RTLD_FIRST",
        "summary": "Uint32",
        "help": "Base.RTLD_FIRST\n\n   Enum constant for dlopen. See your platform man page for details,\n   if applicable.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RTLD_GLOBAL",
        "summary": "Uint32",
        "help": "Base.RTLD_GLOBAL\n\n   Enum constant for dlopen. See your platform man page for details,\n   if applicable.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RTLD_LAZY",
        "summary": "Uint32",
        "help": "Base.RTLD_LAZY\n\n   Enum constant for dlopen. See your platform man page for details,\n   if applicable.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RTLD_LOCAL",
        "summary": "Uint32",
        "help": "Base.RTLD_LOCAL\n\n   Enum constant for dlopen. See your platform man page for details,\n   if applicable.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RTLD_NODELETE",
        "summary": "Uint32",
        "help": "Base.RTLD_NODELETE\n\n   Enum constant for dlopen. See your platform man page for details,\n   if applicable.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RTLD_NOLOAD",
        "summary": "Uint32",
        "help": "Base.RTLD_NOLOAD\n\n   Enum constant for dlopen. See your platform man page for details,\n   if applicable.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RTLD_NOW",
        "summary": "Uint32",
        "help": "Base.RTLD_NOW\n\n   Enum constant for dlopen. See your platform man page for details,\n   if applicable.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Range",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Range1",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RangeIndex",
        "summary": "UnionType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Ranges",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Rational",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RawFD",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Regex",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RegexMatch",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RemoteRef",
        "summary": "DataType",
        "help": "Base.RemoteRef()\n\n   Make an uninitialized remote reference on the local machine.\n\nBase.RemoteRef(n)\n\n   Make an uninitialized remote reference on process \"n\".\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RepString",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RevString",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RopeString",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RoundDown",
        "summary": "RoundingMode",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RoundFromZero",
        "summary": "RoundingMode",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RoundNearest",
        "summary": "RoundingMode",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RoundToZero",
        "summary": "RoundingMode",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RoundUp",
        "summary": "RoundingMode",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RoundingMode",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "STDERR",
        "summary": "TTY",
        "help": "Base.STDERR\n\n   Global variable referring to the standard error stream.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "STDIN",
        "summary": "TTY",
        "help": "Base.STDIN\n\n   Global variable referring to the standard input stream.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "STDOUT",
        "summary": "TTY",
        "help": "Base.STDOUT\n\n   Global variable referring to the standard out stream.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Set",
        "summary": "DataType",
        "help": "Base.Set([itr])\n\n   Construct a \"Set\" of the values generated by the given iterable\n   object, or an empty set. Should be used instead of \"IntSet\" for\n   sparse integer sets, or for sets of arbitrary objects.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SharedArray",
        "summary": "DataType",
        "help": "Base.SharedArray(T::Type, dims::NTuple; init=false, pids=Int[])\n\n   Construct a SharedArray of a bitstype \"T\"  and size \"dims\"\n   across the processes specified by \"pids\" - all of which have to\n   be on the same host.\n\n   If \"pids\" is left unspecified, the shared array will be mapped\n   across all workers on the current host.\n\n   If an \"init\" function of the type \"initfn(S::SharedArray)\" is\n   specified, it is called on all the participating workers.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SharedMatrix",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SharedVector",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SparseMatrixCSC",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SpawnNullStream",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "SpawnNullStream() at deprecated.jl:26"
        ]
      },
      {
        "name": "Stat",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "StatStruct",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "StepRange",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "StridedArray",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "StridedMatrix",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "StridedVecOrMat",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "StridedVector",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SubArray",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SubDArray",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SubOrDArray",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SubString",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SymTridiagonal",
        "summary": "DataType",
        "help": "Base.SymTridiagonal(d, du)\n\n   Construct a real symmetric tridiagonal matrix from the diagonal and\n   upper diagonal, respectively. The result is of type\n   \"SymTridiagonal\" and provides efficient specialized eigensolvers,\n   but may be converted into a regular matrix with \"full()\".\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Symmetric",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Sys",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SystemError",
        "summary": "DataType",
        "help": "Base.SystemError\n\n   A system call failed with an error code (in the \"errno\" global\n   variable).\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Test",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "TextDisplay",
        "summary": "DataType",
        "help": "Base.TextDisplay(stream)\n\n   Returns a \"TextDisplay <: Display\", which can display any object\n   as the text/plain MIME type (only), writing the text representation\n   to the given I/O stream.  (The text representation is the same as\n   the way an object is printed in the Julia REPL.)\n",
        "methods": 
        [

        ]
      },
      {
        "name": "TimeoutAsyncWork",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Timer",
        "summary": "DataType",
        "help": "Base.Timer(f::Function)\n\n   Create a timer to call the given callback function. The callback is\n   passed two arguments: the timer object itself, and a status code,\n   which will be 0 unless an error occurs. The timer can be started\n   and stopped with \"start_timer\" and \"stop_timer\".\n",
        "methods": 
        [

        ]
      },
      {
        "name": "TmStruct",
        "summary": "DataType",
        "help": "Base.TmStruct([seconds])\n\n   Convert a number of seconds since the epoch to broken-down format,\n   with fields \"sec\", \"min\", \"hour\", \"mday\", \"month\",\n   \"year\", \"wday\", \"yday\", and \"isdst\".\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Triangular",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Tridiagonal",
        "summary": "DataType",
        "help": "Base.Tridiagonal(dl, d, du)\n\n   Construct a tridiagonal matrix from the lower diagonal, diagonal,\n   and upper diagonal, respectively.  The result is of type\n   \"Tridiagonal\" and provides efficient specialized linear solvers,\n   but may be converted into a regular matrix with \"full()\".\n",
        "methods": 
        [

        ]
      },
      {
        "name": "TypeError",
        "summary": "DataType",
        "help": "Base.TypeError\n\n   A type assertion failure, or calling an intrinsic function with an\n   incorrect argument type.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "UTF16String",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "UTF32String",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "UdpSocket",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "UniformScaling",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "UnitRange",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "VERSION",
        "summary": "VersionNumber",
        "help": "Base.VERSION\n\n   An object describing which version of Julia is in use.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "VecOrMat",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Vector",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "VersionNumber",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "WORD_SIZE",
        "summary": "Int64",
        "help": "Base.WORD_SIZE\n\n   Standard word size on the current machine, in bits.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "WeakKeyDict",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "WeakRef",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Woodbury",
        "summary": "DataType",
        "help": "Base.Woodbury(A, U, C, V)\n\n   Construct a matrix in a form suitable for applying the Woodbury\n   matrix identity.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Zip",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "\\",
        "summary": "Function",
        "help": "Base.\\(x, y)\n\n   Binary right-division operator.\n\nBase.\\(A, B)\n\n   Matrix division using a polyalgorithm. For input matrices \"A\" and\n   \"B\", the result \"X\" is such that \"A*X == B\" when \"A\" is\n   square.  The solver that is used depends upon the structure of\n   \"A\".  A direct solver is used for upper- or lower triangular\n   \"A\".  For Hermitian \"A\" (equivalent to symmetric \"A\" for non-\n   complex \"A\") the \"BunchKaufman\" factorization is used.\n   Otherwise an LU factorization is used. For rectangular \"A\" the\n   result is the minimum-norm least squares solution computed by\n   reducing \"A\" to bidiagonal form and solving the bidiagonal least\n   squares problem.  For sparse, square \"A\" the LU factorization\n   (from UMFPACK) is used.\n",
        "methods": 
        [
          "\\(a::Float16,b::Float16) at float16.jl:125",
          "\\(x::Number,y::Number) at operators.jl:90",
          "\\(A::Number,B::AbstractArray{T,N}) at abstractarray.jl:356",
          "\\(A::BitArray{N},B::BitArray{N}) at bitarray.jl:885",
          "\\(a::Array{T,1},B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2},SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/dense.jl:406",
          "\\(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2},SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/dense.jl:408",
          "\\{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(M::SymTridiagonal{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},rhs::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/tridiag.jl:53",
          "\\{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Triangular{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/triangular.jl:38",
          "\\(A::Union(Symmetric{T},Hermitian{T}),B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2},SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/symmetric.jl:40",
          "\\(W::Woodbury{T},R::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2},SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/woodbury.jl:73",
          "\\{TD<:Number,TA<:Number}(D::Diagonal{TD<:Number},A::AbstractArray{TA<:Number,1}) at linalg/diagonal.jl:93",
          "\\(Da::Diagonal{T},Db::Diagonal{T}) at linalg/diagonal.jl:106",
          "\\{TA<:Number,Tb<:Number}(A::Union(Triangular{TA<:Number},Bidiagonal{TA<:Number}),b::AbstractArray{Tb<:Number,1}) at linalg/bidiag.jl:126",
          "\\{TA<:Number,TB<:Number}(A::Union(Triangular{TA<:Number},Bidiagonal{TA<:Number}),B::AbstractArray{TB<:Number,2}) at linalg/bidiag.jl:130",
          "\\{TA,TB,N}(A::AbstractArray{TA,2},B::AbstractArray{TB,N}) at linalg/generic.jl:233",
          "\\(a::AbstractArray{T,1},b::AbstractArray{T,N}) at linalg/generic.jl:236",
          "\\{TA,Tb}(A::Union(QRPivoted{TA},QRCompactWY{TA},QR{TA}),b::Union(DenseArray{Tb,1},SubArray{Tb,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:454",
          "\\{TA,TB}(A::Union(QRPivoted{TA},QRCompactWY{TA},QR{TA}),B::Union(DenseArray{TB,2},SubArray{TB,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:460",
          "\\{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::SVD{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Tr},B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:671",
          "\\(A::CholeskyDenseRFP{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},B::Union(Array{T,1},Array{T,2})) at linalg/rectfullpacked.jl:36",
          "\\{TF<:Number,TB<:Number,N}(F::Factorization{TF<:Number},B::AbstractArray{TB<:Number,N}) at linalg/factorization.jl:795",
          "\\(J1::UniformScaling{T<:Number},J2::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:84",
          "\\{T<:Number}(A::Union(Triangular{T<:Number},Bidiagonal{T<:Number}),J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:85",
          "\\(J::UniformScaling{T<:Number},A::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/uniformscaling.jl:86",
          "\\(A::AbstractArray{T,2},J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:87",
          "\\(x::Number,J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:89",
          "\\{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},B::CholmodDense{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/cholmod.jl:838",
          "\\{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},B::Union(Array{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},Array{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1})) at linalg/cholmod.jl:839",
          "\\{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},B::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:937",
          "\\{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},B::SparseMatrixCSC{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:844",
          "\\(A::Array{T,N},x::Number) at deprecated.jl:26"
        ]
      },
      {
        "name": "^",
        "summary": "Function",
        "help": "Base.^(s, n)\n\n   Repeat \"n\" times the string \"s\". The \"^\" operator is an alias\n   to this function.\n\n   **Example**:\n\n      julia> \"Test \"^3\n      \"Test Test Test \"\n\nBase.^(x, y)\n\n   Binary exponentiation operator.\n",
        "methods": 
        [
          "^(x::Bool,y::Bool) at bool.jl:42",
          "^(x::BigInt,y::Bool) at gmp.jl:349",
          "^(x::Integer,y::Bool) at bool.jl:43",
          "^{T<:FloatingPoint}(z::Complex{T<:FloatingPoint},p::Complex{T<:FloatingPoint}) at complex.jl:394",
          "^{T<:Complex{T<:Real}}(z::T<:Complex{T<:Real},p::T<:Complex{T<:Real}) at complex.jl:441",
          "^{T<:FloatingPoint}(z::Complex{T<:FloatingPoint},n::Bool) at complex.jl:503",
          "^{T<:Integer}(z::Complex{T<:Integer},n::Bool) at complex.jl:504",
          "^{T<:Rational{T<:Integer}}(z::Complex{T<:Rational{T<:Integer}},n::Bool) at rational.jl:181",
          "^(z::Complex{T<:Real},n::Bool) at complex.jl:500",
          "^{T<:FloatingPoint}(z::Complex{T<:FloatingPoint},n::Integer) at complex.jl:506",
          "^{T<:Integer}(z::Complex{T<:Integer},n::Integer) at complex.jl:508",
          "^{T<:Rational{T<:Integer}}(z::Complex{T<:Rational{T<:Integer}},n::Integer) at rational.jl:182",
          "^(z::Complex{T<:Real},n::Integer) at complex.jl:501",
          "^(x::Rational{T<:Integer},y::Integer) at rational.jl:174",
          "^{T<:FloatingPoint}(x::T<:FloatingPoint,y::Rational{T<:Integer}) at rational.jl:178",
          "^{T<:FloatingPoint}(x::Complex{T<:FloatingPoint},y::Rational{T<:Integer}) at rational.jl:179",
          "^(::MathConst{:e},x::Rational{T<:Integer}) at constants.jl:74",
          "^(x::Number,y::Rational{T<:Integer}) at rational.jl:177",
          "^(x::BigInt,y::Uint64) at gmp.jl:335",
          "^(x::BigInt,y::BigInt) at gmp.jl:348",
          "^(x::BigInt,y::Integer) at gmp.jl:350",
          "^(x::Integer,y::BigInt) at gmp.jl:351",
          "^{T<:Integer}(x::T<:Integer,p::T<:Integer) at intfuncs.jl:84",
          "^(x::Float64,y::Integer) at math.jl:418",
          "^(x::Float32,y::Integer) at math.jl:420",
          "^(x::Float16,y::Integer) at float16.jl:141",
          "^(x::BigFloat,y::Union(Uint16,Uint8,Uint32,Uint64)) at mpfr.jl:377",
          "^(x::BigFloat,y::Union(Int8,Int64,Int16,Int32)) at mpfr.jl:383",
          "^(x::BigFloat,y::BigInt) at mpfr.jl:389",
          "^(::MathConst{:e},x::Integer) at constants.jl:74",
          "^(x::Number,p::Integer) at intfuncs.jl:85",
          "^(x::Float64,y::Float64) at math.jl:415",
          "^(x::Float32,y::Float32) at math.jl:416",
          "^(a::Float16,b::Float16) at float16.jl:125",
          "^(x::BigFloat,y::BigFloat) at mpfr.jl:321",
          "^(::MathConst{:e},x::MathConst{sym}) at constants.jl:74",
          "^(x::MathConst{sym},y::MathConst{sym}) at constants.jl:23",
          "^(::MathConst{:e},x::Number) at constants.jl:74",
          "^{T<:Number}(x::T<:Number,y::T<:Number) at promotion.jl:192",
          "^(x::Number,y::Number) at promotion.jl:162",
          "^(s::String,r::Integer) at string.jl:77",
          "^(A::Array{T,2},p::Integer) at linalg/dense.jl:154",
          "^(x,p::Integer) at intfuncs.jl:86",
          "^(A::Array{T,2},p::Number) at linalg/dense.jl:157",
          "^(::MathConst{:e},x::AbstractArray{T,2}) at constants.jl:79"
        ]
      },
      {
        "name": "abs",
        "summary": "Function",
        "help": "Base.abs(x)\n\n   Absolute value of \"x\"\n",
        "methods": 
        [
          "abs(x::Bool) at bool.jl:28",
          "abs(x::Unsigned) at int.jl:74",
          "abs(x::Signed) at int.jl:75",
          "abs(x::Float64) at float.jl:212",
          "abs(x::Float32) at float.jl:213",
          "abs(x::Float16) at float16.jl:123",
          "abs(x::Real) at number.jl:24",
          "abs(z::Complex{T<:Real}) at complex.jl:103",
          "abs(B::BitArray{N}) at bitarray.jl:787",
          "abs(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:464",
          "abs(f::Array{FieldValue,1}) at pkg/resolve/fieldvalue.jl:62",
          "abs{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "abs{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "abs{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357",
          "abs{T}(a::HierarchicalValue{T}) at pkg/resolve/versionweight.jl:66",
          "abs(a::VWPreBuildItem) at pkg/resolve/versionweight.jl:94",
          "abs(a::VWPreBuild) at pkg/resolve/versionweight.jl:131",
          "abs(a::VersionWeight) at pkg/resolve/versionweight.jl:185",
          "abs(a::FieldValue) at pkg/resolve/fieldvalue.jl:61"
        ]
      },
      {
        "name": "abs2",
        "summary": "Function",
        "help": "Base.abs2(x)\n\n   Squared absolute value of \"x\"\n",
        "methods": 
        [
          "abs2(x::Bool) at bool.jl:29",
          "abs2(x::Real) at number.jl:25",
          "abs2(z::Complex{T<:Real}) at complex.jl:104",
          "abs2(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:464",
          "abs2{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "abs2{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "abs2{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "abspath",
        "summary": "Function",
        "help": "Base.abspath(path::String) -> String\n\n   Convert a path to an absolute path by adding the current directory\n   if necessary.\n",
        "methods": 
        [
          "abspath(a::String) at path.jl:106",
          "abspath(a::String,b::String...) at path.jl:107"
        ]
      },
      {
        "name": "accept",
        "summary": "Function",
        "help": "Base.accept(server[, client])\n\n   Accepts a connection on the given server and returns a connection\n   to the client. An uninitialized client stream may be provided, in\n   which case it will be used instead of creating a new stream.\n",
        "methods": 
        [
          "accept(server::TcpServer) at socket.jl:338",
          "accept(server::PipeServer) at socket.jl:339",
          "accept(server::UVServer,client::AsyncStream) at stream.jl:837"
        ]
      },
      {
        "name": "acos",
        "summary": "Function",
        "help": "Base.acos(x)\n\n   Compute the inverse cosine of \"x\", where the output is in radians\n",
        "methods": 
        [
          "acos(a::Complex{Float16}) at float16.jl:134",
          "acos{T<:FloatingPoint}(z::Complex{T<:FloatingPoint}) at complex.jl:557",
          "acos(z::Complex{T<:Real}) at complex.jl:577",
          "acos(x::Float64) at math.jl:277",
          "acos(x::Float32) at math.jl:278",
          "acos(a::Float16) at float16.jl:133",
          "acos(x::BigFloat) at mpfr.jl:547",
          "acos(x::Real) at math.jl:279",
          "acos{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "acos{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "acos{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "acos{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "acosd",
        "summary": "Function",
        "help": "Base.acosd(x)\n\n   Compute the inverse cosine of \"x\", where the output is in degrees\n",
        "methods": 
        [
          "acosd{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "acosd{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "acosd{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "acosd{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "acosd(y) at math.jl:238"
        ]
      },
      {
        "name": "acosh",
        "summary": "Function",
        "help": "Base.acosh(x)\n\n   Compute the inverse hyperbolic cosine of \"x\"\n",
        "methods": 
        [
          "acosh(a::Complex{Float16}) at float16.jl:134",
          "acosh(z::Complex{T<:Real}) at complex.jl:624",
          "acosh(x::Float64) at math.jl:277",
          "acosh(x::Float32) at math.jl:278",
          "acosh(a::Float16) at float16.jl:133",
          "acosh(x::BigFloat) at mpfr.jl:547",
          "acosh(x::Real) at math.jl:279",
          "acosh{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "acosh{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "acosh{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "acot",
        "summary": "Function",
        "help": "Base.acot(x)\n\n   Compute the inverse cotangent of \"x\", where the output is in\n   radians\n",
        "methods": 
        [
          "acot{T<:Number}(y::T<:Number) at math.jl:166",
          "acot{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "acot{T<:Number}(y::AbstractArray{T<:Number,N}) at math.jl:167"
        ]
      },
      {
        "name": "acotd",
        "summary": "Function",
        "help": "Base.acotd(x)\n\n   Compute the inverse cotangent of \"x\", where the output is in\n   degrees\n",
        "methods": 
        [
          "acotd{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "acotd{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "acotd{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "acotd{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "acotd(y) at math.jl:238"
        ]
      },
      {
        "name": "acoth",
        "summary": "Function",
        "help": "Base.acoth(x)\n\n   Compute the inverse hyperbolic cotangent of \"x\"\n",
        "methods": 
        [
          "acoth{T<:Number}(y::T<:Number) at math.jl:166",
          "acoth{T<:Number}(y::AbstractArray{T<:Number,N}) at math.jl:167"
        ]
      },
      {
        "name": "acsc",
        "summary": "Function",
        "help": "Base.acsc(x)\n\n   Compute the inverse cosecant of \"x\", where the output is in\n   radians\n",
        "methods": 
        [
          "acsc{T<:Number}(y::T<:Number) at math.jl:166",
          "acsc{T<:Number}(y::AbstractArray{T<:Number,N}) at math.jl:167"
        ]
      },
      {
        "name": "acscd",
        "summary": "Function",
        "help": "Base.acscd(x)\n\n   Compute the inverse cosecant of \"x\", where the output is in\n   degrees\n",
        "methods": 
        [
          "acscd{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "acscd{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "acscd{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "acscd(y) at math.jl:238"
        ]
      },
      {
        "name": "acsch",
        "summary": "Function",
        "help": "Base.acsch(x)\n\n   Compute the inverse hyperbolic cosecant of \"x\"\n",
        "methods": 
        [
          "acsch{T<:Number}(y::T<:Number) at math.jl:166",
          "acsch{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "acsch{T<:Number}(y::AbstractArray{T<:Number,N}) at math.jl:167"
        ]
      },
      {
        "name": "add",
        "summary": "Function",
        "help": "Base.Pkg.add(pkg, vers...)\n\n   Add a requirement entry for \"pkg\" to \"Pkg.dir(\"REQUIRE\")\" and\n   call \"Pkg.resolve()\". If \"vers\" are given, they must be\n   \"VersionNumber\" objects and they specify acceptable version\n   intervals for \"pkg\".\n",
        "methods": 
        [
          "add(s::Set{T},x) at deprecated.jl:26",
          "add(s::IntSet,x) at deprecated.jl:26"
        ]
      },
      {
        "name": "add!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "add!(s::Set{T},x) at deprecated.jl:26",
          "add!(s::IntSet,x) at deprecated.jl:26",
          "add!{T,V<:Number,V2<:Number}(ct::Accumulator{T,V<:Number},r::Accumulator{T,V2<:Number}) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:51",
          "add!{T,V<:Number}(ct::Accumulator{T,V<:Number},x::T,a::V<:Number) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:45",
          "add!{T,V<:Number,V2<:Number}(ct::Accumulator{T,V<:Number},x::T,a::V2<:Number) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:46",
          "add!{T,V<:Number}(ct::Accumulator{T,V<:Number},x::T) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:47",
          "add!{K,C}(cc::ClassifiedCollections{K,C},key::K,e) at /home/samuel/.julia/v0.3/DataStructures/src/classifiedcollections.jl:44"
        ]
      },
      {
        "name": "add_each!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "add_each!(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "addprocs",
        "summary": "Function",
        "help": "Base.addprocs(n; cman::ClusterManager=LocalManager()) -> List of process identifiers\n\n   \"addprocs(4)\" will add 4 processes on the local machine. This can\n   be used to take advantage of multiple cores.\n\n   Keyword argument \"cman\" can be used to provide a custom cluster\n   manager to start workers. For example Beowulf clusters are\n   supported via a custom cluster manager implemented in  package\n   \"ClusterManagers\".\n\n   See the documentation for package \"ClusterManagers\" for more\n   information on how to write a custom cluster manager.\n\nBase.addprocs(machines; tunnel=false, dir=JULIA_HOME, sshflags::Cmd=``) -> List of process identifiers\n\n   Add processes on remote machines via SSH. Requires julia to be\n   installed in the same location on each node, or to be available via\n   a shared file system.\n\n   \"machines\" is a vector of host definitions of the form\n   \"[user@]host[:port] [bind_addr]\". \"user\" defaults to current\n   user, \"port\" to the standard ssh port. Optionally, in case of\n   multi-homed hosts, \"bind_addr\" may be used to explicitly specify\n   an interface.\n\n   Keyword arguments:\n\n   \"tunnel\" : if \"true\" then SSH tunneling will be used to connect\n   to the worker.\n\n   \"dir\" :  specifies the location of the julia binaries on the\n   worker nodes.\n\n   \"sshflags\" : specifies additional ssh options, e.g.\n   \"sshflags=`-i /home/foo/bar.pem`\" .\n",
        "methods": 
        [
          "addprocs(np::Integer) at multi.jl:1219",
          "addprocs(machines::AbstractArray{T,1}) at multi.jl:1222"
        ]
      },
      {
        "name": "addprocs_local",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "addprocs_local(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "addprocs_scyld",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "addprocs_scyld(np::Integer) at deprecated.jl:359"
        ]
      },
      {
        "name": "addprocs_sge",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "addprocs_sge(np::Integer) at deprecated.jl:364"
        ]
      },
      {
        "name": "addprocs_ssh",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "addprocs_ssh(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "addprocs_ssh_tunnel",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "addprocs_ssh_tunnel(m) at deprecated.jl:26"
        ]
      },
      {
        "name": "airy",
        "summary": "Function",
        "help": "Base.airy(k, x)\n\n   kth derivative of the Airy function \\operatorname{Ai}(x).\n",
        "methods": 
        [
          "airy(k::Int64,z::Complex{Float64}) at math.jl:457",
          "airy{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "airy{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "airy{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357",
          "airy(k::Number,x::FloatingPoint) at math.jl:503",
          "airy(k::Number,x::Real) at math.jl:504",
          "airy(k::Number,z::Complex{Float32}) at math.jl:505",
          "airy(k::Number,z::Complex{T<:Real}) at math.jl:506",
          "airy{T1<:Number,T2<:Number}(::T1<:Number,::AbstractArray{T2<:Number,N}) at operators.jl:365",
          "airy{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::T2<:Number) at operators.jl:367",
          "airy{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::AbstractArray{T2<:Number,N}) at operators.jl:371",
          "airy(z) at math.jl:490"
        ]
      },
      {
        "name": "airyai",
        "summary": "Function",
        "help": "Base.airyai(x)\n\n   Airy function \\operatorname{Ai}(x).\n",
        "methods": 
        [
          "airyai{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "airyai{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "airyai{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357",
          "airyai(x::BigFloat) at mpfr.jl:404",
          "airyai(z) at math.jl:494"
        ]
      },
      {
        "name": "airyaiprime",
        "summary": "Function",
        "help": "Base.airyaiprime(x)\n\n   Airy function derivative \\operatorname{Ai}'(x).\n",
        "methods": 
        [
          "airyaiprime{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "airyaiprime{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "airyaiprime{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357",
          "airyaiprime(z) at math.jl:496"
        ]
      },
      {
        "name": "airybi",
        "summary": "Function",
        "help": "Base.airybi(x)\n\n   Airy function \\operatorname{Bi}(x).\n",
        "methods": 
        [
          "airybi{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "airybi{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "airybi{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357",
          "airybi(z) at math.jl:498"
        ]
      },
      {
        "name": "airybiprime",
        "summary": "Function",
        "help": "Base.airybiprime(x)\n\n   Airy function derivative \\operatorname{Bi}'(x).\n",
        "methods": 
        [
          "airybiprime{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "airybiprime{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "airybiprime{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357",
          "airybiprime(z) at math.jl:500"
        ]
      },
      {
        "name": "airyprime",
        "summary": "Function",
        "help": "Base.airyprime(x)\n\n   Airy function derivative \\operatorname{Ai}'(x).\n",
        "methods": 
        [
          "airyprime{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "airyprime{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "airyprime{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357",
          "airyprime(z) at math.jl:492"
        ]
      },
      {
        "name": "all",
        "summary": "Function",
        "help": "Base.all(itr) -> Bool\n\n   Test whether all elements of a boolean collection are true.\n\nBase.all(A, dims)\n\n   Test whether all values along the given dimensions of an array are\n   true.\n\nBase.all(p, itr) -> Bool\n\n   Determine whether predicate \"p\" returns true for all elements of\n   \"itr\".\n\n   **Example**:\n\n      julia> all(i->(4<=i<=6), [4,5,6])\n      true\n",
        "methods": 
        [
          "all(x::()) at tuple.jl:124",
          "all(x::(Any,Any...)) at tuple.jl:125",
          "all(pred::Union(Func{1},Function),itr) at reduce.jl:637",
          "all(B::BitArray{N}) at bitarray.jl:1393",
          "all(A::AbstractArray{Bool,N},region) at reducedim.jl:219",
          "all(itr) at reduce.jl:610"
        ]
      },
      {
        "name": "all!",
        "summary": "Function",
        "help": "Base.all!(r, A)\n\n   Test whether all values in \"A\" along the singleton dimensions of\n   \"r\" are true, and write results to \"r\".\n",
        "methods": 
        [
          "all!(r::AbstractArray{T,N},A::AbstractArray{Bool,N}) at reducedim.jl:218"
        ]
      },
      {
        "name": "angle",
        "summary": "Function",
        "help": "Base.angle(z)\n\n   Compute the phase angle of a complex number \"z\"\n",
        "methods": 
        [
          "angle(z::Real) at number.jl:32",
          "angle(z::Complex{T<:Real}) at complex.jl:282",
          "angle{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "angle{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "angle{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "any",
        "summary": "Function",
        "help": "Base.any(itr) -> Bool\n\n   Test whether any elements of a boolean collection are true.\n\nBase.any(A, dims)\n\n   Test whether any values along the given dimensions of an array are\n   true.\n\nBase.any(p, itr) -> Bool\n\n   Determine whether predicate \"p\" returns true for any elements of\n   \"itr\".\n",
        "methods": 
        [
          "any(x::()) at tuple.jl:127",
          "any(x::(Any,Any...)) at tuple.jl:128",
          "any(pred::Union(Func{1},Function),itr) at reduce.jl:628",
          "any(B::BitArray{N}) at bitarray.jl:1405",
          "any(A::AbstractArray{Bool,N},region) at reducedim.jl:223",
          "any(itr) at reduce.jl:619"
        ]
      },
      {
        "name": "any!",
        "summary": "Function",
        "help": "Base.any!(r, A)\n\n   Test whether any values in \"A\" along the singleton dimensions of\n   \"r\" are true, and write results to \"r\".\n",
        "methods": 
        [
          "any!(r::AbstractArray{T,N},A::AbstractArray{Bool,N}) at reducedim.jl:222"
        ]
      },
      {
        "name": "append!",
        "summary": "Function",
        "help": "Base.append!(collection, items) -> collection.\n\n   Add the elements of \"items\" to the end of a collection.\n   \"append!([1],[2,3]) => [1,2,3]\"\n",
        "methods": 
        [
          "append!(A::Array{Bool,1},items::BitArray{1}) at bitarray.jl:489",
          "append!{T}(a::Array{T,1},items::AbstractArray{T,1}) at array.jl:470",
          "append!(B::BitArray{1},items::BitArray{1}) at bitarray.jl:471",
          "append!(B::BitArray{1},items::AbstractArray{Bool,1}) at bitarray.jl:488"
        ]
      },
      {
        "name": "apropos",
        "summary": "Function",
        "help": "Base.apropos(string)\n\n   Search documentation for functions related to \"string\".\n",
        "methods": 
        [
          "apropos(s::String) at help.jl:142",
          "apropos(io::IO,txt::String) at help.jl:144"
        ]
      },
      {
        "name": "ascii",
        "summary": "Function",
        "help": "Base.ascii(::Array{Uint8, 1})\n\n   Create an ASCII string from a byte array.\n\nBase.ascii(s)\n\n   Convert a string to a contiguous ASCII string (all characters must\n   be valid ASCII characters).\n",
        "methods": 
        [
          "ascii(x) at ascii.jl:98"
        ]
      },
      {
        "name": "asec",
        "summary": "Function",
        "help": "Base.asec(x)\n\n   Compute the inverse secant of \"x\", where the output is in radians\n",
        "methods": 
        [
          "asec{T<:Number}(y::T<:Number) at math.jl:166",
          "asec{T<:Number}(y::AbstractArray{T<:Number,N}) at math.jl:167"
        ]
      },
      {
        "name": "asecd",
        "summary": "Function",
        "help": "Base.asecd(x)\n\n   Compute the inverse secant of \"x\", where the output is in degrees\n",
        "methods": 
        [
          "asecd{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "asecd{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "asecd{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "asecd(y) at math.jl:238"
        ]
      },
      {
        "name": "asech",
        "summary": "Function",
        "help": "Base.asech(x)\n\n   Compute the inverse hyperbolic secant of \"x\"\n",
        "methods": 
        [
          "asech{T<:Number}(y::T<:Number) at math.jl:166",
          "asech{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "asech{T<:Number}(y::AbstractArray{T<:Number,N}) at math.jl:167"
        ]
      },
      {
        "name": "asin",
        "summary": "Function",
        "help": "Base.asin(x)\n\n   Compute the inverse sine of \"x\", where the output is in radians\n",
        "methods": 
        [
          "asin(a::Complex{Float16}) at float16.jl:134",
          "asin(z::Complex{T<:Real}) at complex.jl:543",
          "asin(x::Float64) at math.jl:277",
          "asin(x::Float32) at math.jl:278",
          "asin(a::Float16) at float16.jl:133",
          "asin(x::BigFloat) at mpfr.jl:547",
          "asin(x::Real) at math.jl:279",
          "asin{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "asin{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "asin{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "asin{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "asind",
        "summary": "Function",
        "help": "Base.asind(x)\n\n   Compute the inverse sine of \"x\", where the output is in degrees\n",
        "methods": 
        [
          "asind{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "asind{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "asind{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "asind{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "asind(y) at math.jl:238"
        ]
      },
      {
        "name": "asinh",
        "summary": "Function",
        "help": "Base.asinh(x)\n\n   Compute the inverse hyperbolic sine of \"x\"\n",
        "methods": 
        [
          "asinh(a::Complex{Float16}) at float16.jl:134",
          "asinh(z::Complex{T<:Real}) at complex.jl:619",
          "asinh(x::Float64) at math.jl:253",
          "asinh(x::Float32) at math.jl:254",
          "asinh(a::Float16) at float16.jl:133",
          "asinh(x::BigFloat) at mpfr.jl:547",
          "asinh(x::FloatingPoint) at math.jl:264",
          "asinh(x::Real) at math.jl:255",
          "asinh{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "asinh{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "asinh{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "asinh{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "assert",
        "summary": "Function",
        "help": "Base.assert(cond[, text])\n\n   Raise an error if \"cond\" is false. Also available as the macro\n   \"@assert expr\".\n",
        "methods": 
        [
          "assert(x) at error.jl:43",
          "assert(x,y) at deprecated.jl:26"
        ]
      },
      {
        "name": "assign",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setindex!(a::Array{Any,N},d::Union(DArray{T,N,A},SubArray{T,N,D<:DArray{T,N,A},I<:(Union(Range{Int64},Int64)...,)}),i::Int64) at darray.jl:294",
          "setindex!(A::Array{Any,N},x,i::Real) at base.jl:170",
          "setindex!{T}(s::SubArray{T,0,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v) at subarray.jl:356",
          "setindex!{T}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,i::Integer) at subarray.jl:359",
          "setindex!{T}(s::SubArray{T,2,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,i::Integer,j::Integer) at subarray.jl:362",
          "setindex!{T}(s::SubArray{T,3,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,i::Integer,j::Integer,k::Integer) at subarray.jl:365",
          "setindex!{T}(s::SubArray{T,4,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,i::Integer,j::Integer,k::Integer,l::Integer) at subarray.jl:368",
          "setindex!{T}(s::SubArray{T,5,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,i::Integer,j::Integer,k::Integer,l::Integer,m::Integer) at subarray.jl:371",
          "setindex!{T}(s::SubArray{T,2,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,ind::Integer) at multidimensional.jl:122",
          "setindex!{T}(s::SubArray{T,3,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,ind::Integer) at multidimensional.jl:122",
          "setindex!{T}(s::SubArray{T,4,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,ind::Integer) at multidimensional.jl:122",
          "setindex!{T}(s::SubArray{T,5,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,ind::Integer) at multidimensional.jl:122",
          "setindex!(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,i::Integer) at subarray.jl:345",
          "setindex!(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,is::Integer...) at subarray.jl:348",
          "setindex!(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,I::Real) at subarray.jl:390",
          "setindex!{T}(A::Array{T,N},X::Array{T,N},I::UnitRange{Int64}) at array.jl:329",
          "setindex!(a::Array{T,N},d::DArray{T,N,A},I::UnitRange{Int64}...) at darray.jl:254",
          "setindex!(a::Array{T,N},s::SubArray{T,N,D<:DArray{T,N,A},I<:(Union(Range{Int64},Int64)...,)},I::UnitRange{Int64}...) at darray.jl:265",
          "setindex!(a::Array{T,N},d::Union(DArray{T,N,A},SubArray{T,N,D<:DArray{T,N,A},I<:(Union(Range{Int64},Int64)...,)}),I::Union(UnitRange{Int64},Int64)...) at darray.jl:296",
          "setindex!(A::Array{T,2},x::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{Bool,1},J::Integer) at sparse/sparsematrix.jl:1449",
          "setindex!(A::Array{T,2},x::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{Bool,1},J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1450",
          "setindex!{T<:Integer}(A::Array{T,2},x::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{Bool,1},J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1452",
          "setindex!(A::Array{T,N},X::AbstractArray{T,N},I::AbstractArray{Bool,1}) at array.jl:379",
          "setindex!{T<:Integer}(A::Array{T,2},x::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{T<:Integer,1},J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1451",
          "setindex!{T<:Real}(A::Array{T,N},X::AbstractArray{T,N},I::AbstractArray{T<:Real,1}) at array.jl:337",
          "setindex!(A::Array{T,N},x,I::AbstractArray{Bool,1}) at array.jl:381",
          "setindex!{T<:Real}(A::Array{T,N},x,I::AbstractArray{T<:Real,1}) at array.jl:322",
          "setindex!(A::Array{T,N},X::AbstractArray{T,N},I::AbstractArray{Bool,N}) at array.jl:380",
          "setindex!(A::Array{T,2},x::SparseMatrixCSC{Tv,Ti<:Integer},I::Integer,J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1448",
          "setindex!{T}(A::Array{T,N},x) at array.jl:305",
          "setindex!{T}(A::Array{T,N},x,i0::Real) at array.jl:307",
          "setindex!{T}(A::Array{T,N},x,i0::Real,i1::Real) at array.jl:308",
          "setindex!{T}(A::Array{T,N},x,i0::Real,i1::Real,i2::Real) at array.jl:310",
          "setindex!{T}(A::Array{T,N},x,i0::Real,i1::Real,i2::Real,i3::Real) at array.jl:312",
          "setindex!{T}(A::Array{T,N},x,i0::Real,i1::Real,i2::Real,i3::Real,i4::Real) at array.jl:314",
          "setindex!{T}(A::Array{T,N},x,i0::Real,i1::Real,i2::Real,i3::Real,i4::Real,i5::Real) at array.jl:316",
          "setindex!{T}(A::Array{T,N},x,i0::Real,i1::Real,i2::Real,i3::Real,i4::Real,i5::Real,I::Real...) at array.jl:318",
          "setindex!(B::BitArray{N},x::Bool,i::Int64) at bitarray.jl:415",
          "setindex!(B::BitArray{N},X::AbstractArray{T,N},I::AbstractArray{Bool,N}) at bitarray.jl:434",
          "setindex!(B::BitArray{N},x::Bool,I_0::Int64,I_1::Int64) at multidimensional.jl:273",
          "setindex!(B::BitArray{N},x::Bool,I_0::Int64,I_1::Int64,I_2::Int64) at multidimensional.jl:273",
          "setindex!(B::BitArray{N},x::Bool,I_0::Int64,I_1::Int64,I_2::Int64,I_3::Int64) at multidimensional.jl:273",
          "setindex!(B::BitArray{N},x::Bool,I_0::Int64,I_1::Int64,I_2::Int64,I_3::Int64,I_4::Int64) at multidimensional.jl:273",
          "setindex!(B::BitArray{N},x::Bool,I_0::Int64,I::Int64...) at cartesian.jl:100",
          "setindex!(B::BitArray{N},X::AbstractArray{T,N},i::Real) at multidimensional.jl:396",
          "setindex!(B::BitArray{N},X::AbstractArray{T,N},I_1::Union(Real,AbstractArray{T,N})) at multidimensional.jl:403",
          "setindex!(B::BitArray{N},X::AbstractArray{T,N},I_1::Union(Real,AbstractArray{T,N}),I_2::Union(Real,AbstractArray{T,N})) at multidimensional.jl:403",
          "setindex!(B::BitArray{N},X::AbstractArray{T,N},I_1::Union(Real,AbstractArray{T,N}),I_2::Union(Real,AbstractArray{T,N}),I_3::Union(Real,AbstractArray{T,N})) at multidimensional.jl:403",
          "setindex!(B::BitArray{N},X::AbstractArray{T,N},I_1::Union(Real,AbstractArray{T,N}),I_2::Union(Real,AbstractArray{T,N}),I_3::Union(Real,AbstractArray{T,N}),I_4::Union(Real,AbstractArray{T,N})) at multidimensional.jl:403",
          "setindex!(B::BitArray{N},X::AbstractArray{T,N},I::Union(AbstractArray{T,N},Real)...) at cartesian.jl:100",
          "setindex!(B::BitArray{N},x) at bitarray.jl:412",
          "setindex!(B::BitArray{N},x,i::Real) at multidimensional.jl:382",
          "setindex!(S::SharedArray{T,N},x) at sharedarray.jl:214",
          "setindex!(S::SharedArray{T,N},x,I::Real) at sharedarray.jl:215",
          "setindex!(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Array{T,2},I::Integer,J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1442",
          "setindex!{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},v::AbstractArray{T,2},i::Integer,J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1140",
          "setindex!{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Number,i::Integer,J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1143",
          "setindex!(A::SparseMatrixCSC{Tv,Ti<:Integer},v,i::Integer) at sparse/sparsematrix.jl:1033",
          "setindex!{T,Ti}(A::SparseMatrixCSC{T,Ti},v,i0::Integer,i1::Integer) at sparse/sparsematrix.jl:1036",
          "setindex!{Tv,Ti,T<:Integer}(A::SparseMatrixCSC{Tv,Ti},v::AbstractArray{T,1},i::Integer,J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1317",
          "setindex!(t::AbstractArray{T,N},x,i::Real) at abstractarray.jl:425",
          "setindex!{T}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,I::UnitRange{Int64}) at subarray.jl:374",
          "setindex!{T}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,I::Range{Int64}) at subarray.jl:377",
          "setindex!{T,S<:Integer}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,I::AbstractArray{S<:Integer,1}) at subarray.jl:381",
          "setindex!(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,I::Union(AbstractArray{T,N},Real)...) at subarray.jl:394",
          "setindex!(A::Array{T,N},x,I::AbstractArray{Bool,N}) at array.jl:382",
          "setindex!(B::BitArray{N},x,I::AbstractArray{Bool,N}) at bitarray.jl:423",
          "setindex!(A::Array{T,N},x,J_1::Union(Real,AbstractArray{T,N})) at multidimensional.jl:61",
          "setindex!(A::Array{T,N},x,J_1::Union(Real,AbstractArray{T,N}),J_2::Union(Real,AbstractArray{T,N})) at multidimensional.jl:61",
          "setindex!(A::Array{T,N},x,J_1::Union(Real,AbstractArray{T,N}),J_2::Union(Real,AbstractArray{T,N}),J_3::Union(Real,AbstractArray{T,N})) at multidimensional.jl:61",
          "setindex!(A::Array{T,N},x,J_1::Union(Real,AbstractArray{T,N}),J_2::Union(Real,AbstractArray{T,N}),J_3::Union(Real,AbstractArray{T,N}),J_4::Union(Real,AbstractArray{T,N})) at multidimensional.jl:61",
          "setindex!(A::Array{T,N},x,J::Union(AbstractArray{T,N},Real)...) at cartesian.jl:100",
          "setindex!(B::BitArray{N},x,I_1::Union(Real,AbstractArray{T,N})) at multidimensional.jl:387",
          "setindex!(B::BitArray{N},x,I_1::Union(Real,AbstractArray{T,N}),I_2::Union(Real,AbstractArray{T,N})) at multidimensional.jl:387",
          "setindex!(B::BitArray{N},x,I_1::Union(Real,AbstractArray{T,N}),I_2::Union(Real,AbstractArray{T,N}),I_3::Union(Real,AbstractArray{T,N})) at multidimensional.jl:387",
          "setindex!(B::BitArray{N},x,I_1::Union(Real,AbstractArray{T,N}),I_2::Union(Real,AbstractArray{T,N}),I_3::Union(Real,AbstractArray{T,N}),I_4::Union(Real,AbstractArray{T,N})) at multidimensional.jl:387",
          "setindex!(B::BitArray{N},x,I::Union(AbstractArray{T,N},Real)...) at cartesian.jl:100",
          "setindex!(S::SharedArray{T,N},x,I::AbstractArray{T,N}) at sharedarray.jl:216",
          "setindex!(S::SharedArray{T,N},x,I_1) at sharedarray.jl:217",
          "setindex!(S::SharedArray{T,N},x,I_1,I_2) at sharedarray.jl:217",
          "setindex!(S::SharedArray{T,N},x,I_1,I_2,I_3) at sharedarray.jl:217",
          "setindex!(S::SharedArray{T,N},x,I_1,I_2,I_3,I_4) at sharedarray.jl:217",
          "setindex!(S::SharedArray{T,N},x,I_1,I_2,I_3,I_4,I_5) at sharedarray.jl:217",
          "setindex!(S::SharedArray{T,N},x,I...) at sharedarray.jl:217",
          "setindex!(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Array{T,2},I::AbstractArray{Bool,1},J::Integer) at sparse/sparsematrix.jl:1443",
          "setindex!{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},v::AbstractArray{T,2},I::AbstractArray{T<:Integer,1},j::Integer) at sparse/sparsematrix.jl:1141",
          "setindex!{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Number,I::AbstractArray{T<:Integer,1},j::Integer) at sparse/sparsematrix.jl:1144",
          "setindex!{Tv,T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Number,I::AbstractArray{T<:Integer,1},J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1146",
          "setindex!(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Array{T,2},I::AbstractArray{Bool,1},J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1444",
          "setindex!{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Array{T,2},I::AbstractArray{T<:Integer,1},J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1445",
          "setindex!{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Array{T,2},I::AbstractArray{Bool,1},J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1446",
          "setindex!{Tv,Ti,T<:Integer}(A::SparseMatrixCSC{Tv,Ti},S::Array{T,2},I::AbstractArray{T<:Integer,1},J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1313",
          "setindex!{Tv,Ti,T<:Integer}(A::SparseMatrixCSC{Tv,Ti},v::AbstractArray{T,1},I::AbstractArray{T<:Integer,1},j::Integer) at sparse/sparsematrix.jl:1316",
          "setindex!{Tv,Ti,T<:Integer}(A::SparseMatrixCSC{Tv,Ti},B::SparseMatrixCSC{Tv,Ti},I::AbstractArray{T<:Integer,1},J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1324",
          "setindex!{Tv,Ti,T<:Integer}(A::SparseMatrixCSC{Tv,Ti},v::AbstractArray{T,1},I::AbstractArray{T<:Integer,1},J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1318",
          "setindex!(A::AbstractArray{T,1},x,i1,i2,i3...) at abstractarray.jl:448",
          "setindex!(A::AbstractArray{T,2},x,i1,i2,i3,i4...) at abstractarray.jl:454",
          "setindex!(t::AbstractArray{T,N},x) at abstractarray.jl:427",
          "setindex!(t::ObjectIdDict,v::ANY,k::ANY) at dict.jl:168",
          "setindex!{K,V}(h::Dict{K,V},v0,key0) at dict.jl:444",
          "setindex!{K}(wkh::WeakKeyDict{K,V},v,key) at dict.jl:627",
          "setindex!(::EnvHash,v,k::String) at env.jl:89",
          "setindex!{K,V}(pq::PriorityQueue{K,V},value,key) at collections.jl:220",
          "setindex!{K,V}(h::HashDict{K,V,O<:Union(Nothing,Int64)},v0,key0) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:347",
          "setindex!(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "setindex!(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "setindex!(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "setindex!(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "setindex!(t::Associative{K,V},v,k1,k2,ks...) at dict.jl:138",
          "setindex!(a::ZeroOffsetVector,x,i) at linalg/tridiag.jl:84",
          "setindex!{T}(t::Trie{T},val::T,key::String) at /home/samuel/.julia/v0.3/DataStructures/src/trie.jl:17"
        ]
      },
      {
        "name": "assign_shape_check",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "assign_shape_check(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "atan",
        "summary": "Function",
        "help": "Base.atan(x)\n\n   Compute the inverse tangent of \"x\", where the output is in\n   radians\n",
        "methods": 
        [
          "atan(a::Complex{Float16}) at float16.jl:134",
          "atan(z::Complex{T<:Real}) at complex.jl:580",
          "atan(x::Float64) at math.jl:253",
          "atan(x::Float32) at math.jl:254",
          "atan(a::Float16) at float16.jl:133",
          "atan(x::BigFloat) at mpfr.jl:547",
          "atan(x::FloatingPoint) at math.jl:264",
          "atan(x::Real) at math.jl:255",
          "atan{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "atan{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "atan{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "atan{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "atan2",
        "summary": "Function",
        "help": "Base.atan2(y, x)\n\n   Compute the inverse tangent of \"y/x\", using the signs of both\n   \"x\" and \"y\" to determine the quadrant of the return value.\n",
        "methods": 
        [
          "atan2(x::Float64,y::Float64) at math.jl:328",
          "atan2(x::Float32,y::Float32) at math.jl:329",
          "atan2(a::Float16,b::Float16) at float16.jl:137",
          "atan2(y::BigFloat,x::BigFloat) at mpfr.jl:571",
          "atan2{T<:FloatingPoint}(x::T<:FloatingPoint,y::T<:FloatingPoint) at math.jl:324",
          "atan2(x::Real,y::Real) at math.jl:323",
          "atan2{T1<:Number,T2<:Number}(::T1<:Number,::AbstractArray{T2<:Number,N}) at operators.jl:365",
          "atan2{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::T2<:Number) at operators.jl:367",
          "atan2{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::AbstractArray{T2<:Number,N}) at operators.jl:371"
        ]
      },
      {
        "name": "atand",
        "summary": "Function",
        "help": "Base.atand(x)\n\n   Compute the inverse tangent of \"x\", where the output is in\n   degrees\n",
        "methods": 
        [
          "atand{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "atand{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "atand{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "atand{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "atand(y) at math.jl:238"
        ]
      },
      {
        "name": "atanh",
        "summary": "Function",
        "help": "Base.atanh(x)\n\n   Compute the inverse hyperbolic tangent of \"x\"\n",
        "methods": 
        [
          "atanh(a::Complex{Float16}) at float16.jl:134",
          "atanh{T<:FloatingPoint}(z::Complex{T<:FloatingPoint}) at complex.jl:643",
          "atanh(z::Complex{T<:Real}) at complex.jl:681",
          "atanh(x::Float64) at math.jl:277",
          "atanh(x::Float32) at math.jl:278",
          "atanh(a::Float16) at float16.jl:133",
          "atanh(x::BigFloat) at mpfr.jl:547",
          "atanh(x::Real) at math.jl:279",
          "atanh{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "atanh{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "atanh{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "atanh{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "atexit",
        "summary": "Function",
        "help": "Base.atexit(f)\n\n   Register a zero-argument function to be called at exit.\n",
        "methods": 
        [
          "atexit(f::Function) at client.jl:414"
        ]
      },
      {
        "name": "backtrace",
        "summary": "Function",
        "help": "Base.backtrace()\n\n   Get a backtrace object for the current program point.\n",
        "methods": 
        [
          "backtrace() at error.jl:30"
        ]
      },
      {
        "name": "base",
        "summary": "Function",
        "help": "Base.base(base, n[, pad])\n\n   Convert an integer to a string in the given base, optionally\n   specifying a number of digits to pad to. The base can be specified\n   as either an integer, or as a \"Uint8\" array of character values\n   to use as digit symbols.\n",
        "methods": 
        [
          "base(b::Int64,x::Unsigned,pad::Int64,neg::Bool) at intfuncs.jl:243",
          "base(b::Integer,n::BigInt) at gmp.jl:424",
          "base(b::Integer,n::Integer) at intfuncs.jl:255",
          "base(b::Integer,n::Integer,pad::Integer) at intfuncs.jl:255"
        ]
      },
      {
        "name": "base64",
        "summary": "Function",
        "help": "Base.base64(writefunc, args...)\nBase.base64(args...)\n\n   Given a \"write\"-like function \"writefunc\", which takes an I/O\n   stream as its first argument, \"base64(writefunc, args...)\" calls\n   \"writefunc\" to write \"args...\" to a base64-encoded string, and\n   returns the string.  \"base64(args...)\" is equivalent to\n   \"base64(write, args...)\": it converts its arguments into bytes\n   using the standard \"write\" functions and returns the\n   base64-encoded string.\n",
        "methods": 
        [
          "base64(f::Function,args...) at base64.jl:123",
          "base64(x...) at base64.jl:129"
        ]
      },
      {
        "name": "basename",
        "summary": "Function",
        "help": "Base.basename(path::String) -> String\n\n   Get the file name part of a path.\n",
        "methods": 
        [
          "basename(path::String) at path.jl:40"
        ]
      },
      {
        "name": "begins_with",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "begins_with(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "beginswith",
        "summary": "Function",
        "help": "Base.beginswith(string, prefix | chars)\n\n   Returns \"true\" if \"string\" starts with \"prefix\". If the\n   second argument is a vector or set of characters, tests whether the\n   first character of \"string\" belongs to that set.\n",
        "methods": 
        [
          "beginswith(a::Union(UTF8String,ASCIIString),b::Union(UTF8String,ASCIIString)) at string.jl:526",
          "beginswith(a::String,b::String) at string.jl:491",
          "beginswith(str::String,chars::Union(Char,Set{Char},AbstractArray{Char,1})) at string.jl:500",
          "beginswith(a::Array{Uint8,1},b::Array{Uint8,1}) at string.jl:527"
        ]
      },
      {
        "name": "besselh",
        "summary": "Function",
        "help": "Base.besselh(nu, k, x)\n\n   Bessel function of the third kind of order \"nu\" (Hankel\n   function). \"k\" is either 1 or 2, selecting \"hankelh1\" or\n   \"hankelh2\", respectively.\n",
        "methods": 
        [
          "besselh(nu::Float64,k::Integer,z::Complex{Float64}) at math.jl:586",
          "besselh(nu::Real,k::Integer,z::Complex{Float32}) at math.jl:628",
          "besselh(nu::Real,k::Integer,z::Complex{T<:Real}) at math.jl:629",
          "besselh(nu::Real,k::Integer,x::Real) at math.jl:630",
          "besselh{T1<:Number,T2<:Number}(::T1<:Number,::AbstractArray{T2<:Number,N}) at operators.jl:365",
          "besselh{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::T2<:Number) at operators.jl:367",
          "besselh{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::AbstractArray{T2<:Number,N}) at operators.jl:371",
          "besselh(nu,z) at math.jl:627"
        ]
      },
      {
        "name": "besseli",
        "summary": "Function",
        "help": "Base.besseli(nu, x)\n\n   Modified Bessel function of the first kind of order \"nu\",\n   I_\\nu(x).\n",
        "methods": 
        [
          "besseli(nu::Float64,z::Complex{Float64}) at math.jl:594",
          "besseli(nu::Real,z::Complex{Float32}) at math.jl:633",
          "besseli(nu::Real,z::Complex{T<:Real}) at math.jl:634",
          "besseli(nu::Real,x::Integer) at math.jl:635",
          "besseli(nu::Real,x::FloatingPoint) at math.jl:637",
          "besseli{T1<:Number,T2<:Number}(::T1<:Number,::AbstractArray{T2<:Number,N}) at operators.jl:365",
          "besseli{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::T2<:Number) at operators.jl:367",
          "besseli{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::AbstractArray{T2<:Number,N}) at operators.jl:371"
        ]
      },
      {
        "name": "besselj",
        "summary": "Function",
        "help": "Base.besselj(nu, x)\n\n   Bessel function of the first kind of order \"nu\", J_\\nu(x).\n",
        "methods": 
        [
          "besselj(nu::Float64,z::Complex{Float64}) at math.jl:602",
          "besselj(nu::Integer,x::Float32) at math.jl:613",
          "besselj(n::Integer,x::BigFloat) at mpfr.jl:436",
          "besselj(nu::Integer,x::FloatingPoint) at math.jl:609",
          "besselj(nu::FloatingPoint,x::FloatingPoint) at math.jl:645",
          "besselj(nu::Real,z::Complex{Float32}) at math.jl:655",
          "besselj(nu::Real,z::Complex{T<:Real}) at math.jl:656",
          "besselj(nu::Real,x::Integer) at math.jl:657",
          "besselj{T1<:Number,T2<:Number}(::T1<:Number,::AbstractArray{T2<:Number,N}) at operators.jl:365",
          "besselj{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::T2<:Number) at operators.jl:367",
          "besselj{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::AbstractArray{T2<:Number,N}) at operators.jl:371"
        ]
      },
      {
        "name": "besselj0",
        "summary": "Function",
        "help": "Base.besselj0(x)\n\n   Bessel function of the first kind of order 0, J_0(x).\n",
        "methods": 
        [
          "besselj0(x::Float64) at math.jl:436",
          "besselj0(x::Float32) at math.jl:437",
          "besselj0(x::BigFloat) at mpfr.jl:424",
          "besselj0(x::Real) at math.jl:441",
          "besselj0(x::Complex{T<:Real}) at math.jl:442",
          "besselj0{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "besselj0{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "besselj0{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "besselj1",
        "summary": "Function",
        "help": "Base.besselj1(x)\n\n   Bessel function of the first kind of order 1, J_1(x).\n",
        "methods": 
        [
          "besselj1(x::Float64) at math.jl:436",
          "besselj1(x::Float32) at math.jl:437",
          "besselj1(x::BigFloat) at mpfr.jl:430",
          "besselj1(x::Real) at math.jl:441",
          "besselj1(x::Complex{T<:Real}) at math.jl:442",
          "besselj1{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "besselj1{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "besselj1{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "besselk",
        "summary": "Function",
        "help": "Base.besselk(nu, x)\n\n   Modified Bessel function of the second kind of order \"nu\",\n   K_\\nu(x).\n",
        "methods": 
        [
          "besselk(nu::Float64,z::Complex{Float64}) at math.jl:617",
          "besselk(nu::Real,z::Complex{Float32}) at math.jl:660",
          "besselk(nu::Real,z::Complex{T<:Real}) at math.jl:661",
          "besselk(nu::Real,x::Integer) at math.jl:662",
          "besselk(nu::Real,x::FloatingPoint) at math.jl:664",
          "besselk{T1<:Number,T2<:Number}(::T1<:Number,::AbstractArray{T2<:Number,N}) at operators.jl:365",
          "besselk{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::T2<:Number) at operators.jl:367",
          "besselk{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::AbstractArray{T2<:Number,N}) at operators.jl:371"
        ]
      },
      {
        "name": "bessely",
        "summary": "Function",
        "help": "Base.bessely(nu, x)\n\n   Bessel function of the second kind of order \"nu\", Y_\\nu(x).\n",
        "methods": 
        [
          "bessely(nu::Float64,z::Complex{Float64}) at math.jl:620",
          "bessely(nu::Real,z::Complex{Float32}) at math.jl:674",
          "bessely(nu::Real,z::Complex{T<:Real}) at math.jl:675",
          "bessely(nu::Real,x::Integer) at math.jl:676",
          "bessely(nu::Integer,x::Float32) at math.jl:693",
          "bessely(n::Integer,x::BigFloat) at mpfr.jl:460",
          "bessely(nu::Integer,x::FloatingPoint) at math.jl:687",
          "bessely(nu::Real,x::FloatingPoint) at math.jl:678",
          "bessely{T1<:Number,T2<:Number}(::T1<:Number,::AbstractArray{T2<:Number,N}) at operators.jl:365",
          "bessely{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::T2<:Number) at operators.jl:367",
          "bessely{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::AbstractArray{T2<:Number,N}) at operators.jl:371"
        ]
      },
      {
        "name": "bessely0",
        "summary": "Function",
        "help": "Base.bessely0(x)\n\n   Bessel function of the second kind of order 0, Y_0(x).\n",
        "methods": 
        [
          "bessely0(x::Float64) at math.jl:431",
          "bessely0(x::Float32) at math.jl:432",
          "bessely0(x::BigFloat) at mpfr.jl:442",
          "bessely0(x::Real) at math.jl:441",
          "bessely0(x::Complex{T<:Real}) at math.jl:442",
          "bessely0{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "bessely0{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "bessely0{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "bessely1",
        "summary": "Function",
        "help": "Base.bessely1(x)\n\n   Bessel function of the second kind of order 1, Y_1(x).\n",
        "methods": 
        [
          "bessely1(x::Float64) at math.jl:431",
          "bessely1(x::Float32) at math.jl:432",
          "bessely1(x::BigFloat) at mpfr.jl:451",
          "bessely1(x::Real) at math.jl:441",
          "bessely1(x::Complex{T<:Real}) at math.jl:442",
          "bessely1{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "bessely1{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "bessely1{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "beta",
        "summary": "Function",
        "help": "Base.beta(x, y)\n\n   Euler integral of the first kind \\operatorname{B}(x,y) =\n   \\Gamma(x)\\Gamma(y)/\\Gamma(x+y).\n",
        "methods": 
        [
          "beta(x::Number,w::Number) at math.jl:1115",
          "beta{T1<:Number,T2<:Number}(::T1<:Number,::AbstractArray{T2<:Number,N}) at operators.jl:365",
          "beta{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::T2<:Number) at operators.jl:367",
          "beta{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::AbstractArray{T2<:Number,N}) at operators.jl:371"
        ]
      },
      {
        "name": "bfft",
        "summary": "Function",
        "help": "Base.bfft(A[, dims])\n\n   Similar to \"ifft()\", but computes an unnormalized inverse\n   (backward) transform, which must be divided by the product of the\n   sizes of the transformed dimensions in order to obtain the inverse.\n   (This is slightly more efficient than \"ifft()\" because it omits a\n   scaling step, which in some applications can be combined with other\n   computational steps elsewhere.)\n\n      \\operatorname{BDFT}(A)[k] = \\operatorname{length}(A)\n      \\operatorname{IDFT}(A)[k]\n",
        "methods": 
        [
          "bfft{T<:Union(Complex{Float64},Complex{Float32})}(X::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),N},SubArray{T<:Union(Complex{Float64},Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),region) at fftw.jl:422",
          "bfft{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region) at fftw.jl:438",
          "bfft(X::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at fftw.jl:480",
          "bfft(x::Number) at fftw.jl:683",
          "bfft(x::Number,dims) at fftw.jl:689"
        ]
      },
      {
        "name": "bfft!",
        "summary": "Function",
        "help": "Base.bfft!(A[, dims])\n\n   Same as \"bfft()\", but operates in-place on \"A\".\n",
        "methods": 
        [
          "bfft!{T<:Union(Complex{Float64},Complex{Float32})}(X::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),N},SubArray{T<:Union(Complex{Float64},Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),region) at fftw.jl:431",
          "bfft!(X::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at fftw.jl:481"
        ]
      },
      {
        "name": "big",
        "summary": "Function",
        "help": "Base.big(x)\n\n   Convert a number to a maximum precision representation (typically\n   \"BigInt\" or \"BigFloat\"). See \"BigFloat\" for information about\n   some pitfalls with floating-point numbers.\n",
        "methods": 
        [
          "big(n::Integer) at /home/samuel/julia/base/sysimg.jl:173",
          "big(x::FloatingPoint) at /home/samuel/julia/base/sysimg.jl:174",
          "big(q::Rational{T<:Integer}) at /home/samuel/julia/base/sysimg.jl:175",
          "big(z::Complex{T<:Real}) at /home/samuel/julia/base/sysimg.jl:176",
          "big(A::Triangular{T<:Number}) at linalg/triangular.jl:103",
          "big{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "big{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "big{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357",
          "big(x::MathConst{sym}) at constants.jl:51"
        ]
      },
      {
        "name": "bin",
        "summary": "Function",
        "help": "Base.bin(n[, pad])\n\n   Convert an integer to a binary string, optionally specifying a\n   number of digits to pad to.\n",
        "methods": 
        [
          "bin(x::Unsigned,pad::Int64,neg::Bool) at intfuncs.jl:189",
          "bin(x::Unsigned,p::Int64) at intfuncs.jl:259",
          "bin(x::Unsigned) at intfuncs.jl:260",
          "bin(x::Char,p::Int64) at intfuncs.jl:261",
          "bin(x::Char) at intfuncs.jl:262",
          "bin(n::BigInt) at gmp.jl:418",
          "bin(x::Integer,p::Int64) at intfuncs.jl:263",
          "bin(x::Integer) at intfuncs.jl:264"
        ]
      },
      {
        "name": "bind",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "bind(server::PipeServer,name::ASCIIString) at stream.jl:862",
          "bind(sock::TcpServer,addr::InetAddr) at socket.jl:343",
          "bind(sock::Union(TcpServer,UdpSocket),host::IPv4,port::Integer) at socket.jl:392",
          "bind(sock::UdpSocket,host::IPv6,port::Uint16) at socket.jl:412"
        ]
      },
      {
        "name": "binomial",
        "summary": "Function",
        "help": "Base.binomial(n, k)\n\n   Number of ways to choose \"k\" out of \"n\" items\n",
        "methods": 
        [
          "binomial(n::BigInt,k::Uint64) at gmp.jl:403",
          "binomial(n::BigInt,k::Integer) at gmp.jl:407",
          "binomial{T<:Integer}(n::T<:Integer,k::T<:Integer) at combinatorics.jl:68"
        ]
      },
      {
        "name": "bitbroadcast",
        "summary": "Function",
        "help": "Base.bitbroadcast(f, As...)\n\n   Like \"broadcast\", but allocates a \"BitArray\" to store the\n   result, rather then an \"Array\".\n",
        "methods": 
        [
          "bitbroadcast(f::Function,As...) at broadcast.jl:236"
        ]
      },
      {
        "name": "bitmix",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "bitmix(x,y::Uint64) at deprecated.jl:26",
          "bitmix(x,y::Int64) at deprecated.jl:26",
          "bitmix(x,y::Union(Uint32,Int32)) at deprecated.jl:26",
          "bitmix(x,y::Union(Uint64,Int64)) at deprecated.jl:26"
        ]
      },
      {
        "name": "bitpack",
        "summary": "Function",
        "help": "Base.bitpack(A::AbstractArray{T, N}) -> BitArray\n\n   Converts a numeric array to a packed boolean array\n",
        "methods": 
        [
          "bitpack{T,N}(A::AbstractArray{T,N}) at bitarray.jl:330"
        ]
      },
      {
        "name": "bits",
        "summary": "Function",
        "help": "Base.bits(n)\n\n   A string giving the literal bit representation of a number.\n",
        "methods": 
        [
          "bits(x::Union(Uint8,Int8,Bool)) at intfuncs.jl:268",
          "bits(x::Union(Float16,Uint16,Int16)) at intfuncs.jl:269",
          "bits(x::Union(Char,Float32,Uint32,Int32)) at intfuncs.jl:270",
          "bits(x::Union(Float64,Uint64,Int64)) at intfuncs.jl:271",
          "bits(x::Union(Uint128,Int128)) at intfuncs.jl:272"
        ]
      },
      {
        "name": "bitunpack",
        "summary": "Function",
        "help": "Base.bitunpack(B::BitArray{N}) -> Array{Bool,N}\n\n   Converts a packed boolean array to an array of booleans\n",
        "methods": 
        [
          "bitunpack{N}(B::BitArray{N}) at bitarray.jl:329"
        ]
      },
      {
        "name": "bkfact",
        "summary": "Function",
        "help": "Base.bkfact(A) -> BunchKaufman\n\n   Compute the Bunch-Kaufman [Bunch1977] factorization of a real\n   symmetric or complex Hermitian matrix \"A\" and return a\n   \"BunchKaufman\" object. The following functions are available for\n   \"BunchKaufman\" objects: \"size\", \"\\\", \"inv\", \"issym\",\n   \"ishermitian\".\n",
        "methods": 
        [
          "bkfact{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/bunchkaufman.jl:21",
          "bkfact{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),uplo::Symbol) at linalg/bunchkaufman.jl:21",
          "bkfact{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),uplo::Symbol,symmetric::Bool) at linalg/bunchkaufman.jl:21",
          "bkfact{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/bunchkaufman.jl:22",
          "bkfact{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),uplo::Symbol) at linalg/bunchkaufman.jl:22",
          "bkfact{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),uplo::Symbol,symmetric::Bool) at linalg/bunchkaufman.jl:22"
        ]
      },
      {
        "name": "bkfact!",
        "summary": "Function",
        "help": "Base.bkfact!(A) -> BunchKaufman\n\n   \"bkfact!\" is the same as \"bkfact()\", but saves space by\n   overwriting the input \"A\", instead of creating a copy.\n",
        "methods": 
        [
          "bkfact!{T<:Union(Float64,Float32)}(A::Union(SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2})) at linalg/bunchkaufman.jl:13",
          "bkfact!{T<:Union(Float64,Float32)}(A::Union(SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2}),uplo::Symbol) at linalg/bunchkaufman.jl:13",
          "bkfact!{T<:Union(Float64,Float32)}(A::Union(SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2}),uplo::Symbol,symmetric::Bool) at linalg/bunchkaufman.jl:13",
          "bkfact!{T<:Union(Complex{Float64},Complex{Float32})}(A::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/bunchkaufman.jl:18",
          "bkfact!{T<:Union(Complex{Float64},Complex{Float32})}(A::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),uplo::Symbol) at linalg/bunchkaufman.jl:18",
          "bkfact!{T<:Union(Complex{Float64},Complex{Float32})}(A::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),uplo::Symbol,symmetric::Bool) at linalg/bunchkaufman.jl:18"
        ]
      },
      {
        "name": "blas_set_num_threads",
        "summary": "Function",
        "help": "Base.LinAlg.BLAS.blas_set_num_threads(n)\n\n   Set the number of threads the BLAS library should use.\n",
        "methods": 
        [
          "blas_set_num_threads(n::Integer) at util.jl:101"
        ]
      },
      {
        "name": "blkdiag",
        "summary": "Function",
        "help": "Base.blkdiag(A...)\n\n   Concatenate matrices block-diagonally. Currently only implemented\n   for sparse matrices.\n",
        "methods": 
        [
          "blkdiag(X::SparseMatrixCSC{Tv,Ti<:Integer}...) at sparse/sparsematrix.jl:1539"
        ]
      },
      {
        "name": "bool",
        "summary": "Function",
        "help": "Base.bool(x)\n\n   Convert a number or numeric array to boolean\n",
        "methods": 
        [
          "bool(x::Bool) at bool.jl:9",
          "bool(x::Number) at bool.jl:10",
          "bool(x::AbstractArray{Bool,N}) at abstractarray.jl:299",
          "bool(x::AbstractArray{T,N}) at abstractarray.jl:300"
        ]
      },
      {
        "name": "brfft",
        "summary": "Function",
        "help": "Base.brfft(A, d[, dims])\n\n   Similar to \"irfft()\" but computes an unnormalized inverse\n   transform (similar to \"bfft()\"), which must be divided by the\n   product of the sizes of the transformed dimensions (of the real\n   output array) in order to obtain the inverse transform.\n",
        "methods": 
        [
          "brfft(X::Union(SubArray{Complex{Float32},N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float32},N}),d::Integer,region::Integer) at fftw.jl:564",
          "brfft(X::Union(SubArray{Complex{Float32},N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float32},N}),d::Integer,region) at fftw.jl:588",
          "brfft(X::Union(SubArray{Complex{Float64},N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float64},N}),d::Integer,region::Integer) at fftw.jl:564",
          "brfft(X::Union(SubArray{Complex{Float64},N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float64},N}),d::Integer,region) at fftw.jl:588",
          "brfft{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),d::Integer,region) at fftw.jl:596",
          "brfft(X::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),d) at fftw.jl:637",
          "brfft(x::Number,d::Integer) at fftw.jl:686",
          "brfft(x::Number,d::Integer,dims) at fftw.jl:693"
        ]
      },
      {
        "name": "broadcast",
        "summary": "Function",
        "help": "Base.broadcast(f, As...)\n\n   Broadcasts the arrays \"As\" to a common size by expanding\n   singleton dimensions, and returns an array of the results\n   \"f(as...)\" for each position.\n",
        "methods": 
        [
          "broadcast(f::Function,As...) at broadcast.jl:234"
        ]
      },
      {
        "name": "broadcast!",
        "summary": "Function",
        "help": "Base.broadcast!(f, dest, As...)\n\n   Like \"broadcast\", but store the result of \"broadcast(f, As...)\"\n   in the \"dest\" array. Note that \"dest\" is only used to store the\n   result, and does not supply arguments to \"f\" unless it is also\n   listed in the \"As\", as in \"broadcast!(f, A, A, B)\" to perform\n   \"A[:] = broadcast(f, A, B)\".\n",
        "methods": 
        [
          "broadcast!(f::Function,B::BitArray{N},As::Union(BitArray{N},Number,Array{T,N})...) at broadcast.jl:220",
          "broadcast!(f::Function,B,As::Union(BitArray{N},Number,Array{T,N})...) at broadcast.jl:220",
          "broadcast!(f::Function,B::BitArray{N},As...) at broadcast.jl:220",
          "broadcast!(f::Function,B,As...) at broadcast.jl:220"
        ]
      },
      {
        "name": "broadcast!_function",
        "summary": "Function",
        "help": "Base.broadcast!_function(f)\n\n   Like \"broadcast_function\", but for \"broadcast!\".\n",
        "methods": 
        [
          "broadcast!_function(f::Function) at broadcast.jl:238"
        ]
      },
      {
        "name": "broadcast_function",
        "summary": "Function",
        "help": "Base.broadcast_function(f)\n\n   Returns a function \"broadcast_f\" such that\n   \"broadcast_function(f)(As...) === broadcast(f, As...)\". Most\n   useful in the form \"const broadcast_f = broadcast_function(f)\".\n",
        "methods": 
        [
          "broadcast_function(f::Function) at broadcast.jl:239"
        ]
      },
      {
        "name": "broadcast_getindex",
        "summary": "Function",
        "help": "Base.broadcast_getindex(A, inds...)\n\n   Broadcasts the \"inds\" arrays to a common size like \"broadcast\",\n   and returns an array of the results \"A[ks...]\", where \"ks\" goes\n   over the positions in the broadcast.\n",
        "methods": 
        [
          "broadcast_getindex(src::AbstractArray{T,N},I::AbstractArray{T,N}...) at broadcast.jl:241"
        ]
      },
      {
        "name": "broadcast_setindex!",
        "summary": "Function",
        "help": "Base.broadcast_setindex!(A, X, inds...)\n\n   Broadcasts the \"X\" and \"inds\" arrays to a common size and\n   stores the value from each position in \"X\" at the indices given\n   by the same positions in \"inds\".\n",
        "methods": 
        [
          "broadcast_setindex!(A::AbstractArray{T,N},x,I_1::AbstractArray{T,N}) at broadcast.jl:253",
          "broadcast_setindex!(A::AbstractArray{T,N},x,I_1::AbstractArray{T,N},I_2::AbstractArray{T,N}) at broadcast.jl:253",
          "broadcast_setindex!(A::AbstractArray{T,N},x,I_1::AbstractArray{T,N},I_2::AbstractArray{T,N},I_3::AbstractArray{T,N}) at broadcast.jl:253",
          "broadcast_setindex!(A::AbstractArray{T,N},x,I_1::AbstractArray{T,N},I_2::AbstractArray{T,N},I_3::AbstractArray{T,N},I_4::AbstractArray{T,N}) at broadcast.jl:253",
          "broadcast_setindex!(A::AbstractArray{T,N},x,I::AbstractArray{T,N}...) at cartesian.jl:100"
        ]
      },
      {
        "name": "bswap",
        "summary": "Function",
        "help": "Base.bswap(n)\n\n   Byte-swap an integer\n",
        "methods": 
        [
          "bswap(x::Int8) at int.jl:194",
          "bswap(x::Uint8) at int.jl:195",
          "bswap(x::Int16) at int.jl:196",
          "bswap(x::Uint16) at int.jl:197",
          "bswap(x::Int32) at int.jl:198",
          "bswap(x::Uint32) at int.jl:199",
          "bswap(x::Int64) at int.jl:200",
          "bswap(x::Uint64) at int.jl:201",
          "bswap(x::Int128) at int.jl:202",
          "bswap(x::Uint128) at int.jl:203",
          "bswap(x::Float32) at float.jl:303",
          "bswap(x::Float64) at float.jl:304",
          "bswap(x::Char) at char.jl:37"
        ]
      },
      {
        "name": "bsxfun",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "bsxfun(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "bytes2hex",
        "summary": "Function",
        "help": "Base.bytes2hex(bin_arr::Array{Uint8, 1})\n\n   Convert an array of bytes to its hexadecimal representation. All\n   characters are in lower-case. Returns an ASCIIString.\n",
        "methods": 
        [
          "bytes2hex{T<:Uint8}(arr::Array{T<:Uint8,1}) at string.jl:1674"
        ]
      },
      {
        "name": "bytestring",
        "summary": "Function",
        "help": "Base.bytestring(::Ptr{Uint8}[, length])\n\n   Create a string from the address of a C (0-terminated) string\n   encoded in ASCII or UTF-8. A copy is made; the ptr can be safely\n   freed. If \"length\" is specified, the string does not have to be\n   0-terminated.\n\nBase.bytestring(s::String)\n\n   Convert a string to a contiguous byte array representation\n   appropriate for passing it to C functions. The string will be\n   encoded as either ASCII or UTF-8, and its underlying representation\n   will be null-terminated.\n",
        "methods": 
        [
          "bytestring(str::Union(UTF8String,ASCIIString)) at base.jl:126",
          "bytestring(io::IOBuffer) at iobuffer.jl:170",
          "bytestring() at string.jl:33",
          "bytestring(s::Array{Uint8,1}) at string.jl:34",
          "bytestring{T<:Union(UTF8String,ASCIIString)}(p::SubString{T<:Union(UTF8String,ASCIIString)}) at string.jl:652",
          "bytestring(s::String...) at string.jl:35",
          "bytestring(p::Union(Ptr{Int8},Ptr{Uint8})) at string.jl:38",
          "bytestring(p::Union(Ptr{Int8},Ptr{Uint8}),len::Integer) at string.jl:43",
          "bytestring(d::Datum) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:266"
        ]
      },
      {
        "name": "c_calloc",
        "summary": "Function",
        "help": "Base.c_calloc(num::Integer, size::Integer) -> Ptr{Void}\n\n   Call \"calloc\" from the C standard library.\n",
        "methods": 
        [
          "c_calloc(num::Integer,size::Integer) at libc.jl:91"
        ]
      },
      {
        "name": "c_free",
        "summary": "Function",
        "help": "Base.c_free(addr::Ptr)\n\n   Call \"free\" from the C standard library.\n",
        "methods": 
        [
          "c_free(p::Ptr{T}) at libc.jl:88"
        ]
      },
      {
        "name": "c_malloc",
        "summary": "Function",
        "help": "Base.c_malloc(size::Integer) -> Ptr{Void}\n\n   Call \"malloc\" from the C standard library.\n",
        "methods": 
        [
          "c_malloc(size::Integer) at libc.jl:89"
        ]
      },
      {
        "name": "c_realloc",
        "summary": "Function",
        "help": "Base.c_realloc(addr::Ptr, size::Integer) -> Ptr{Void}\n\n   Call \"realloc\" from the C standard library.\n",
        "methods": 
        [
          "c_realloc(p::Ptr{T},size::Integer) at libc.jl:90"
        ]
      },
      {
        "name": "cartesian_map",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "cartesian_map(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "cartesianmap",
        "summary": "Function",
        "help": "Base.cartesianmap(f, dims)\n\n   Given a \"dims\" tuple of integers \"(m, n, ...)\", call \"f\" on\n   all combinations of integers in the ranges \"1:m\", \"1:n\", etc.\n\n   **Example**:\n\n      julia> cartesianmap(println, (2,2))\n      11\n      21\n      12\n      22\n",
        "methods": 
        [
          "cartesianmap(body,t::()) at abstractarray.jl:1151",
          "cartesianmap(body,t::(Int64,)) at abstractarray.jl:1154",
          "cartesianmap(body,t::(Int64,Int64)) at abstractarray.jl:1160",
          "cartesianmap(body,t::(Int64,Int64,Int64)) at abstractarray.jl:1168",
          "cartesianmap(body,t::(Int64...,),it...) at abstractarray.jl:1129"
        ]
      },
      {
        "name": "cat",
        "summary": "Function",
        "help": "Base.cat(dim, A...)\n\n   Concatenate the input arrays along the specified dimension\n",
        "methods": 
        [
          "cat(catdim::Integer) at abstractarray.jl:494",
          "cat(catdim::Integer,X::Union(BitArray{N},Integer)...) at bitarray.jl:1652",
          "cat{T}(catdim::Integer,A::AbstractArray{T,N}...) at abstractarray.jl:658",
          "cat(catdim::Integer,A::AbstractArray{T,N}...) at abstractarray.jl:660",
          "cat(catdim::Integer,X...) at abstractarray.jl:599",
          "cat(lst::LinkedList{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:100",
          "cat(lst::LinkedList{T},lsts::LinkedList{T}...) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:103"
        ]
      },
      {
        "name": "catalan",
        "summary": "MathConst{:catalan}",
        "help": "Base.catalan\n\n   Catalan's constant\n",
        "methods": 
        [

        ]
      },
      {
        "name": "catch_backtrace",
        "summary": "Function",
        "help": "Base.catch_backtrace()\n\n   Get the backtrace of the current exception, for use within\n   \"catch\" blocks.\n",
        "methods": 
        [
          "catch_backtrace() at error.jl:31"
        ]
      },
      {
        "name": "cbrt",
        "summary": "Function",
        "help": "Base.cbrt(x)\n\n   Return x^{1/3}.   The prefix operator \"∛\" is equivalent to\n   \"cbrt\".\n",
        "methods": 
        [
          "cbrt(x::Float64) at math.jl:253",
          "cbrt(x::Float32) at math.jl:254",
          "cbrt(x::BigFloat) at mpfr.jl:397",
          "cbrt(x::FloatingPoint) at math.jl:261",
          "cbrt(x::Real) at math.jl:255",
          "cbrt{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "cbrt{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "cbrt{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "cd",
        "summary": "Function",
        "help": "Base.cd(dir::String)\n\n   Set the current working directory. Returns the new current\n   directory.\n\nBase.cd(f[, dir])\n\n   Temporarily changes the current working directory (HOME if not\n   specified) and applies function f before returning.\n",
        "methods": 
        [
          "cd(dir::String) at file.jl:11",
          "cd() at file.jl:13",
          "cd(f::Function,dir::String,args...) at file.jl:16",
          "cd(f::Function) at file.jl:35"
        ]
      },
      {
        "name": "ceil",
        "summary": "Function",
        "help": "Base.ceil(x[, digits[, base]])\n\n   Returns the nearest integral value of the same type as \"x\" not\n   less than \"x\". \"digits\" and \"base\" work as above.\n",
        "methods": 
        [
          "ceil(x::Integer) at int.jl:371",
          "ceil(x::Rational{T<:Integer}) at rational.jl:163",
          "ceil(x::Float64) at math.jl:291",
          "ceil(x::Float32) at math.jl:292",
          "ceil{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "ceil{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "ceil{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "ceil{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "ceil(x::Float16) at float16.jl:104",
          "ceil(x::BigFloat) at mpfr.jl:639",
          "ceil(x,digits::Integer) at floatfuncs.jl:85",
          "ceil(x,digits::Integer,base::Integer) at floatfuncs.jl:85"
        ]
      },
      {
        "name": "cell",
        "summary": "Function",
        "help": "Base.cell(dims)\n\n   Construct an uninitialized cell array (heterogeneous array).\n   \"dims\" can be either a tuple or a series of integer arguments.\n",
        "methods": 
        [
          "cell(dims::Integer...) at array.jl:164",
          "cell(dims::(Integer...,)) at array.jl:165"
        ]
      },
      {
        "name": "cfunction",
        "summary": "Function",
        "help": "Base.cfunction(fun::Function, RetType::Type, (ArgTypes...))\n\n   Generate C-callable function pointer from Julia function. Type\n   annotation of the return value in the callback function is a must\n   for situations where Julia cannot infer the return type\n   automatically.\n\n   For example:\n\n      function foo()\n          # body\n\n          retval::Float64\n      end\n\n      bar = cfunction(foo, Float64, ())\n",
        "methods": 
        [
          "cfunction(f::Function,r,a) at c.jl:23"
        ]
      },
      {
        "name": "cglobal",
        "summary": "IntrinsicFunction",
        "help": "Base.cglobal((symbol, library) or ptr[, Type=Void])\n\n   Obtain a pointer to a global variable in a C-exported shared\n   library, specified exactly as in \"ccall\".  Returns a\n   \"Ptr{Type}\", defaulting to \"Ptr{Void}\" if no Type argument is\n   supplied.  The values can be read or written by \"unsafe_load\" or\n   \"unsafe_store!\", respectively.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "char",
        "summary": "Function",
        "help": "Base.char(x)\n\n   Convert a number or array to \"Char\" data type\n",
        "methods": 
        [
          "char(x::AbstractArray{Char,N}) at abstractarray.jl:267",
          "char(x::AbstractArray{T,N}) at abstractarray.jl:270",
          "char(x::FloatingPoint) at char.jl:2",
          "char(x) at char.jl:1"
        ]
      },
      {
        "name": "charwidth",
        "summary": "Function",
        "help": "Base.charwidth(c)\n\n   Gives the number of columns needed to print a character.\n",
        "methods": 
        [
          "charwidth(c::Char) at string.jl:534"
        ]
      },
      {
        "name": "check_ascii",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "check_ascii(x) at deprecated.jl:26"
        ]
      },
      {
        "name": "check_bounds",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "check_bounds(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "check_openblas",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "check_openblas(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "check_utf8",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "check_utf8(x) at deprecated.jl:26"
        ]
      },
      {
        "name": "checkbounds",
        "summary": "Function",
        "help": "Base.checkbounds(array, indexes...)\n\n   Throw an error if the specified indexes are not in bounds for the\n   given array.\n",
        "methods": 
        [
          "checkbounds(sz::Int64,i::Int64) at abstractarray.jl:62",
          "checkbounds(sz::Int64,i::Real) at abstractarray.jl:63",
          "checkbounds(sz::Int64,r::Range{Int64}) at abstractarray.jl:65",
          "checkbounds{T<:Real}(sz::Int64,r::Range{T<:Real}) at abstractarray.jl:66",
          "checkbounds(sz::Int64,I::AbstractArray{Bool,1}) at abstractarray.jl:64",
          "checkbounds{T<:Real}(sz::Int64,I::AbstractArray{T<:Real,N}) at abstractarray.jl:69",
          "checkbounds(A::AbstractArray{T,N},I::AbstractArray{Bool,N}) at abstractarray.jl:74",
          "checkbounds(A::AbstractArray{T,2},I::Union(Real,AbstractArray{T,N}),J::Union(Real,AbstractArray{T,N})) at abstractarray.jl:79",
          "checkbounds(A::AbstractArray{T,N},I::Union(Real,AbstractArray{T,N}),J::Union(Real,AbstractArray{T,N})) at abstractarray.jl:84",
          "checkbounds(A::AbstractArray{T,N},I::Union(AbstractArray{T,N},Real)...) at abstractarray.jl:89",
          "checkbounds(A::AbstractArray{T,N},I) at abstractarray.jl:76"
        ]
      },
      {
        "name": "chol",
        "summary": "Function",
        "help": "Base.chol(A[, LU]) -> F\n\n   Compute the Cholesky factorization of a symmetric positive definite\n   matrix \"A\" and return the matrix \"F\". If \"LU\" is \":L\"\n   (Lower), \"A = L*L'\". If \"LU\" is \":U\" (Upper), \"A = R'*R\".\n",
        "methods": 
        [
          "chol(A::Union(AbstractArray{T,2},Number),uplo::Symbol) at linalg/factorization.jl:43",
          "chol(A::Union(AbstractArray{T,2},Number)) at linalg/factorization.jl:44"
        ]
      },
      {
        "name": "cholfact",
        "summary": "Function",
        "help": "Base.cholfact(A, [LU,][pivot=false,][tol=-1.0]) -> Cholesky\n\n   Compute the Cholesky factorization of a dense symmetric positive\n   (semi)definite matrix \"A\" and return either a \"Cholesky\" if\n   \"pivot=false\" or \"CholeskyPivoted\" if \"pivot=true\". \"LU\"\n   may be \":L\" for using the lower part or \":U\" for the upper\n   part. The default is to use \":U\". The triangular matrix can be\n   obtained from the factorization \"F\" with: \"F[:L]\" and\n   \"F[:U]\". The following functions are available for \"Cholesky\"\n   objects: \"size\", \"\\\", \"inv\", \"det\". For\n   \"CholeskyPivoted\" there is also defined a \"rank\". If\n   \"pivot=false\" a \"PosDefException\" exception is thrown in case\n   the matrix is not positive definite. The argument \"tol\"\n   determines the tolerance for determining the rank. For negative\n   values, the tolerance is the machine precision.\n\nBase.cholfact(A[, ll]) -> CholmodFactor\n\n   Compute the sparse Cholesky factorization of a sparse matrix \"A\".\n   If \"A\" is Hermitian its Cholesky factor is determined.  If \"A\"\n   is not Hermitian the Cholesky factor of \"A*A'\" is determined. A\n   fill-reducing permutation is used.  Methods for \"size\",\n   \"solve\", \"\\\", \"findn_nzs\", \"diag\", \"det\" and \"logdet\".\n   One of the solve methods includes an integer argument that can be\n   used to solve systems involving parts of the factorization only.\n   The optional boolean argument, \"ll\" determines whether the\n   factorization returned is of the \"A[p,p] = L*L'\" form, where\n   \"L\" is lower triangular or \"A[p,p] = L*Diagonal(D)*L'\" form\n   where \"L\" is unit lower triangular and \"D\" is a non-negative\n   vector.  The default is LDL.\n",
        "methods": 
        [
          "cholfact{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:39",
          "cholfact{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),uplo::Symbol) at linalg/factorization.jl:39",
          "cholfact{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/factorization.jl:40",
          "cholfact{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),uplo::Symbol) at linalg/factorization.jl:40",
          "cholfact(x::Number) at linalg/factorization.jl:41",
          "cholfact{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::SymmetricRFP{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/rectfullpacked.jl:31",
          "cholfact{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32},ll::Bool) at linalg/cholmod.jl:627",
          "cholfact{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32},beta::Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),ll::Bool) at linalg/cholmod.jl:641",
          "cholfact{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64},ll::Bool) at linalg/cholmod.jl:627",
          "cholfact{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64},beta::Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),ll::Bool) at linalg/cholmod.jl:641",
          "cholfact{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},beta::T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})) at linalg/cholmod.jl:873",
          "cholfact(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:874",
          "cholfact(A::SparseMatrixCSC{Tv,Ti<:Integer},ll::Bool) at linalg/cholmod.jl:875",
          "cholfact(A::SparseMatrixCSC{Tv,Ti<:Integer}) at linalg/cholmod.jl:876"
        ]
      },
      {
        "name": "cholfact!",
        "summary": "Function",
        "help": "Base.cholfact!(A, [LU,][pivot=false,][tol=-1.0]) -> Cholesky\n\n   \"cholfact!\" is the same as \"cholfact()\", but saves space by\n   overwriting the input \"A\", instead of creating a copy.\n",
        "methods": 
        [
          "cholfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:30",
          "cholfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),uplo::Symbol) at linalg/factorization.jl:30",
          "cholfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::SymmetricRFP{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/rectfullpacked.jl:30",
          "cholfact!{Tv<:Float64}(L::CholmodFactor{Tv<:Float64,Int32},A::CholmodSparse{Tv<:Float64,Int32},beta::Tv<:Float64) at linalg/cholmod.jl:669",
          "cholfact!{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32},A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:660",
          "cholfact!{Tv<:Float64}(L::CholmodFactor{Tv<:Float64,Int64},A::CholmodSparse{Tv<:Float64,Int64},beta::Tv<:Float64) at linalg/cholmod.jl:669",
          "cholfact!{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64},A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:660",
          "cholfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},A::CholmodSparse{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},beta::Number) at linalg/cholmod.jl:878",
          "cholfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},A::SparseMatrixCSC{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Integer},beta::Number) at linalg/cholmod.jl:881",
          "cholfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},A::SparseMatrixCSC{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Integer}) at linalg/cholmod.jl:883"
        ]
      },
      {
        "name": "cholpfact",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "cholpfact(A) at deprecated.jl:26"
        ]
      },
      {
        "name": "cholpfact!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "cholpfact!(A) at deprecated.jl:26",
          "cholpfact!(A,uplo) at deprecated.jl:26",
          "cholpfact!(A,uplo,tol) at deprecated.jl:26"
        ]
      },
      {
        "name": "chomp",
        "summary": "Function",
        "help": "Base.chomp(string)\n\n   Remove a trailing newline from a string\n",
        "methods": 
        [
          "chomp(s::Union(UTF8String,ASCIIString)) at string.jl:1406",
          "chomp(s::String) at string.jl:1400"
        ]
      },
      {
        "name": "chop",
        "summary": "Function",
        "help": "Base.chop(string)\n\n   Remove the last character from a string\n",
        "methods": 
        [
          "chop(s::String) at string.jl:1397"
        ]
      },
      {
        "name": "chr2ind",
        "summary": "Function",
        "help": "Base.chr2ind(string, i)\n\n   Convert a character index to a byte index\n",
        "methods": 
        [
          "chr2ind(s::DirectIndexString,i::Integer) at string.jl:143",
          "chr2ind(s::String,i::Integer) at string.jl:160"
        ]
      },
      {
        "name": "circshift",
        "summary": "Function",
        "help": "Base.circshift(A, shifts)\n\n   Circularly shift the data in an array. The second argument is a\n   vector giving the amount to shift in each dimension.\n",
        "methods": 
        [
          "circshift(a,shiftamt::Real) at abstractarray.jl:410",
          "circshift(a,shiftamts) at abstractarray.jl:412"
        ]
      },
      {
        "name": "cis",
        "summary": "Function",
        "help": "Base.cis(z)\n\n   Return \"cos(z) + i*sin(z)\" if z is real. Return \"(cos(real(z)) +\n   i*sin(real(z)))/exp(imag(z))\" if \"z\" is complex\n",
        "methods": 
        [
          "cis(theta::Real) at complex.jl:276",
          "cis(z::Complex{T<:Real}) at complex.jl:278"
        ]
      },
      {
        "name": "clamp",
        "summary": "Function",
        "help": "Base.clamp(x, lo, hi)\n\n   Return x if \"lo <= x <= hi\". If \"x < lo\", return \"lo\". If \"x\n   > hi\", return \"hi\". Arguments are promoted to a common type.\n   Operates elementwise over \"x\" if it is an array.\n",
        "methods": 
        [
          "clamp{T}(x::AbstractArray{T,1},lo,hi) at math.jl:36",
          "clamp{T}(x::AbstractArray{T,2},lo,hi) at math.jl:37",
          "clamp{T}(x::AbstractArray{T,N},lo,hi) at math.jl:39",
          "clamp{X,L,H}(x::X,lo::L,hi::H) at math.jl:30"
        ]
      },
      {
        "name": "clipboard",
        "summary": "Function",
        "help": "Base.clipboard(x)\n\n   Send a printed form of \"x\" to the operating system clipboard\n   (\"copy\").\n\nBase.clipboard() -> String\n\n   Return a string with the contents of the operating system clipboard\n   (\"paste\").\n",
        "methods": 
        [
          "clipboard(x) at interactiveutil.jl:88",
          "clipboard() at interactiveutil.jl:98"
        ]
      },
      {
        "name": "close",
        "summary": "Function",
        "help": "Base.close(stream)\n\n   Close an I/O stream. Performs a \"flush\" first.\n",
        "methods": 
        [
          "close(io::IOBuffer) at iobuffer.jl:155",
          "close(b::Base64Pipe) at base64.jl:110",
          "close(s::IOStream) at io.jl:265",
          "close(t::Timer) at stream.jl:446",
          "close(stream::Union(AsyncStream,UVServer)) at stream.jl:588",
          "close(f::File) at fs.jl:83",
          "close(d::TextDisplay) at multimedia.jl:122",
          "close(t::FileMonitor) at poll.jl:22",
          "close(t::UVPollingWatcher) at poll.jl:236",
          "close(s::Session) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:94"
        ]
      },
      {
        "name": "cmp",
        "summary": "Function",
        "help": "Base.cmp(x, y)\n\n   Return -1, 0, or 1 depending on whether \"x\" is less than, equal\n   to, or greater than \"y\", respectively. Uses the total order\n   implemented by \"isless\". For floating-point numbers, uses \"<\"\n   but throws an error for unordered arguments.\n",
        "methods": 
        [
          "cmp(x::FloatingPoint,y::FloatingPoint) at float.jl:159",
          "cmp(x::Real,y::FloatingPoint) at float.jl:164",
          "cmp(x::FloatingPoint,y::Real) at float.jl:169",
          "cmp(x::BigInt,y::BigInt) at gmp.jl:325",
          "cmp(x::Real,y::Real) at operators.jl:54",
          "cmp(a::Union(UTF8String,ASCIIString),b::Union(UTF8String,ASCIIString)) at string.jl:520",
          "cmp(a::String,b::String) at string.jl:469",
          "cmp(a::Symbol,b::Symbol) at string.jl:521",
          "cmp{T}(a::HierarchicalValue{T},b::HierarchicalValue{T}) at pkg/resolve/versionweight.jl:44",
          "cmp(a::VWPreBuildItem,b::VWPreBuildItem) at pkg/resolve/versionweight.jl:87",
          "cmp(a::VWPreBuild,b::VWPreBuild) at pkg/resolve/versionweight.jl:125",
          "cmp(a::VersionWeight,b::VersionWeight) at pkg/resolve/versionweight.jl:175",
          "cmp(x,y) at operators.jl:49"
        ]
      },
      {
        "name": "code_llvm",
        "summary": "Function",
        "help": "Base.code_llvm(f, types)\n\n   Prints the LLVM bitcodes generated for running the method matching\n   the given generic function and type signature to STDOUT.\n",
        "methods": 
        [
          "code_llvm(f::Union(DataType,Function),types::(Type{T<:Top}...,)) at reflection.jl:139"
        ]
      },
      {
        "name": "code_lowered",
        "summary": "Function",
        "help": "Base.code_lowered(f, types)\n\n   Returns an array of lowered ASTs for the methods matching the given\n   generic function and type signature.\n",
        "methods": 
        [
          "code_lowered(f::Function,t::(Type{T<:Top}...,)) at reflection.jl:75"
        ]
      },
      {
        "name": "code_native",
        "summary": "Function",
        "help": "Base.code_native(f, types)\n\n   Prints the native assembly instructions generated for running the\n   method matching the given generic function and type signature to\n   STDOUT.\n",
        "methods": 
        [
          "code_native(f::Union(DataType,Function),types::(Type{T<:Top}...,)) at reflection.jl:140"
        ]
      },
      {
        "name": "code_typed",
        "summary": "Function",
        "help": "Base.code_typed(f, types)\n\n   Returns an array of lowered and type-inferred ASTs for the methods\n   matching the given generic function and type signature.\n",
        "methods": 
        [
          "code_typed(f::Union(DataType,Function),types::(Type{T<:Top}...,)) at inference.jl:2803"
        ]
      },
      {
        "name": "collect",
        "summary": "Function",
        "help": "Base.collect(collection)\n\n   Return an array of all items in a collection. For associative\n   collections, returns (key, value) tuples.\n\nBase.collect(element_type, collection)\n\n   Return an array of type \"Array{element_type,1}\" of all items in a\n   collection.\n",
        "methods": 
        [
          "collect(T::Type{T<:Top},itr) at array.jl:223",
          "collect{T}(q::Deque{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:132",
          "collect(itr) at array.jl:240"
        ]
      },
      {
        "name": "colon",
        "summary": "Function",
        "help": "Base.colon(start[, step], stop)\n\n   Called by \":\" syntax for constructing ranges.\n",
        "methods": 
        [
          "colon{T<:FloatingPoint}(start::T<:FloatingPoint,step::T<:FloatingPoint,stop::T<:FloatingPoint) at range.jl:118",
          "colon{T<:FloatingPoint}(a::T<:FloatingPoint,b::T<:FloatingPoint) at range.jl:147",
          "colon{T<:FloatingPoint}(a::T<:FloatingPoint,b::FloatingPoint,c::T<:FloatingPoint) at range.jl:150",
          "colon{T<:Real}(a::T<:Real,b::FloatingPoint,c::T<:Real) at range.jl:149",
          "colon{T<:FloatingPoint}(a::T<:FloatingPoint,b::Real,c::T<:FloatingPoint) at range.jl:151",
          "colon{T<:Real}(start::T<:Real,stop::T<:Real) at range.jl:69",
          "colon(a::Real,b::Real) at range.jl:67",
          "colon{T<:Real}(start::T<:Real,step,stop::T<:Real) at range.jl:82",
          "colon{A<:Real,C<:Real}(a::A<:Real,b,c::C<:Real) at range.jl:80",
          "colon(t1::CalendarTime,d::FixedCalendarDuration,t2::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:384",
          "colon(t1::CalendarTime,d::CalendarDuration,t2::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:389",
          "colon(t1::CalendarTime,t2::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:394",
          "colon{T}(start::T,stop::T) at range.jl:73",
          "colon{T}(start::T,step,stop::T) at range.jl:84"
        ]
      },
      {
        "name": "combinations",
        "summary": "Function",
        "help": "Base.combinations(arr, n)\n\n   Generate all combinations of \"n\" elements from an indexable\n   object.  Because the number of combinations can be very large, this\n   function returns an iterator object. Use\n   \"collect(combinations(a,n))\" to get an array of all combinations.\n",
        "methods": 
        [
          "combinations(a,t::Integer) at combinatorics.jl:243"
        ]
      },
      {
        "name": "compile_hint",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "compile_hint(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "complement",
        "summary": "Function",
        "help": "Base.complement(s)\n\n   Returns the set-complement of IntSet s.\n",
        "methods": 
        [
          "complement(s::IntSet) at intset.jl:242"
        ]
      },
      {
        "name": "complement!",
        "summary": "Function",
        "help": "Base.complement!(s)\n\n   Mutates IntSet s into its set-complement.\n",
        "methods": 
        [
          "complement!(s::IntSet) at intset.jl:235"
        ]
      },
      {
        "name": "complex",
        "summary": "Function",
        "help": "Base.complex(r, i)\n\n   Convert real numbers or arrays to complex\n",
        "methods": 
        [
          "complex(x::Real,y::Real) at complex.jl:45",
          "complex(x::Real) at complex.jl:46",
          "complex(z::Complex{T<:Real}) at complex.jl:47",
          "complex{S<:Real,T<:Real}(A::Array{S<:Real,N},B::Array{T<:Real,N}) at array.jl:804",
          "complex{T<:Real}(A::Array{T<:Real,N},B::Real) at array.jl:821",
          "complex(S1::SharedArray{T,N},S2::SharedArray{T,N}) at sharedarray.jl:313",
          "complex(S::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:178",
          "complex(A::SparseMatrixCSC{Tv,Ti<:Integer},B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:180",
          "complex{T<:Complex{T<:Real}}(x::AbstractArray{T<:Complex{T<:Real},N}) at abstractarray.jl:316",
          "complex(A::AbstractArray{T,N}) at abstractarray.jl:319",
          "complex{T<:Real}(A::Real,B::Array{T<:Real,N}) at array.jl:813"
        ]
      },
      {
        "name": "complex128",
        "summary": "Function",
        "help": "Base.complex128(r, i)\n\n   Convert to \"r+i*im\" represented as a \"Complex128\" data type\n",
        "methods": 
        [
          "complex128(r::Float64,i::Float64) at complex.jl:49",
          "complex128(r::Real,i::Real) at complex.jl:50",
          "complex128{S,N}(x::AbstractArray{S,N}) at abstractarray.jl:312",
          "complex128(z) at complex.jl:51"
        ]
      },
      {
        "name": "complex32",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "complex32(r::Float16,i::Float16) at complex.jl:55",
          "complex32(r::Real,i::Real) at complex.jl:56",
          "complex32(z) at complex.jl:57"
        ]
      },
      {
        "name": "complex64",
        "summary": "Function",
        "help": "Base.complex64(r, i)\n\n   Convert to \"r+i*im\" represented as a \"Complex64\" data type\n",
        "methods": 
        [
          "complex64(r::Float32,i::Float32) at complex.jl:52",
          "complex64(r::Real,i::Real) at complex.jl:53",
          "complex64{S,N}(x::AbstractArray{S,N}) at abstractarray.jl:312",
          "complex64(z) at complex.jl:54"
        ]
      },
      {
        "name": "cond",
        "summary": "Function",
        "help": "Base.cond(M[, p])\n\n   Condition number of the matrix \"M\", computed using the operator\n   \"p\"-norm. Valid values for \"p\" are \"1\", \"2\" (default), or\n   \"Inf\".\n",
        "methods": 
        [
          "cond(x::Number) at linalg/generic.jl:241",
          "cond(x::Number,p) at linalg/generic.jl:242",
          "cond(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/dense.jl:444",
          "cond(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),p::Real) at linalg/dense.jl:444",
          "cond{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})}(A::LU{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})},p::Number) at linalg/lu.jl:147",
          "cond(A::LU{T,S<:AbstractArray{T,2}},p::Number) at linalg/lu.jl:148",
          "cond{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Triangular{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/triangular.jl:70",
          "cond{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Triangular{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},p::Real) at linalg/triangular.jl:70"
        ]
      },
      {
        "name": "condskeel",
        "summary": "Function",
        "help": "Base.condskeel(M[, x, p])\n\n      \\kappa_S(M, p) & = \\left\\Vert \\left\\vert M \\right\\vert\n      \\left\\vert M^{-1} \\right\\vert  \\right\\Vert_p \\\\\n      \\kappa_S(M, x, p) & = \\left\\Vert \\left\\vert M \\right\\vert\n      \\left\\vert M^{-1} \\right\\vert \\left\\vert x \\right\\vert\n      \\right\\Vert_p\n\n   Skeel condition number \\kappa_S of the matrix \"M\", optionally\n   with respect to the vector \"x\", as computed using the operator\n   \"p\"-norm. \"p\" is \"Inf\" by default, if not provided. Valid\n   values for \"p\" are \"1\", \"2\", or \"Inf\".\n\n   This quantity is also known in the literature as the Bauer\n   condition number, relative condition number, or componentwise\n   relative condition number.\n",
        "methods": 
        [
          "condskeel{T<:Integer}(A::AbstractArray{T<:Integer,2}) at linalg/generic.jl:246",
          "condskeel{T<:Integer}(A::AbstractArray{T<:Integer,2},p::Real) at linalg/generic.jl:246",
          "condskeel{T<:Integer}(A::AbstractArray{T<:Integer,2},x::AbstractArray{T,1}) at linalg/generic.jl:248",
          "condskeel{T<:Integer}(A::AbstractArray{T<:Integer,2},x::AbstractArray{T,1},p::Real) at linalg/generic.jl:248",
          "condskeel(A::AbstractArray{T,2}) at linalg/generic.jl:245",
          "condskeel(A::AbstractArray{T,2},p::Real) at linalg/generic.jl:245",
          "condskeel(A::AbstractArray{T,2},x::AbstractArray{T,1}) at linalg/generic.jl:247",
          "condskeel(A::AbstractArray{T,2},x::AbstractArray{T,1},p::Real) at linalg/generic.jl:247"
        ]
      },
      {
        "name": "conj",
        "summary": "Function",
        "help": "Base.conj(z)\n\n   Compute the complex conjugate of a complex number \"z\"\n",
        "methods": 
        [
          "conj(x::Real) at number.jl:28",
          "conj(z::Complex{T<:Real}) at complex.jl:102",
          "conj(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:667",
          "conj(M::SymTridiagonal{T}) at linalg/tridiag.jl:32",
          "conj(M::Tridiagonal{T}) at linalg/tridiag.jl:188",
          "conj(D::Diagonal{T}) at linalg/diagonal.jl:73",
          "iround(M::Bidiagonal{T}) at linalg/bidiag.jl:67",
          "conj{T<:Real}(x::AbstractArray{T<:Real,N}) at abstractarray.jl:340"
        ]
      },
      {
        "name": "conj!",
        "summary": "Function",
        "help": "Base.conj!(A)\n\n   Convert an array to its complex conjugate in-place\n",
        "methods": 
        [
          "conj!{T<:Real}(x::AbstractArray{T<:Real,N}) at abstractarray.jl:341",
          "conj!{T<:Number}(A::AbstractArray{T<:Number,N}) at array.jl:658"
        ]
      },
      {
        "name": "connect",
        "summary": "Function",
        "help": "Base.connect([host], port) -> TcpSocket\n\n   Connect to the host \"host\" on port \"port\"\n\nBase.connect(path) -> Pipe\n\n   Connect to the Named Pipe/Domain Socket at \"path\"\n",
        "methods": 
        [
          "connect(sock::TcpSocket,port::Integer) at socket.jl:599",
          "connect(sock::AsyncStream,args...) at stream.jl:895",
          "connect(path::String) at stream.jl:900",
          "connect(port::Integer) at socket.jl:600",
          "connect(host::String,port::Integer) at socket.jl:603",
          "connect(addr::IpAddr,port::Integer) at socket.jl:604",
          "connect(addr::InetAddr) at socket.jl:605"
        ]
      },
      {
        "name": "consume",
        "summary": "Function",
        "help": "Base.consume(task, values...)\n\n   Receive the next value passed to \"produce\" by the specified task.\n   Additional arguments may be passed, to be returned from the last\n   \"produce\" call in the producer.\n",
        "methods": 
        [
          "consume(P::Task,values...) at task.jl:137"
        ]
      },
      {
        "name": "contains",
        "summary": "Function",
        "help": "Base.contains(haystack, needle)\n\n   Determine whether the second argument is a substring of the first.\n",
        "methods": 
        [
          "contains(eq::Function,itr,x) at reduce.jl:156",
          "contains(a::String,b::String) at string.jl:464",
          "contains(itr,x) at reduce.jl:151"
        ]
      },
      {
        "name": "conv",
        "summary": "Function",
        "help": "Base.conv(u, v)\n\n   Convolution of two vectors. Uses FFT algorithm.\n",
        "methods": 
        [
          "conv{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(u::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),v::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at dsp.jl:86",
          "conv{T<:Integer}(u::Union(DenseArray{T<:Integer,1},SubArray{T<:Integer,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),v::Union(DenseArray{T<:Integer,1},SubArray{T<:Integer,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at dsp.jl:101",
          "conv{T<:Integer,S<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(u::Union(DenseArray{T<:Integer,1},SubArray{T<:Integer,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),v::Union(DenseArray{S<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{S<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at dsp.jl:102",
          "conv{T<:Integer,S<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(u::Union(DenseArray{S<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{S<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),v::Union(DenseArray{T<:Integer,1},SubArray{T<:Integer,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at dsp.jl:103"
        ]
      },
      {
        "name": "conv2",
        "summary": "Function",
        "help": "Base.conv2(u, v, A)\n\n   2-D convolution of the matrix \"A\" with the 2-D separable kernel\n   generated by the vectors \"u\" and \"v\".  Uses 2-D FFT algorithm\n\nBase.conv2(B, A)\n\n   2-D convolution of the matrix \"B\" with the matrix \"A\".  Uses\n   2-D FFT algorithm\n",
        "methods": 
        [
          "conv2{T<:Integer}(u::Union(DenseArray{T<:Integer,1},SubArray{T<:Integer,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),v::Union(DenseArray{T<:Integer,1},SubArray{T<:Integer,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),A::Union(SubArray{T<:Integer,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Integer,2})) at dsp.jl:133",
          "conv2{T}(u::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1}),v::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1}),A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at dsp.jl:106",
          "conv2{T<:Integer}(A::Union(SubArray{T<:Integer,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Integer,2}),B::Union(SubArray{T<:Integer,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Integer,2})) at dsp.jl:132",
          "conv2{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at dsp.jl:120"
        ]
      },
      {
        "name": "convert",
        "summary": "Function",
        "help": "Base.convert(type, x)\n\n   Try to convert \"x\" to the given type. Conversions from floating\n   point to integer, rational to integer, and complex to real will\n   raise an \"InexactError\" if \"x\" cannot be represented exactly in\n   the new type.\n",
        "methods": 
        [
          "convert(::(),::()) at base.jl:15",
          "convert(::Type{(Any...,)},x::(Any...,)) at base.jl:16",
          "convert{T}(::Type{(T...,)},x::(Any...,)) at base.jl:24",
          "convert(T::(Any,Any...),x::(Any,Any...)) at base.jl:21",
          "convert{T}(::Type{FloatRange{T}},r::FloatRange{T<:FloatingPoint}) at range.jl:442",
          "convert{T}(::Type{FloatRange{T}},r::OrdinalRange{T,S}) at range.jl:447",
          "convert{T}(::Type{Array{T,1}},r::Range{T}) at range.jl:473",
          "convert(::Type{Bool},x::Bool) at bool.jl:3",
          "convert(::Type{Bool},x::Rational{T<:Integer}) at rational.jl:44",
          "convert(::Type{Bool},x::Real) at bool.jl:4",
          "convert(::Type{Int8},x::Bool) at int.jl:288",
          "convert(::Type{Int8},x::Uint8) at int.jl:291",
          "convert(::Type{Int8},x::Int16) at int.jl:283",
          "convert(::Type{Int8},x::Uint16) at int.jl:283",
          "convert(::Type{Int8},x::Int32) at int.jl:283",
          "convert(::Type{Int8},x::Uint32) at int.jl:283",
          "convert(::Type{Int8},x::Char) at int.jl:283",
          "convert(::Type{Int8},x::Int64) at int.jl:283",
          "convert(::Type{Int8},x::Uint64) at int.jl:283",
          "convert(::Type{Int8},x::Int128) at int.jl:283",
          "convert(::Type{Int8},x::Uint128) at int.jl:283",
          "convert(::Type{Uint8},x::Bool) at int.jl:288",
          "convert(::Type{Uint8},x::Int8) at int.jl:291",
          "convert(::Type{Uint8},x::Int16) at int.jl:283",
          "convert(::Type{Uint8},x::Uint16) at int.jl:283",
          "convert(::Type{Uint8},x::Int32) at int.jl:283",
          "convert(::Type{Uint8},x::Uint32) at int.jl:283",
          "convert(::Type{Uint8},x::Char) at int.jl:283",
          "convert(::Type{Uint8},x::Int64) at int.jl:283",
          "convert(::Type{Uint8},x::Uint64) at int.jl:283",
          "convert(::Type{Uint8},x::Int128) at int.jl:283",
          "convert(::Type{Uint8},x::Uint128) at int.jl:283",
          "convert(::Type{Int16},x::Bool) at int.jl:288",
          "convert(::Type{Int16},x::Int8) at int.jl:286",
          "convert(::Type{Int16},x::Uint8) at int.jl:288",
          "convert(::Type{Int16},x::Uint16) at int.jl:291",
          "convert(::Type{Int16},x::Int32) at int.jl:283",
          "convert(::Type{Int16},x::Uint32) at int.jl:283",
          "convert(::Type{Int16},x::Char) at int.jl:283",
          "convert(::Type{Int16},x::Int64) at int.jl:283",
          "convert(::Type{Int16},x::Uint64) at int.jl:283",
          "convert(::Type{Int16},x::Int128) at int.jl:283",
          "convert(::Type{Int16},x::Uint128) at int.jl:283",
          "convert(::Type{Uint16},x::Bool) at int.jl:288",
          "convert(::Type{Uint16},x::Int8) at int.jl:286",
          "convert(::Type{Uint16},x::Uint8) at int.jl:288",
          "convert(::Type{Uint16},x::Int16) at int.jl:291",
          "convert(::Type{Uint16},x::Int32) at int.jl:283",
          "convert(::Type{Uint16},x::Uint32) at int.jl:283",
          "convert(::Type{Uint16},x::Char) at int.jl:283",
          "convert(::Type{Uint16},x::Int64) at int.jl:283",
          "convert(::Type{Uint16},x::Uint64) at int.jl:283",
          "convert(::Type{Uint16},x::Int128) at int.jl:283",
          "convert(::Type{Uint16},x::Uint128) at int.jl:283",
          "convert(::Type{Int32},x::Bool) at int.jl:288",
          "convert(::Type{Int32},x::Int8) at int.jl:286",
          "convert(::Type{Int32},x::Uint8) at int.jl:288",
          "convert(::Type{Int32},x::Int16) at int.jl:286",
          "convert(::Type{Int32},x::Uint16) at int.jl:288",
          "convert(::Type{Int32},x::Uint32) at int.jl:291",
          "convert(::Type{Int32},x::Char) at int.jl:291",
          "convert(::Type{Int32},x::Int64) at int.jl:283",
          "convert(::Type{Int32},x::Uint64) at int.jl:283",
          "convert(::Type{Int32},x::Int128) at int.jl:283",
          "convert(::Type{Int32},x::Uint128) at int.jl:283",
          "convert(::Type{Uint32},x::Bool) at int.jl:288",
          "convert(::Type{Uint32},x::Int8) at int.jl:286",
          "convert(::Type{Uint32},x::Uint8) at int.jl:288",
          "convert(::Type{Uint32},x::Int16) at int.jl:286",
          "convert(::Type{Uint32},x::Uint16) at int.jl:288",
          "convert(::Type{Uint32},x::Int32) at int.jl:291",
          "convert(::Type{Uint32},x::Char) at int.jl:291",
          "convert(::Type{Uint32},x::Int64) at int.jl:283",
          "convert(::Type{Uint32},x::Uint64) at int.jl:283",
          "convert(::Type{Uint32},x::Int128) at int.jl:283",
          "convert(::Type{Uint32},x::Uint128) at int.jl:283",
          "convert(::Type{Char},x::Bool) at int.jl:288",
          "convert(::Type{Char},x::Int8) at int.jl:286",
          "convert(::Type{Char},x::Uint8) at int.jl:288",
          "convert(::Type{Char},x::Int16) at int.jl:286",
          "convert(::Type{Char},x::Uint16) at int.jl:288",
          "convert(::Type{Char},x::Int32) at int.jl:291",
          "convert(::Type{Char},x::Uint32) at int.jl:291",
          "convert(::Type{Char},x::Int64) at int.jl:283",
          "convert(::Type{Char},x::Uint64) at int.jl:283",
          "convert(::Type{Char},x::Int128) at int.jl:283",
          "convert(::Type{Char},x::Uint128) at int.jl:283",
          "convert(::Type{Int64},x::Bool) at int.jl:288",
          "convert(::Type{Int64},x::Int8) at int.jl:286",
          "convert(::Type{Int64},x::Uint8) at int.jl:288",
          "convert(::Type{Int64},x::Int16) at int.jl:286",
          "convert(::Type{Int64},x::Uint16) at int.jl:288",
          "convert(::Type{Int64},x::Int32) at int.jl:286",
          "convert(::Type{Int64},x::Uint32) at int.jl:288",
          "convert(::Type{Int64},x::Char) at int.jl:288",
          "convert(::Type{Int64},x::Uint64) at int.jl:291",
          "convert(::Type{Int64},x::Int128) at int.jl:283",
          "convert(::Type{Int64},x::Uint128) at int.jl:283",
          "convert(::Type{Uint64},x::Bool) at int.jl:288",
          "convert(::Type{Uint64},x::Int8) at int.jl:286",
          "convert(::Type{Uint64},x::Uint8) at int.jl:288",
          "convert(::Type{Uint64},x::Int16) at int.jl:286",
          "convert(::Type{Uint64},x::Uint16) at int.jl:288",
          "convert(::Type{Uint64},x::Int32) at int.jl:286",
          "convert(::Type{Uint64},x::Uint32) at int.jl:288",
          "convert(::Type{Uint64},x::Char) at int.jl:288",
          "convert(::Type{Uint64},x::Int64) at int.jl:291",
          "convert(::Type{Uint64},x::Int128) at int.jl:283",
          "convert(::Type{Uint64},x::Uint128) at int.jl:283",
          "convert(::Type{Int128},x::Bool) at int.jl:288",
          "convert(::Type{Int128},x::Int8) at int.jl:286",
          "convert(::Type{Int128},x::Uint8) at int.jl:288",
          "convert(::Type{Int128},x::Int16) at int.jl:286",
          "convert(::Type{Int128},x::Uint16) at int.jl:288",
          "convert(::Type{Int128},x::Int32) at int.jl:286",
          "convert(::Type{Int128},x::Uint32) at int.jl:288",
          "convert(::Type{Int128},x::Char) at int.jl:288",
          "convert(::Type{Int128},x::Int64) at int.jl:286",
          "convert(::Type{Int128},x::Uint64) at int.jl:288",
          "convert(::Type{Int128},x::Uint128) at int.jl:291",
          "convert(::Type{Uint128},x::Bool) at int.jl:288",
          "convert(::Type{Uint128},x::Int8) at int.jl:286",
          "convert(::Type{Uint128},x::Uint8) at int.jl:288",
          "convert(::Type{Uint128},x::Int16) at int.jl:286",
          "convert(::Type{Uint128},x::Uint16) at int.jl:288",
          "convert(::Type{Uint128},x::Int32) at int.jl:286",
          "convert(::Type{Uint128},x::Uint32) at int.jl:288",
          "convert(::Type{Uint128},x::Char) at int.jl:288",
          "convert(::Type{Uint128},x::Int64) at int.jl:286",
          "convert(::Type{Uint128},x::Uint64) at int.jl:288",
          "convert(::Type{Uint128},x::Int128) at int.jl:291",
          "convert(::Type{Int8},x::Float32) at int.jl:298",
          "convert(::Type{Int8},x::Float64) at int.jl:299",
          "convert(::Type{Int16},x::Float32) at int.jl:298",
          "convert(::Type{Int16},x::Float64) at int.jl:299",
          "convert(::Type{Int32},x::Float32) at int.jl:298",
          "convert(::Type{Int32},x::Float64) at int.jl:299",
          "convert(::Type{Int64},x::Float32) at int.jl:298",
          "convert(::Type{Int64},x::Float64) at int.jl:299",
          "convert(::Type{Uint8},x::Float32) at int.jl:305",
          "convert(::Type{Uint8},x::Float64) at int.jl:306",
          "convert(::Type{Uint16},x::Float32) at int.jl:305",
          "convert(::Type{Uint16},x::Float64) at int.jl:306",
          "convert(::Type{Uint32},x::Float32) at int.jl:305",
          "convert(::Type{Uint32},x::Float64) at int.jl:306",
          "convert(::Type{Uint64},x::Float32) at int.jl:305",
          "convert(::Type{Uint64},x::Float64) at int.jl:306",
          "convert(::Type{Int128},x::Float32) at int.jl:317",
          "convert(::Type{Int128},x::FloatingPoint) at int.jl:311",
          "convert(::Type{Uint128},x::Float32) at int.jl:326",
          "convert(::Type{Uint128},x::FloatingPoint) at int.jl:320",
          "convert(::Type{Char},x::Float32) at int.jl:328",
          "convert(::Type{Char},x::Float64) at int.jl:329",
          "convert(::Type{Signed},x::Uint8) at int.jl:331",
          "convert(::Type{Signed},x::Uint16) at int.jl:332",
          "convert(::Type{Signed},x::Uint32) at int.jl:333",
          "convert(::Type{Signed},x::Uint64) at int.jl:334",
          "convert(::Type{Signed},x::Uint128) at int.jl:335",
          "convert(::Type{Signed},x::Float32) at int.jl:336",
          "convert(::Type{Signed},x::Float64) at int.jl:337",
          "convert(::Type{Signed},x::Char) at int.jl:338",
          "convert(::Type{Unsigned},x::Int8) at int.jl:340",
          "convert(::Type{Unsigned},x::Int16) at int.jl:341",
          "convert(::Type{Unsigned},x::Int32) at int.jl:342",
          "convert(::Type{Unsigned},x::Int64) at int.jl:343",
          "convert(::Type{Unsigned},x::Int128) at int.jl:344",
          "convert(::Type{Unsigned},x::Float32) at int.jl:345",
          "convert(::Type{Unsigned},x::Float64) at int.jl:346",
          "convert(::Type{Unsigned},x::Char) at int.jl:347",
          "convert(::Type{Integer},x::Float32) at int.jl:349",
          "convert(::Type{Integer},x::Float64) at int.jl:350",
          "convert(::Type{Uint64},x::Ptr{T}) at pointer.jl:6",
          "convert{T<:Integer}(::Type{T<:Integer},x::Ptr{T}) at pointer.jl:7",
          "convert{T}(::Type{Ptr{T}},x::Integer) at pointer.jl:10",
          "convert{T}(::Type{Ptr{T}},p::Ptr{T}) at pointer.jl:13",
          "convert{T}(::Type{Ptr{T}},p::Ptr{T}) at pointer.jl:14",
          "convert(::Type{Ptr{Uint8}},x::Symbol) at pointer.jl:17",
          "convert(::Type{Ptr{Int8}},x::Symbol) at pointer.jl:18",
          "convert(::Type{Ptr{Uint8}},s::Union(UTF8String,ASCIIString)) at pointer.jl:19",
          "convert(::Type{Ptr{Int8}},s::Union(UTF8String,ASCIIString)) at pointer.jl:20",
          "convert(::Type{Ptr{None}},a::Array{T,N}) at pointer.jl:23",
          "convert{T}(::Type{Ptr{T}},a::Array{T,N}) at pointer.jl:22",
          "convert(::Type{Float32},x::Int128) at float.jl:3",
          "convert(::Type{Float32},x::Uint128) at float.jl:4",
          "convert(::Type{Float64},x::Int128) at float.jl:8",
          "convert(::Type{Float64},x::Uint128) at float.jl:9",
          "convert(::Type{Float16},x::Union(Signed,Unsigned)) at float.jl:13",
          "convert(::Type{Float32},x::Int8) at float.jl:21",
          "convert(::Type{Float32},x::Int16) at float.jl:21",
          "convert(::Type{Float32},x::Int32) at float.jl:21",
          "convert(::Type{Float32},x::Int64) at float.jl:21",
          "convert(::Type{Float32},x::Bool) at float.jl:27",
          "convert(::Type{Float32},x::Char) at float.jl:27",
          "convert(::Type{Float32},x::Uint8) at float.jl:27",
          "convert(::Type{Float32},x::Uint16) at float.jl:27",
          "convert(::Type{Float32},x::Uint32) at float.jl:27",
          "convert(::Type{Float32},x::Uint64) at float.jl:27",
          "convert(::Type{Float64},x::Int8) at float.jl:21",
          "convert(::Type{Float64},x::Int16) at float.jl:21",
          "convert(::Type{Float64},x::Int32) at float.jl:21",
          "convert(::Type{Float64},x::Int64) at float.jl:21",
          "convert(::Type{Float64},x::Bool) at float.jl:27",
          "convert(::Type{Float64},x::Char) at float.jl:27",
          "convert(::Type{Float64},x::Uint8) at float.jl:27",
          "convert(::Type{Float64},x::Uint16) at float.jl:27",
          "convert(::Type{Float64},x::Uint32) at float.jl:27",
          "convert(::Type{Float64},x::Uint64) at float.jl:27",
          "convert(::Type{Float16},x::Float64) at float.jl:33",
          "convert(::Type{Float32},x::Float64) at float.jl:34",
          "convert(::Type{Float64},x::Float16) at float.jl:37",
          "convert(::Type{Float64},x::Float32) at float.jl:38",
          "convert(::Type{FloatingPoint},x::Bool) at float.jl:40",
          "convert(::Type{FloatingPoint},x::Char) at float.jl:41",
          "convert(::Type{FloatingPoint},x::Int8) at float.jl:42",
          "convert(::Type{FloatingPoint},x::Int16) at float.jl:43",
          "convert(::Type{FloatingPoint},x::Int32) at float.jl:44",
          "convert(::Type{FloatingPoint},x::Int64) at float.jl:45",
          "convert(::Type{FloatingPoint},x::Int128) at float.jl:46",
          "convert(::Type{FloatingPoint},x::Uint8) at float.jl:47",
          "convert(::Type{FloatingPoint},x::Uint16) at float.jl:48",
          "convert(::Type{FloatingPoint},x::Uint32) at float.jl:49",
          "convert(::Type{FloatingPoint},x::Uint64) at float.jl:50",
          "convert(::Type{FloatingPoint},x::Uint128) at float.jl:51",
          "convert{T<:Real}(::Type{Complex{T<:Real}},x::MathConst{sym}) at constants.jl:13",
          "convert{T<:Real}(::Type{Complex{T<:Real}},x::Real) at complex.jl:16",
          "convert{T<:Real}(::Type{Complex{T<:Real}},z::Complex{T<:Real}) at complex.jl:17",
          "convert{T<:Real}(::Type{T<:Real},z::Complex{T<:Real}) at complex.jl:18",
          "convert(::Type{Complex{T<:Real}},z::Complex{T<:Real}) at complex.jl:21",
          "convert(::Type{Complex{T<:Real}},x::Real) at complex.jl:22",
          "convert{T<:Integer}(::Type{Rational{T<:Integer}},x::Rational{T<:Integer}) at rational.jl:38",
          "convert{T<:Integer}(::Type{Rational{T<:Integer}},x::Integer) at rational.jl:39",
          "convert(::Type{Rational{T<:Integer}},x::Rational{T<:Integer}) at rational.jl:41",
          "convert(::Type{Rational{T<:Integer}},x::Integer) at rational.jl:42",
          "convert{T<:Integer}(::Type{T<:Integer},x::Rational{T<:Integer}) at rational.jl:45",
          "convert(::Type{FloatingPoint},x::Rational{T<:Integer}) at rational.jl:47",
          "convert{S}(::Type{BigFloat},x::Rational{S}) at mpfr.jl:87",
          "convert{T<:FloatingPoint,S}(::Type{T<:FloatingPoint},x::Rational{S}) at rational.jl:49",
          "convert(::Type{Rational{T<:Integer}},x::Float64) at rational.jl:58",
          "convert(::Type{Rational{T<:Integer}},x::Float32) at rational.jl:59",
          "convert(::Type{Rational{T<:Integer}},x::BigFloat) at mpfr.jl:86",
          "convert{T<:Integer}(::Type{Rational{T<:Integer}},x::FloatingPoint) at rational.jl:54",
          "convert{T,N}(::Type{AbstractArray{T,N}},B::BitArray{N}) at bitarray.jl:323",
          "convert{T}(::Type{AbstractArray{T,2}},A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:165",
          "convert{T}(::Type{AbstractArray{T,2}},S::SymTridiagonal{T}) at linalg/tridiag.jl:23",
          "convert{T}(::Type{AbstractArray{T,2}},M::Tridiagonal{T}) at linalg/tridiag.jl:226",
          "convert{T}(::Type{AbstractArray{T,2}},Q::QRPackedQ{T}) at linalg/factorization.jl:229",
          "convert{S}(::Type{AbstractArray{S,2}},Q::QRCompactWYQ{S}) at linalg/factorization.jl:231",
          "convert{T}(::Type{AbstractArray{T,2}},A::Triangular{T<:Number}) at linalg/triangular.jl:89",
          "convert{T}(::Type{AbstractArray{T,2}},A::Symmetric{T}) at linalg/symmetric.jl:21",
          "convert{T}(::Type{AbstractArray{T,2}},A::Hermitian{T}) at linalg/symmetric.jl:23",
          "convert{T}(::Type{AbstractArray{T,2}},D::Diagonal{T}) at linalg/diagonal.jl:10",
          "convert{T,N}(::Type{AbstractArray{T,N}},A::AbstractArray{T,N}) at abstractarray.jl:302",
          "convert{T,S,N}(::Type{AbstractArray{T,N}},A::AbstractArray{S,N}) at abstractarray.jl:303",
          "convert{S,T,N}(::Type{Array{S,N}},s::SubArray{T,N,D<:DArray{T,N,A},I<:(Union(Range{Int64},Int64)...,)}) at darray.jl:185",
          "convert{T,S,N}(::Type{Array{T,N}},A::SubArray{S,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)}) at subarray.jl:402",
          "convert{T,n}(::Type{Array{T,n}},x::Array{T,n}) at array.jl:218",
          "convert{T,n,S}(::Type{Array{T,n}},x::Array{S,n}) at array.jl:220",
          "convert{T,n}(::Type{Array{T,N}},x::Array{T,n}) at array.jl:217",
          "convert{T,n,S}(::Type{Array{T,N}},x::Array{S,n}) at array.jl:219",
          "convert{T,N}(::Type{Array{T,N}},B::BitArray{N}) at bitarray.jl:284",
          "convert{T,N}(::Type{Array{T,N}},B::BitArray{N}) at bitarray.jl:282",
          "convert{S,T,N}(::Type{Array{S,N}},d::DArray{T,N,A}) at darray.jl:175",
          "convert(::Type{Array{T,N}},S::SharedArray{T,N}) at sharedarray.jl:206",
          "convert(::Type{Array{T,2}},S::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:166",
          "convert{T}(::Type{Array{T,2}},M::SymTridiagonal{T}) at linalg/tridiag.jl:24",
          "convert{T}(::Type{Array{T,2}},M::Tridiagonal{T}) at linalg/tridiag.jl:165",
          "convert(::Type{Array{T,2}},A::Triangular{T<:Number}) at linalg/triangular.jl:86",
          "convert{T}(::Type{Array{T,2}},W::Woodbury{T}) at linalg/woodbury.jl:57",
          "convert{T}(::Type{Array{T,2}},A::Bidiagonal{T}) at linalg/bidiag.jl:31",
          "convert(::Type{Array{T,2}},D::Diagonal{T}) at linalg/special.jl:8",
          "convert{T,N}(::Type{Array{T,N}},A::AbstractArray{T,N}) at abstractarray.jl:305",
          "convert{T}(::Type{Ptr{T}},x::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)}) at subarray.jl:400",
          "convert{N}(::Type{BitArray{N}},B::BitArray{N}) at bitarray.jl:322",
          "convert{T,N}(::Type{BitArray{N}},A::AbstractArray{T,N}) at bitarray.jl:294",
          "convert{T,N}(::Type{BitArray{N}},A::AbstractArray{T,N}) at bitarray.jl:292",
          "convert{K,V}(::Type{Dict{K,V}},d::Dict{K,V}) at dict.jl:255",
          "convert{K,V}(::Type{Dict{K,V}},d::Dict{K,V}) at dict.jl:244",
          "convert(::Type{ASCIIString},s::ASCIIString) at ascii.jl:99",
          "convert(::Type{ASCIIString},s::UTF8String) at ascii.jl:100",
          "convert(::Type{ASCIIString},a::Array{Uint8,1}) at ascii.jl:101",
          "convert(::Type{ASCIIString},a::Array{Uint8,1},invalids_as::ASCIIString) at ascii.jl:103",
          "convert(::Type{ASCIIString},s::String) at ascii.jl:120",
          "convert(::Type{UTF8String},s::UTF8String) at utf8.jl:162",
          "convert(::Type{UTF8String},s::ASCIIString) at utf8.jl:163",
          "convert(::Type{UTF8String},a::Array{Uint8,1}) at utf8.jl:164",
          "convert(::Type{UTF8String},a::Array{Uint8,1},invalids_as::String) at utf8.jl:166",
          "convert(::Type{UTF8String},s::UTF16String) at utf16.jl:43",
          "convert(::Type{UTF8String},s::String) at utf8.jl:186",
          "convert(::Type{UTF16String},s::UTF16String) at utf16.jl:41",
          "convert(::Type{UTF16String},s::String) at utf16.jl:42",
          "convert(::Type{Array{Uint16,1}},s::UTF16String) at utf16.jl:45",
          "convert(::Type{Array{Uint16,N}},s::UTF16String) at utf16.jl:46",
          "convert{T<:Union(Uint16,Int16)}(::Type{Ptr{T<:Union(Uint16,Int16)}},s::UTF16String) at utf16.jl:49",
          "convert(::Type{UTF16String},data::Array{Uint16,N}) at utf16.jl:70",
          "convert(T::Type{UTF16String},bytes::Array{Uint8,N}) at utf16.jl:75",
          "convert(::Type{Array{Uint8,1}},s::String) at string.jl:47",
          "convert(::Type{Array{Uint8,N}},s::String) at string.jl:48",
          "convert(::Type{Union(UTF8String,ASCIIString)},s::String) at string.jl:49",
          "convert(::Type{Array{Char,1}},s::UTF32String) at string.jl:582",
          "convert(::Type{Array{Char,1}},s::String) at string.jl:50",
          "convert(::Type{Symbol},s::String) at string.jl:51",
          "convert(::Type{UTF32String},s::UTF32String) at string.jl:579",
          "convert(::Type{UTF32String},s::String) at string.jl:580",
          "convert{T<:String}(::Type{T<:String},v::Array{Char,1}) at string.jl:581",
          "convert(::Type{Array{Char,N}},s::UTF32String) at string.jl:583",
          "convert{T<:Union(Char,Uint32,Int32)}(::Type{Ptr{T<:Union(Char,Uint32,Int32)}},s::UTF32String) at string.jl:588",
          "convert{T<:String}(::Type{SubString{T<:String}},s::T<:String) at string.jl:650",
          "convert{P<:Union(Uint8,Int8),T<:Union(UTF8String,ASCIIString)}(::Type{Ptr{P<:Union(Uint8,Int8)}},s::SubString{T<:Union(UTF8String,ASCIIString)}) at string.jl:667",
          "convert(::Type{RepString},s::String) at string.jl:712",
          "convert(T::Type{Ptr{None}},s::IOStream) at io.jl:262",
          "convert(::Type{CFILE},s::IO) at io.jl:326",
          "convert(::Type{Int32},fd::RawFD) at stream.jl:27",
          "convert(T::Type{Ptr{None}},s::AsyncStream) at stream.jl:216",
          "convert(::Type{Float32},val::Float16) at float16.jl:2",
          "convert(::Type{Float16},val::Float32) at float16.jl:81",
          "convert(::Type{Integer},x::Float16) at float16.jl:99",
          "convert(::Type{BigInt},x::Integer) at gmp.jl:113",
          "convert(::Type{BigInt},x::FloatingPoint) at gmp.jl:114",
          "convert(::Type{Int64},n::BigInt) at gmp.jl:126",
          "convert(::Type{Int32},n::BigInt) at gmp.jl:121",
          "convert(::Type{Int16},n::BigInt) at gmp.jl:122",
          "convert(::Type{Int8},n::BigInt) at gmp.jl:123",
          "convert(::Type{Uint64},n::BigInt) at gmp.jl:144",
          "convert(::Type{Uint32},x::BigInt) at gmp.jl:139",
          "convert(::Type{Uint16},x::BigInt) at gmp.jl:140",
          "convert(::Type{Uint8},x::BigInt) at gmp.jl:141",
          "convert(::Type{Uint128},x::BigInt) at gmp.jl:162",
          "convert(::Type{Int128},x::BigInt) at gmp.jl:166",
          "convert(::Type{Float64},n::BigInt) at gmp.jl:170",
          "convert(::Type{Float32},n::BigInt) at gmp.jl:172",
          "convert(::Type{Float16},n::BigInt) at gmp.jl:173",
          "convert(::Type{BigFloat},::MathConst{:π}) at constants.jl:31",
          "convert(::Type{BigFloat},::MathConst{:e}) at constants.jl:38",
          "convert(::Type{BigFloat},::MathConst{:γ}) at constants.jl:31",
          "convert(::Type{BigFloat},::MathConst{:catalan}) at constants.jl:31",
          "convert(::Type{BigFloat},::MathConst{:φ}) at constants.jl:38",
          "convert(::Type{BigFloat},x::Real) at mpfr.jl:88",
          "convert(::Type{FloatingPoint},x::BigInt) at mpfr.jl:89",
          "convert(::Type{Int8},x::BigFloat) at mpfr.jl:94",
          "convert(::Type{Int16},x::BigFloat) at mpfr.jl:94",
          "convert(::Type{Int32},x::BigFloat) at mpfr.jl:94",
          "convert(::Type{Int64},x::BigFloat) at mpfr.jl:94",
          "convert(::Type{Uint8},x::BigFloat) at mpfr.jl:104",
          "convert(::Type{Uint16},x::BigFloat) at mpfr.jl:104",
          "convert(::Type{Uint32},x::BigFloat) at mpfr.jl:104",
          "convert(::Type{Uint64},x::BigFloat) at mpfr.jl:104",
          "convert(::Type{Float64},x::BigFloat) at mpfr.jl:115",
          "convert(::Type{Float32},x::BigFloat) at mpfr.jl:117",
          "convert(::Type{Integer},x::BigFloat) at mpfr.jl:120",
          "convert(::Type{Array{Uint8,1}},u::UUID) at random.jl:268",
          "convert{T}(::Type{Ptr{T}},S::SharedArray{T,N}) at sharedarray.jl:138",
          "convert{TS,TA,N}(::Type{SharedArray{TS,N}},A::Array{TA,N}) at sharedarray.jl:142",
          "convert{T}(::Type{SharedArray{T,N}},A::Array{T,N}) at sharedarray.jl:141",
          "convert(::Type{SharedArray{T,N}},A::Array{T,N}) at sharedarray.jl:140",
          "convert(::Type{VersionNumber},v::Integer) at version.jl:59",
          "convert(::Type{VersionNumber},v::(Any...,)) at version.jl:60",
          "convert(::Type{VersionNumber},v::String) at version.jl:83",
          "convert{Tv,TvS,TiS}(::Type{SparseMatrixCSC{Tv,Ti<:Integer}},S::SparseMatrixCSC{TvS,TiS}) at sparse/sparsematrix.jl:147",
          "convert{Tv,Ti,TvS,TiS}(::Type{SparseMatrixCSC{Tv,Ti}},S::SparseMatrixCSC{TvS,TiS}) at sparse/sparsematrix.jl:136",
          "convert{Tv,Ti}(::Type{SparseMatrixCSC{Tv,Ti}},M::Array{T,2}) at sparse/sparsematrix.jl:158",
          "convert{T}(::Type{SymTridiagonal{T}},M::SymTridiagonal{T}) at linalg/tridiag.jl:230",
          "convert{T}(::Type{Tridiagonal{T}},M::SymTridiagonal{T}) at linalg/tridiag.jl:227",
          "convert(::Type{Tridiagonal{T}},A::SymTridiagonal{T}) at linalg/tridiag.jl:219",
          "convert{T}(::Type{Tridiagonal{T}},M::Tridiagonal{T}) at linalg/tridiag.jl:225",
          "convert{T}(::Type{SymTridiagonal{T}},M::Tridiagonal{T}) at linalg/tridiag.jl:228",
          "convert{T}(::Type{Cholesky{T}},C::Cholesky{T}) at linalg/factorization.jl:46",
          "convert{T}(::Type{Factorization{T}},C::Cholesky{T}) at linalg/factorization.jl:47",
          "convert{T}(::Type{CholeskyPivoted{T}},C::CholeskyPivoted{T}) at linalg/factorization.jl:48",
          "convert{T}(::Type{Factorization{T}},C::CholeskyPivoted{T}) at linalg/factorization.jl:49",
          "convert{T}(::Type{QR{T}},A::QR{T}) at linalg/factorization.jl:186",
          "convert{T}(::Type{Factorization{T}},A::QR{T}) at linalg/factorization.jl:187",
          "convert{T}(::Type{QRCompactWY{T}},A::QRCompactWY{S}) at linalg/factorization.jl:188",
          "convert{T}(::Type{Factorization{T}},A::QRCompactWY{S}) at linalg/factorization.jl:189",
          "convert{T}(::Type{QRPivoted{T}},A::QRPivoted{T}) at linalg/factorization.jl:190",
          "convert{T}(::Type{Factorization{T}},A::QRPivoted{T}) at linalg/factorization.jl:191",
          "convert{T}(::Type{QRPackedQ{T}},Q::QRPackedQ{T}) at linalg/factorization.jl:228",
          "convert{S}(::Type{QRCompactWYQ{S}},Q::QRCompactWYQ{S}) at linalg/factorization.jl:230",
          "convert{T}(::Type{Factorization{T}},F::LU{T,S<:AbstractArray{T,2}}) at linalg/lu.jl:80",
          "convert{T}(::Type{Factorization{T}},B::BunchKaufman{T}) at linalg/bunchkaufman.jl:25",
          "convert{T,S,U}(::Type{Factorization{T}},F::LDLt{S,U}) at linalg/ldlt.jl:13",
          "convert{T}(::Type{Factorization{T}},F::Factorization{T}) at linalg/factorization.jl:792",
          "convert{T}(::Type{LU{T,S<:AbstractArray{T,2}}},F::LU{T,S<:AbstractArray{T,2}}) at linalg/lu.jl:76",
          "convert{T,S}(::Type{LU{T,S}},F::LU{T,S<:AbstractArray{T,2}}) at linalg/lu.jl:79",
          "convert{T}(::Type{BunchKaufman{T}},B::BunchKaufman{T}) at linalg/bunchkaufman.jl:24",
          "convert{T}(::Type{Triangular{T}},A::Triangular{T}) at linalg/triangular.jl:87",
          "convert{T}(::Type{Triangular{T}},A::Triangular{T<:Number}) at linalg/triangular.jl:88",
          "convert{T}(::Type{Symmetric{T}},A::Symmetric{T}) at linalg/symmetric.jl:20",
          "convert{T}(::Type{Hermitian{T}},A::Hermitian{T}) at linalg/symmetric.jl:22",
          "convert{T}(::Type{Diagonal{T}},D::Diagonal{T}) at linalg/diagonal.jl:8",
          "convert{T}(::Type{Diagonal{T}},D::Diagonal{T}) at linalg/diagonal.jl:9",
          "convert{T}(::Type{Tridiagonal{T}},A::Bidiagonal{T}) at linalg/bidiag.jl:37",
          "convert{T}(::Type{Bidiagonal{T}},A::Diagonal{T}) at linalg/special.jl:4",
          "convert{T}(::Type{SymTridiagonal{T}},A::Diagonal{T}) at linalg/special.jl:5",
          "convert{T}(::Type{Tridiagonal{T}},A::Diagonal{T}) at linalg/special.jl:6",
          "convert(::Type{Triangular{T<:Number}},A::Union(Tridiagonal{T},Bidiagonal{T},SymTridiagonal{T},Diagonal{T})) at linalg/special.jl:7",
          "convert(::Type{Diagonal{T}},A::Union(Bidiagonal{T},SymTridiagonal{T})) at linalg/special.jl:11",
          "convert(::Type{SymTridiagonal{T}},A::Bidiagonal{T}) at linalg/special.jl:16",
          "convert{T}(::Type{Tridiagonal{T}},A::Bidiagonal{T}) at linalg/special.jl:20",
          "convert(::Type{Bidiagonal{T}},A::SymTridiagonal{T}) at linalg/special.jl:23",
          "convert(::Type{Diagonal{T}},A::Tridiagonal{T}) at linalg/special.jl:28",
          "convert(::Type{Bidiagonal{T}},A::Tridiagonal{T}) at linalg/special.jl:33",
          "convert(::Type{SymTridiagonal{T}},A::Tridiagonal{T}) at linalg/special.jl:40",
          "convert(::Type{Diagonal{T}},A::Triangular{T<:Number}) at linalg/special.jl:45",
          "convert(::Type{Bidiagonal{T}},A::Triangular{T<:Number}) at linalg/special.jl:50",
          "convert(::Type{SymTridiagonal{T}},A::Triangular{T<:Number}) at linalg/special.jl:60",
          "convert(::Type{Tridiagonal{T}},A::Triangular{T<:Number}) at linalg/special.jl:63",
          "convert{T,S,U<:AbstractArray{T,2}}(::Type{LDLt{T,S<:AbstractArray{T,2}}},F::LDLt{S,U<:AbstractArray{T,2}}) at linalg/ldlt.jl:11",
          "convert{T,S}(::Type{LDLt{T,S}},F::LDLt{T,S<:AbstractArray{T,2}}) at linalg/ldlt.jl:8",
          "convert(::Type{FloatingPoint},x::MathConst{sym}) at constants.jl:11",
          "convert(::Type{Float16},x::MathConst{sym}) at constants.jl:12",
          "convert{T<:Integer}(::Type{Rational{T<:Integer}},x::MathConst{sym}) at constants.jl:14",
          "convert(::Type{Float64},::MathConst{:π}) at constants.jl:43",
          "convert(::Type{Float32},::MathConst{:π}) at constants.jl:44",
          "convert(::Type{Float64},::MathConst{:e}) at constants.jl:43",
          "convert(::Type{Float32},::MathConst{:e}) at constants.jl:44",
          "convert(::Type{Float64},::MathConst{:γ}) at constants.jl:43",
          "convert(::Type{Float32},::MathConst{:γ}) at constants.jl:44",
          "convert(::Type{Float64},::MathConst{:catalan}) at constants.jl:43",
          "convert(::Type{Float32},::MathConst{:catalan}) at constants.jl:44",
          "convert(::Type{Float64},::MathConst{:φ}) at constants.jl:43",
          "convert(::Type{Float32},::MathConst{:φ}) at constants.jl:44",
          "convert{T}(p::Type{Ptr{T}},a::Array{T,N}) at deprecated.jl:26",
          "convert(T,x) at base.jl:13"
        ]
      },
      {
        "name": "copy",
        "summary": "Function",
        "help": "Base.copy(x)\n\n   Create a shallow copy of \"x\": the outer structure is copied, but\n   not all internal values. For example, copying an array produces a\n   new array with identically-same elements as the original.\n",
        "methods": 
        [
          "copy(r::Range{T}) at range.jl:210",
          "copy(e::Expr) at expr.jl:30",
          "copy(s::SymbolNode) at expr.jl:34",
          "copy(n::GetfieldNode) at expr.jl:35",
          "copy(x::Union(DataType,(Any...,),LambdaStaticData,Symbol,String,Function,QuoteNode,Number,UnionType,TopNode)) at operators.jl:169",
          "copy(d::Union(DArray{T,N,A},SubArray{T,N,D<:DArray{T,N,A},I<:(Union(Range{Int64},Int64)...,)})) at darray.jl:248",
          "copy(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)}) at subarray.jl:188",
          "copy(S::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:127",
          "copy(M::SymTridiagonal{T}) at linalg/tridiag.jl:32",
          "copy(M::Tridiagonal{T}) at linalg/tridiag.jl:188",
          "copy(A::Symmetric{T}) at linalg/symmetric.jl:24",
          "copy(A::Hermitian{T}) at linalg/symmetric.jl:25",
          "copy(W::Woodbury{T}) at linalg/woodbury.jl:66",
          "iround(M::Bidiagonal{T}) at linalg/bidiag.jl:67",
          "copy(A::SymmetricRFP{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/rectfullpacked.jl:33",
          "copy(a::AbstractArray{None,N}) at abstractarray.jl:203",
          "copy(a::AbstractArray{T,N}) at abstractarray.jl:202",
          "copy(s::IntSet) at intset.jl:13",
          "copy(o::ObjectIdDict) at dict.jl:204",
          "copy(a::Associative{K,V}) at dict.jl:68",
          "copy(s::Set{T}) at set.jl:27",
          "copy(b::IOBuffer) at iobuffer.jl:18",
          "copy(r::Regex) at regex.jl:53",
          "copy(::DevNullStream) at process.jl:103",
          "copy(J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:15",
          "copy{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(B::CholmodDense{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/cholmod.jl:385",
          "copy{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:747",
          "copy{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:752",
          "copy{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(T::CholmodTriplet{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:757",
          "copy{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:747",
          "copy{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:752",
          "copy{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(T::CholmodTriplet{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:757",
          "copy{T,V<:Number}(ct::Accumulator{T,V<:Number}) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:23",
          "copy{K,C}(cc::ClassifiedCollections{K,C}) at /home/samuel/.julia/v0.3/DataStructures/src/classifiedcollections.jl:23",
          "copy(s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:36",
          "copy(l::Nil{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:94",
          "copy(l::Cons{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:97"
        ]
      },
      {
        "name": "copy!",
        "summary": "Function",
        "help": "Base.copy!(dest, src)\n\n   Copy all elements from collection \"src\" to array \"dest\".\n   Returns \"dest\".\n\nBase.copy!(dest, do, src, so, N)\n\n   Copy \"N\" elements from collection \"src\" starting at offset\n   \"so\", to array \"dest\" starting at offset \"do\". Returns\n   \"dest\".\n",
        "methods": 
        [
          "copy!(dest::AbstractArray{T,N},doffs::Integer,src::Integer) at abstractarray.jl:175",
          "copy!{T}(dest::Array{T,N},dsto::Integer,src::Array{T,N},so::Integer,N::Integer) at array.jl:51",
          "copy!(dest::BitArray{N},pos_d::Integer,src::BitArray{N},pos_s::Integer,numbits::Integer) at bitarray.jl:262",
          "copy!(dest::AbstractArray{T,N},doffs::Integer,src::AbstractArray{T,N},soffs::Integer) at abstractarray.jl:196",
          "copy!(dest::AbstractArray{T,N},doffs::Integer,src::AbstractArray{T,N},soffs::Integer,n::Integer) at abstractarray.jl:196",
          "copy!(dest::AbstractArray{T,N},doffs::Integer,src) at abstractarray.jl:158",
          "copy!(dest::AbstractArray{T,N},doffs::Integer,src,soffs::Integer) at abstractarray.jl:158",
          "copy!(dest::AbstractArray{T,N},doffs::Integer,src,soffs::Integer,n::Integer) at abstractarray.jl:181",
          "copy!{R,S}(B::AbstractArray{R,2},ir_dest::Range{Int64},jr_dest::Range{Int64},A::AbstractArray{S,2},ir_src::Range{Int64},jr_src::Range{Int64}) at abstractarray.jl:206",
          "copy!{T}(dest::Array{T,N},src::Array{T,N}) at array.jl:57",
          "copy!(dest::BitArray{N},src::BitArray{N}) at bitarray.jl:241",
          "copy!(S::SharedArray{T,N},A::Array{T,N}) at sharedarray.jl:291",
          "copy!(S::SharedArray{T,N},R::SharedArray{T,N}) at sharedarray.jl:294",
          "copy!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Integer}(dest::Array{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N},rdest::Union(UnitRange{Ti<:Integer},Range{Ti<:Integer}),src::Array{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N},rsrc::Union(UnitRange{Ti<:Integer},Range{Ti<:Integer})) at linalg/blas.jl:850",
          "copy!(dest::Tridiagonal{T},src::Tridiagonal{T}) at linalg/tridiag.jl:183",
          "copy!(D1::Diagonal{T},D2::Diagonal{T}) at linalg/diagonal.jl:17",
          "copy!{T}(dest::AbstractArray{T,1},src::AbstractArray{T,1}) at multidimensional.jl:148",
          "copy!{R,S}(B::AbstractArray{R,2},ir_dest::UnitRange{Int64},jr_dest::UnitRange{Int64},tM::Char,M::AbstractArray{S,2},ir_src::UnitRange{Int64},jr_src::UnitRange{Int64}) at linalg/matmul.jl:296",
          "copy!{T}(dest::AbstractArray{T,2},src::AbstractArray{T,2}) at multidimensional.jl:148",
          "copy!{T}(dest::AbstractArray{T,3},src::AbstractArray{T,3}) at multidimensional.jl:148",
          "copy!{T}(dest::AbstractArray{T,4},src::AbstractArray{T,4}) at multidimensional.jl:148",
          "copy!{T,N}(dest::AbstractArray{T,N},src::AbstractArray{T,N}) at cartesian.jl:100",
          "copy!(dest::AbstractArray{T,N},src) at abstractarray.jl:147",
          "copy!(to::IntSet,from::IntSet) at intset.jl:116",
          "copy!(dest::AbstractArray{T,N},src,doffs::Integer) at deprecated.jl:26"
        ]
      },
      {
        "name": "copysign",
        "summary": "Function",
        "help": "Base.copysign(x, y)\n\n   Return \"x\" such that it has the same sign as \"y\"\n",
        "methods": 
        [
          "copysign(x::Signed,y::Signed) at int.jl:69",
          "copysign(x::Signed,y::Float32) at int.jl:70",
          "copysign(x::Signed,y::Float64) at int.jl:71",
          "copysign(x::Signed,y::Real) at int.jl:72",
          "copysign(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:102",
          "copysign(x::Rational{T<:Integer},y::Real) at rational.jl:101",
          "copysign(x::Float64,y::Float64) at floatfuncs.jl:3",
          "copysign(x::Float32,y::Float32) at floatfuncs.jl:4",
          "copysign(x::Float32,y::Real) at floatfuncs.jl:5",
          "copysign(x::Float64,y::Real) at floatfuncs.jl:6",
          "copysign(x::BigFloat,y::BigFloat) at mpfr.jl:619",
          "copysign(x::Real,y::Real) at number.jl:26",
          "copysign{T1<:Real,T2<:Real}(::T1<:Real,::AbstractArray{T2<:Real,N}) at operators.jl:365",
          "copysign{T1<:Real,T2<:Real}(::AbstractArray{T1<:Real,N},::T2<:Real) at operators.jl:367",
          "copysign{T1<:Real,T2<:Real}(::AbstractArray{T1<:Real,N},::AbstractArray{T2<:Real,N}) at operators.jl:371"
        ]
      },
      {
        "name": "cor",
        "summary": "Function",
        "help": "Base.cor(v1[, v2][, vardim=1, mean=nothing])\n\n   Compute the Pearson correlation between the vector(s) in \"v1\" and\n   \"v2\".\n\n   Users can use the keyword argument \"vardim\" to specify the\n   variable dimension, and \"mean\" to supply pre-computed mean\n   values.\n",
        "methods": 
        [
          "cor(x::AbstractArray{T,1}) at statistics.jl:385",
          "cor(x::AbstractArray{T,2}) at statistics.jl:392",
          "cor(x::AbstractArray{T,1},y::AbstractArray{T,1}) at statistics.jl:399",
          "cor(x::Union(AbstractArray{T,2},AbstractArray{T,1}),y::Union(AbstractArray{T,2},AbstractArray{T,1})) at statistics.jl:406"
        ]
      },
      {
        "name": "cos",
        "summary": "Function",
        "help": "Base.cos(x)\n\n   Compute cosine of \"x\", where \"x\" is in radians\n",
        "methods": 
        [
          "cos(a::Complex{Float16}) at float16.jl:134",
          "cos(z::Complex{T<:Real}) at complex.jl:521",
          "cos(x::Float64) at math.jl:277",
          "cos(x::Float32) at math.jl:278",
          "cos(a::Float16) at float16.jl:133",
          "cos(x::BigFloat) at mpfr.jl:547",
          "cos(x::Real) at math.jl:279",
          "cos{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "cos{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "cos{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "cos{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "cosc",
        "summary": "Function",
        "help": "Base.cosc(x)\n\n   Compute \\cos(\\pi x) / x - \\sin(\\pi x) / (\\pi x^2) if x \\neq\n   0, and 0 if x = 0. This is the derivative of \"sinc(x)\".\n",
        "methods": 
        [
          "cosc(x::Integer) at math.jl:143",
          "cosc{T<:Integer}(x::Complex{T<:Integer}) at math.jl:144",
          "cosc(x::Number) at math.jl:142",
          "cosc{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "cosc{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "cosc{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "cosc{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "cosd",
        "summary": "Function",
        "help": "Base.cosd(x)\n\n   Compute cosine of \"x\", where \"x\" is in degrees\n",
        "methods": 
        [
          "cosd(x::Real) at math.jl:200",
          "cosd{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "cosd{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "cosd{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "cosd{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "cosd(z) at math.jl:231"
        ]
      },
      {
        "name": "cosh",
        "summary": "Function",
        "help": "Base.cosh(x)\n\n   Compute hyperbolic cosine of \"x\"\n",
        "methods": 
        [
          "cosh(a::Complex{Float16}) at float16.jl:134",
          "cosh(z::Complex{T<:Real}) at complex.jl:592",
          "cosh(x::Float64) at math.jl:253",
          "cosh(x::Float32) at math.jl:254",
          "cosh(a::Float16) at float16.jl:133",
          "cosh(x::BigFloat) at mpfr.jl:397",
          "cosh(x::FloatingPoint) at math.jl:264",
          "cosh(x::Real) at math.jl:255",
          "cosh{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "cosh{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "cosh{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "cosh{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "cospi",
        "summary": "Function",
        "help": "Base.cospi(x)\n\n   Compute \\cos(\\pi x) more accurately than \"cos(pi*x)\",\n   especially for large \"x\".\n",
        "methods": 
        [
          "cospi(x::Integer) at math.jl:105",
          "cospi(x::Real) at math.jl:79",
          "cospi(z::Complex{T<:Real}) at math.jl:119",
          "cospi{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "cospi{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "cospi{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "cospi{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "cot",
        "summary": "Function",
        "help": "Base.cot(x)\n\n   Compute the cotangent of \"x\", where \"x\" is in radians\n",
        "methods": 
        [
          "cot{T<:Number}(z::T<:Number) at math.jl:158",
          "cot{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "cot{T<:Number}(z::AbstractArray{T<:Number,N}) at math.jl:159"
        ]
      },
      {
        "name": "cotd",
        "summary": "Function",
        "help": "Base.cotd(x)\n\n   Compute the cotangent of \"x\", where \"x\" is in degrees\n",
        "methods": 
        [
          "cotd{T<:Number}(z::T<:Number) at math.jl:158",
          "cotd{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "cotd{T<:Number}(z::AbstractArray{T<:Number,N}) at math.jl:159"
        ]
      },
      {
        "name": "coth",
        "summary": "Function",
        "help": "Base.coth(x)\n\n   Compute the hyperbolic cotangent of \"x\"\n",
        "methods": 
        [
          "coth(x::BigFloat) at mpfr.jl:397",
          "coth{T<:Number}(z::T<:Number) at math.jl:158",
          "coth{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "coth{T<:Number}(z::AbstractArray{T<:Number,N}) at math.jl:159"
        ]
      },
      {
        "name": "count",
        "summary": "Function",
        "help": "Base.count(p, itr) -> Integer\n\n   Count the number of elements in \"itr\" for which predicate \"p\"\n   returns true.\n",
        "methods": 
        [
          "count(pred::Function,itr) at reduce.jl:189",
          "count(start::Number,step::Number) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:31",
          "count(start::Number) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:32",
          "count() at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:33"
        ]
      },
      {
        "name": "count_ones",
        "summary": "Function",
        "help": "Base.count_ones(x::Integer) -> Integer\n\n   Number of ones in the binary representation of \"x\".\n\n   **Example**: \"count_ones(7) -> 3\"\n",
        "methods": 
        [
          "count_ones(x::Int8) at int.jl:205",
          "count_ones(x::Uint8) at int.jl:206",
          "count_ones(x::Int16) at int.jl:207",
          "count_ones(x::Uint16) at int.jl:208",
          "count_ones(x::Int32) at int.jl:209",
          "count_ones(x::Uint32) at int.jl:210",
          "count_ones(x::Int64) at int.jl:211",
          "count_ones(x::Uint64) at int.jl:212",
          "count_ones(x::Int128) at int.jl:213",
          "count_ones(x::Uint128) at int.jl:214",
          "count_ones(x::BigInt) at gmp.jl:315"
        ]
      },
      {
        "name": "count_zeros",
        "summary": "Function",
        "help": "Base.count_zeros(x::Integer) -> Integer\n\n   Number of zeros in the binary representation of \"x\".\n\n   **Example**: \"count_zeros(int32(2 ^ 16 - 1)) -> 16\"\n",
        "methods": 
        [
          "count_zeros(x::Integer) at int.jl:238"
        ]
      },
      {
        "name": "countlines",
        "summary": "Function",
        "help": "Base.countlines(io[, eol::Char])\n\n   Read io until the end of the stream/file and count the number of\n   non-empty lines. To specify a file pass the filename as the first\n   argument. EOL markers other than 'n' are supported by passing them\n   as the second argument.\n",
        "methods": 
        [
          "countlines(filename::String,eol::Char) at datafmt.jl:16",
          "countlines(io::IO,eol::Char) at datafmt.jl:21",
          "countlines(nameorfile) at datafmt.jl:14"
        ]
      },
      {
        "name": "countnz",
        "summary": "Function",
        "help": "Base.countnz(A)\n\n   Counts the number of nonzero values in array A (dense or sparse).\n   Note that this is not a constant-time operation. For sparse\n   matrices, one should usually use \"nfilled\" instead.\n",
        "methods": 
        [
          "countnz(B::BitArray{N}) at bitarray.jl:1245",
          "countnz(S::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:19",
          "countnz(a::AbstractArray{T,N}) at reduce.jl:178",
          "countnz(itr) at reduce.jl:168"
        ]
      },
      {
        "name": "cov",
        "summary": "Function",
        "help": "Base.cov(v1[, v2][, vardim=1, corrected=true, mean=nothing])\n\n   Compute the Pearson covariance between the vector(s) in \"v1\" and\n   \"v2\". Here, \"v1\" and \"v2\" can be either vectors or matrices.\n\n   This function accepts three keyword arguments:\n\n   * \"vardim\": the dimension of variables. When \"vardim = 1\",\n     variables are considered in columns while observations in rows;\n     when \"vardim = 2\", variables are in rows while observations in\n     columns. By default, it is set to \"1\".\n\n   * \"corrected\": whether to apply Bessel's correction (divide by\n     \"n-1\" instead of \"n\"). By default, it is set to \"true\".\n\n   * \"mean\": allow users to supply mean values that are known. By\n     default, it is set to \"nothing\", which indicates that the\n     mean(s) are unknown, and the function will compute the mean.\n     Users can use \"mean=0\" to indicate that the input data are\n     centered, and hence there's no need to subtract the mean.\n\n   The size of the result depends on the size of \"v1\" and \"v2\".\n   When both \"v1\" and \"v2\" are vectors, it returns the covariance\n   between them as a scalar. When either one is a matrix, it returns a\n   covariance matrix of size \"(n1, n2)\", where \"n1\" and \"n2\" are\n   the numbers of slices in \"v1\" and \"v2\", which depend on the\n   setting of \"vardim\".\n\n   Note: \"v2\" can be omitted, which indicates \"v2 = v1\".\n",
        "methods": 
        [
          "cov(x::AbstractArray{T,1}) at statistics.jl:251",
          "cov(x::AbstractArray{T,2}) at statistics.jl:258",
          "cov(x::AbstractArray{T,1},y::AbstractArray{T,1}) at statistics.jl:265",
          "cov(x::Union(AbstractArray{T,2},AbstractArray{T,1}),y::Union(AbstractArray{T,2},AbstractArray{T,1})) at statistics.jl:272"
        ]
      },
      {
        "name": "cp",
        "summary": "Function",
        "help": "Base.cp(src::String, dst::String)\n\n   Copy a file from *src* to *dest*.\n",
        "methods": 
        [
          "cp(src::String,dst::String) at file.jl:63"
        ]
      },
      {
        "name": "cross",
        "summary": "Function",
        "help": "Base.cross(x, y)\n\n   Compute the cross product of two 3-vectors.\n",
        "methods": 
        [
          "cross(a::AbstractArray{T,1},b::AbstractArray{T,1}) at linalg/generic.jl:23"
        ]
      },
      {
        "name": "csc",
        "summary": "Function",
        "help": "Base.csc(x)\n\n   Compute the cosecant of \"x\", where \"x\" is in radians\n",
        "methods": 
        [
          "csc(x::BigFloat) at mpfr.jl:547",
          "csc{T<:Number}(z::T<:Number) at math.jl:158",
          "csc{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "csc{T<:Number}(z::AbstractArray{T<:Number,N}) at math.jl:159"
        ]
      },
      {
        "name": "cscd",
        "summary": "Function",
        "help": "Base.cscd(x)\n\n   Compute the cosecant of \"x\", where \"x\" is in degrees\n",
        "methods": 
        [
          "cscd{T<:Number}(z::T<:Number) at math.jl:158",
          "cscd{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "cscd{T<:Number}(z::AbstractArray{T<:Number,N}) at math.jl:159"
        ]
      },
      {
        "name": "csch",
        "summary": "Function",
        "help": "Base.csch(x)\n\n   Compute the hyperbolic cosecant of \"x\"\n",
        "methods": 
        [
          "csch(x::BigFloat) at mpfr.jl:397",
          "csch{T<:Number}(z::T<:Number) at math.jl:158",
          "csch{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "csch{T<:Number}(z::AbstractArray{T<:Number,N}) at math.jl:159"
        ]
      },
      {
        "name": "ctime",
        "summary": "Function",
        "help": "Base.ctime(file)\n\n   Equivalent to stat(file).ctime\n",
        "methods": 
        [
          "ctime(path...) at stat.jl:115"
        ]
      },
      {
        "name": "ctranspose",
        "summary": "Function",
        "help": "Base.ctranspose(A)\n\n   The conjugate transposition operator (\"'\").\n",
        "methods": 
        [
          "ctranspose(r::Range{T}) at range.jl:206",
          "ctranspose(x::Number) at number.jl:30",
          "ctranspose(B::BitArray{N}) at bitarray.jl:1563",
          "ctranspose{T<:Real}(A::Union(DenseArray{T<:Real,1},SubArray{T<:Real,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},SubArray{T<:Real,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Real,2})) at array.jl:1313",
          "ctranspose(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at array.jl:1310",
          "ctranspose{T}(x::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at array.jl:1316",
          "ctranspose{Tv,Ti}(S::SparseMatrixCSC{Tv,Ti}) at sparse/csparse.jl:193",
          "ctranspose(M::SymTridiagonal{T}) at linalg/tridiag.jl:37",
          "ctranspose(M::Tridiagonal{T}) at linalg/tridiag.jl:193",
          "ctranspose(A::Triangular{T<:Number}) at linalg/triangular.jl:99",
          "ctranspose(A::Hermitian{T}) at linalg/symmetric.jl:33",
          "ctranspose(D::Diagonal{T}) at linalg/diagonal.jl:75",
          "ctranspose(M::Bidiagonal{T}) at linalg/bidiag.jl:71",
          "ctranspose(J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:18",
          "ctranspose{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:762",
          "ctranspose{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:762"
        ]
      },
      {
        "name": "cummax",
        "summary": "Function",
        "help": "Base.cummax(A[, dim])\n\n   Cumulative maximum along a dimension.\n",
        "methods": 
        [
          "cummax(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),axis::Integer) at array.jl:1445",
          "cummax(v::AbstractArray{T,1}) at array.jl:1433",
          "cummax(A::AbstractArray{T,N}) at array.jl:1470"
        ]
      },
      {
        "name": "cummin",
        "summary": "Function",
        "help": "Base.cummin(A[, dim])\n\n   Cumulative minimum along a dimension.\n",
        "methods": 
        [
          "cummin(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),axis::Integer) at array.jl:1445",
          "cummin(v::AbstractArray{T,1}) at array.jl:1433",
          "cummin(A::AbstractArray{T,N}) at array.jl:1470"
        ]
      },
      {
        "name": "cumprod",
        "summary": "Function",
        "help": "Base.cumprod(A[, dim])\n\n   Cumulative product along a dimension.\n",
        "methods": 
        [
          "cumprod(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),axis::Integer) at array.jl:1402",
          "cumprod(v::AbstractArray{T,1}) at array.jl:1393",
          "cumprod(A::AbstractArray{T,N}) at array.jl:1428"
        ]
      },
      {
        "name": "cumsum",
        "summary": "Function",
        "help": "Base.cumsum(A[, dim])\n\n   Cumulative sum along a dimension.\n",
        "methods": 
        [
          "cumsum(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),axis::Integer) at array.jl:1402",
          "cumsum(v::AbstractArray{T,1}) at array.jl:1393",
          "cumsum(A::AbstractArray{T,N}) at array.jl:1428"
        ]
      },
      {
        "name": "cumsum_kbn",
        "summary": "Function",
        "help": "Base.cumsum_kbn(A[, dim])\n\n   Cumulative sum along a dimension, using the Kahan-Babuska-Neumaier\n   compensated summation algorithm for additional accuracy.\n",
        "methods": 
        [
          "cumsum_kbn{T<:FloatingPoint}(v::AbstractArray{T<:FloatingPoint,1}) at abstractarray.jl:877",
          "cumsum_kbn{T<:FloatingPoint}(A::AbstractArray{T<:FloatingPoint,N},axis::Integer) at abstractarray.jl:899"
        ]
      },
      {
        "name": "current_module",
        "summary": "Function",
        "help": "Base.current_module() -> Module\n\n   Get the *dynamically* current module, which is the module code is\n   currently being read from. In general, this is not the same as the\n   module containing the call to this function.\n",
        "methods": 
        [
          "current_module() at reflection.jl:4"
        ]
      },
      {
        "name": "current_task",
        "summary": "Function",
        "help": "Base.current_task()\n\n   Get the currently running Task.\n",
        "methods": 
        [
          "current_task() at task.jl:9"
        ]
      },
      {
        "name": "dawson",
        "summary": "Function",
        "help": "Base.dawson(x)\n\n   Compute the Dawson function (scaled imaginary error function) of\n   \"x\", defined by \\frac{\\sqrt{\\pi}}{2} e^{-x^2}\n   \\operatorname{erfi}(x).\n",
        "methods": 
        [
          "dawson(z::Complex{Float64}) at math.jl:1239",
          "dawson(z::Complex{Float32}) at math.jl:1240",
          "dawson(z::Complex{T<:Real}) at math.jl:1241",
          "dawson(x::Float64) at math.jl:1248",
          "dawson(x::Float32) at math.jl:1249",
          "dawson(x::Integer) at math.jl:1250",
          "dawson{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "dawson{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "dawson{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "dct",
        "summary": "Function",
        "help": "Base.dct(A[, dims])\n\n   Performs a multidimensional type-II discrete cosine transform (DCT)\n   of the array \"A\", using the unitary normalization of the DCT. The\n   optional \"dims\" argument specifies an iterable subset of\n   dimensions (e.g. an integer, range, tuple, or array) to transform\n   along.  Most efficient if the size of \"A\" along the transformed\n   dimensions is a product of small primes; see \"nextprod()\".  See\n   also \"plan_dct()\" for even greater efficiency.\n",
        "methods": 
        [
          "dct{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region) at dsp.jl:179",
          "dct{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N})) at dsp.jl:243",
          "dct(x::Number,dims) at dsp.jl:256",
          "dct(x::Number) at dsp.jl:258"
        ]
      },
      {
        "name": "dct!",
        "summary": "Function",
        "help": "Base.dct!(A[, dims])\n\n   Same as \"dct!()\", except that it operates in-place on \"A\",\n   which must be an array of real or complex floating-point values.\n",
        "methods": 
        [
          "dct!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(X::Union(SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N}),region) at dsp.jl:179",
          "dct!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(X::Union(SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N})) at dsp.jl:243"
        ]
      },
      {
        "name": "dec",
        "summary": "Function",
        "help": "Base.dec(n[, pad])\n\n   Convert an integer to a decimal string, optionally specifying a\n   number of digits to pad to.\n",
        "methods": 
        [
          "dec(x::Unsigned,pad::Int64,neg::Bool) at intfuncs.jl:213",
          "dec(x::Unsigned,p::Int64) at intfuncs.jl:259",
          "dec(x::Unsigned) at intfuncs.jl:260",
          "dec(x::Char,p::Int64) at intfuncs.jl:261",
          "dec(x::Char) at intfuncs.jl:262",
          "dec(n::BigInt) at gmp.jl:420",
          "dec(x::Integer,p::Int64) at intfuncs.jl:263",
          "dec(x::Integer) at intfuncs.jl:264"
        ]
      },
      {
        "name": "deconv",
        "summary": "Function",
        "help": "Base.deconv(b, a)\n\n   Construct vector \"c\" such that \"b = conv(a,c) + r\". Equivalent\n   to polynomial division.\n",
        "methods": 
        [
          "deconv{T}(b::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1}),a::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at dsp.jl:74"
        ]
      },
      {
        "name": "deepcopy",
        "summary": "Function",
        "help": "Base.deepcopy(x)\n\n   Create a deep copy of \"x\": everything is copied recursively,\n   resulting in a fully independent object. For example, deep-copying\n   an array produces a new array whose elements are deep-copies of the\n   original elements.\n\n   As a special case, functions can only be actually deep-copied if\n   they are anonymous, otherwise they are just copied. The difference\n   is only relevant in the case of closures, i.e. functions which may\n   contain hidden internal references.\n\n   While it isn't normally necessary, user-defined types can override\n   the default \"deepcopy\" behavior by defining a specialized version\n   of the function \"deepcopy_internal(x::T, dict::ObjectIdDict)\"\n   (which shouldn't otherwise be used), where \"T\" is the type to be\n   specialized for, and \"dict\" keeps track of objects copied so far\n   within the recursion. Within the definition, \"deepcopy_internal\"\n   should be used in place of \"deepcopy\", and the \"dict\" variable\n   should be updated as appropriate before returning.\n",
        "methods": 
        [
          "deepcopy(x) at deepcopy.jl:6"
        ]
      },
      {
        "name": "deg2rad",
        "summary": "Function",
        "help": "Base.deg2rad(x)\n\n   Convert \"x\" from degrees to radians\n",
        "methods": 
        [
          "deg2rad(z::Integer) at math.jl:150",
          "deg2rad(z::BigFloat) at mpfr.jl:373",
          "deg2rad(z::Real) at math.jl:148",
          "deg2rad{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "deg2rad{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "deg2rad{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "degrees2radians",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "degrees2radians(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "del_each!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "del_each!(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "delete!",
        "summary": "Function",
        "help": "Base.delete!(collection, key)\n\n   Delete the mapping for the given key in a collection, and return\n   the colection.\n",
        "methods": 
        [
          "delete!(s::IntSet,n::Integer) at intset.jl:79",
          "delete!(t::ObjectIdDict,key) at dict.jl:184",
          "delete!(h::Dict{K,V},key) at dict.jl:561",
          "delete!{K}(wkh::WeakKeyDict{K,V},key) at dict.jl:643",
          "delete!(s::Set{T},x) at set.jl:21",
          "delete!(::EnvHash,k::String) at env.jl:81",
          "delete!(::EnvHash,k::String,def) at env.jl:88",
          "delete!(a::Array{T,1},x) at deprecated.jl:26",
          "delete!(a::BitArray{1},x) at deprecated.jl:26",
          "delete!(d::Dict{K,V},key,default) at deprecated.jl:26",
          "delete!(h::HashDict{K,V,O<:Union(Nothing,Int64)},key) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:465",
          "delete!(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "delete!(s::OrderedSet{T},x) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:29",
          "delete!(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "delete!(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "delete!(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11"
        ]
      },
      {
        "name": "deleteat!",
        "summary": "Function",
        "help": "Base.deleteat!(collection, index)\n\n   Remove the item at the given index, and return the modified\n   collection. Subsequent items are shifted to fill the resulting gap.\n\nBase.deleteat!(collection, itr)\n\n   Remove the items at the indices given by *itr*, and return the\n   modified collection. Subsequent items are shifted to fill the\n   resulting gap.  *itr* must be sorted and unique.\n",
        "methods": 
        [
          "deleteat!(a::Array{T,1},i::Integer) at array.jl:555",
          "deleteat!{T<:Integer}(a::Array{T,1},r::UnitRange{T<:Integer}) at array.jl:562",
          "deleteat!(a::Array{T,1},inds) at array.jl:572",
          "deleteat!(B::BitArray{1},i::Integer) at bitarray.jl:660",
          "deleteat!(B::BitArray{1},r::UnitRange{Int64}) at bitarray.jl:667",
          "deleteat!(B::BitArray{1},inds) at bitarray.jl:690"
        ]
      },
      {
        "name": "den",
        "summary": "Function",
        "help": "Base.den(x)\n\n   Denominator of the rational representation of \"x\"\n",
        "methods": 
        [
          "den(x::Integer) at rational.jl:95",
          "den(x::Rational{T<:Integer}) at rational.jl:97"
        ]
      },
      {
        "name": "dense",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "dense(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "deserialize",
        "summary": "Function",
        "help": "Base.deserialize(stream)\n\n   Read a value written by \"serialize\".\n",
        "methods": 
        [
          "deserialize{K,V}(s,T::Type{Dict{K,V}}) at dict.jl:277",
          "deserialize(s,t::Type{Regex}) at regex.jl:254",
          "deserialize(s) at serialize.jl:310",
          "deserialize(s,::Type{Symbol}) at serialize.jl:332",
          "deserialize(s,::Type{LongSymbol}) at serialize.jl:333",
          "deserialize(s,::Type{Module}) at serialize.jl:336",
          "deserialize(s,::Type{Function}) at serialize.jl:350",
          "deserialize(s,::Type{LambdaStaticData}) at serialize.jl:375",
          "deserialize(s,::Type{Array{T,N}}) at serialize.jl:398",
          "deserialize(s,::Type{Expr}) at serialize.jl:439",
          "deserialize(s,::Type{LongExpr}) at serialize.jl:440",
          "deserialize(s,::Type{TypeVar}) at serialize.jl:452",
          "deserialize(s,::Type{UnionType}) at serialize.jl:460",
          "deserialize(s,::Type{DataType}) at serialize.jl:466",
          "deserialize{T}(s,::Type{Ptr{T}}) at serialize.jl:482",
          "deserialize(s,::Type{Task}) at serialize.jl:485",
          "deserialize(s,t::Type{RemoteRef}) at multi.jl:564",
          "deserialize(s,::Type{BigInt}) at gmp.jl:184",
          "deserialize(s,::Type{BigFloat}) at mpfr.jl:135",
          "deserialize{T,N}(s,t::Type{SharedArray{T,N}}) at sharedarray.jl:198",
          "deserialize{K,V,O}(s,T::Type{HashDict{K,V,O}}) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:64",
          "deserialize(s,t::DataType) at serialize.jl:495"
        ]
      },
      {
        "name": "det",
        "summary": "Function",
        "help": "Base.det(M)\n\n   Matrix determinant\n",
        "methods": 
        [
          "det(A::Array{T,2}) at linalg/dense.jl:319",
          "det(x::Number) at linalg/dense.jl:322",
          "det(A::SymTridiagonal{T}) at linalg/tridiag.jl:135",
          "det(A::Tridiagonal{T}) at linalg/tridiag.jl:216",
          "det{T}(C::Cholesky{T}) at linalg/factorization.jl:108",
          "det{T}(C::CholeskyPivoted{T}) at linalg/factorization.jl:113",
          "det(A::Eigen{T,V}) at linalg/factorization.jl:588",
          "det{T,S}(A::LU{T,S}) at linalg/lu.jl:119",
          "det(A::Triangular{T<:Number}) at linalg/triangular.jl:170",
          "det(W::Woodbury{T}) at linalg/woodbury.jl:77",
          "det(D::Diagonal{T}) at linalg/diagonal.jl:79",
          "det{Tv<:Float64,Ti<:Int32}(lu::UmfpackLU{Tv<:Float64,Ti<:Int32}) at linalg/umfpack.jl:248",
          "det{Tv<:Complex{Float64},Ti<:Int32}(lu::UmfpackLU{Tv<:Complex{Float64},Ti<:Int32}) at linalg/umfpack.jl:255",
          "det{Tv<:Float64,Ti<:Int64}(lu::UmfpackLU{Tv<:Float64,Ti<:Int64}) at linalg/umfpack.jl:248",
          "det{Tv<:Complex{Float64},Ti<:Int64}(lu::UmfpackLU{Tv<:Complex{Float64},Ti<:Int64}) at linalg/umfpack.jl:255",
          "det(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:1021"
        ]
      },
      {
        "name": "detach",
        "summary": "Function",
        "help": "Base.detach(command)\n\n   Mark a command object so that it will be run in a new process\n   group, allowing it to outlive the julia process, and not have\n   Ctrl-C interrupts passed to it.\n",
        "methods": 
        [
          "detach(cmd::Cmd) at process.jl:141"
        ]
      },
      {
        "name": "dfill",
        "summary": "Function",
        "help": "Base.dfill(x, dims, ...)\n\n   Construct a distributed array filled with value \"x\". Trailing\n   arguments are the same as those accepted by \"DArray()\".\n",
        "methods": 
        [
          "dfill(v,d::Int64...) at darray.jl:157",
          "dfill(v,args...) at darray.jl:156"
        ]
      },
      {
        "name": "diag",
        "summary": "Function",
        "help": "Base.diag(M[, k])\n\n   The \"k\"-th diagonal of a matrix, as a vector. Use \"diagm\" to\n   construct a diagonal matrix.\n",
        "methods": 
        [
          "diag(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:1714",
          "diag(A::Array{T,2}) at linalg/dense.jl:115",
          "diag(A::Array{T,2},k::Integer) at linalg/dense.jl:115",
          "diag{T}(M::SymTridiagonal{T}) at linalg/tridiag.jl:40",
          "diag{T}(M::SymTridiagonal{T},n::Integer) at linalg/tridiag.jl:40",
          "diag{T}(M::Tridiagonal{T}) at linalg/tridiag.jl:195",
          "diag{T}(M::Tridiagonal{T},n::Integer) at linalg/tridiag.jl:195",
          "diag(A::Triangular{T<:Number}) at linalg/triangular.jl:102",
          "diag(D::Diagonal{T}) at linalg/diagonal.jl:77",
          "diag{T}(M::Bidiagonal{T}) at linalg/bidiag.jl:77",
          "diag{T}(M::Bidiagonal{T},n::Integer) at linalg/bidiag.jl:77",
          "diag(B::BitArray{2}) at linalg/bitarray.jl:79",
          "diag(A::AbstractArray{T,1}) at linalg/generic.jl:50",
          "diag{Tv}(A::CholmodSparse{Tv,Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:972",
          "diag{Tv}(L::CholmodFactor{Tv,Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:986"
        ]
      },
      {
        "name": "diagind",
        "summary": "Function",
        "help": "Base.diagind(M[, k])\n\n   A \"Range\" giving the indices of the \"k\"-th diagonal of the\n   matrix \"M\".\n",
        "methods": 
        [
          "diagind(m::Integer,n::Integer) at linalg/dense.jl:105",
          "diagind(m::Integer,n::Integer,k::Integer) at linalg/dense.jl:105",
          "diagind(A::AbstractArray{T,2}) at linalg/dense.jl:113",
          "diagind(A::AbstractArray{T,2},k::Integer) at linalg/dense.jl:113"
        ]
      },
      {
        "name": "diagm",
        "summary": "Function",
        "help": "Base.diagm(v[, k])\n\n   Construct a diagonal matrix and place \"v\" on the \"k\"-th\n   diagonal.\n",
        "methods": 
        [
          "diagm{Tv,Ti}(v::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:1717",
          "diagm(v::Union(BitArray{2},BitArray{1})) at linalg/bitarray.jl:88",
          "diagm{T}(v::AbstractArray{T,1}) at linalg/dense.jl:118",
          "diagm{T}(v::AbstractArray{T,1},k::Integer) at linalg/dense.jl:118",
          "diagm(x::Number) at linalg/dense.jl:124"
        ]
      },
      {
        "name": "diagmm",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "diagmm(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "diagmm!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "diagmm!(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "diff",
        "summary": "Function",
        "help": "Base.diff(A[, dim])\n\n   Finite difference operator of matrix or vector.\n",
        "methods": 
        [
          "diff(a::SparseMatrixCSC{Tv,Ti<:Integer},dim::Integer) at linalg/sparse.jl:476",
          "diff(a::AbstractArray{T,2}) at linalg/generic.jl:34",
          "diff(a::AbstractArray{T,1}) at linalg/generic.jl:35",
          "diff(A::AbstractArray{T,2},dim::Integer) at linalg/generic.jl:38"
        ]
      },
      {
        "name": "digamma",
        "summary": "Function",
        "help": "Base.digamma(x)\n\n   Compute the digamma function of \"x\" (the logarithmic derivative\n   of \"gamma(x)\")\n",
        "methods": 
        [
          "digamma(x::Float64) at math.jl:1016",
          "digamma(x::Float32) at math.jl:1077",
          "digamma(x::BigFloat) at mpfr.jl:397",
          "digamma(x::Real) at math.jl:1078",
          "digamma{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "digamma{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "digamma{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "digits",
        "summary": "Function",
        "help": "Base.digits(n[, base][, pad])\n\n   Returns an array of the digits of \"n\" in the given base,\n   optionally padded with zeros to a specified size. More significant\n   digits are at higher indexes, such that \"n ==\n   sum([digits[k]*base^(k-1) for k=1:length(digits)])\".\n",
        "methods": 
        [
          "digits(n::Integer) at intfuncs.jl:275",
          "digits{T<:Integer}(n::Integer,base::T<:Integer) at intfuncs.jl:275",
          "digits{T<:Integer}(n::Integer,base::T<:Integer,pad::Int64) at intfuncs.jl:275"
        ]
      },
      {
        "name": "dirname",
        "summary": "Function",
        "help": "Base.dirname(path::String) -> String\n\n   Get the directory part of a path.\n",
        "methods": 
        [
          "dirname(path::String) at path.jl:39"
        ]
      },
      {
        "name": "disable_sigint",
        "summary": "Function",
        "help": "Base.disable_sigint(f::Function)\n\n   Disable Ctrl-C handler during execution of a function, for calling\n   external code that is not interrupt safe. Intended to be called\n   using \"do\" block syntax as follows:\n\n      disable_sigint() do\n          # interrupt-unsafe code\n          ...\n      end\n",
        "methods": 
        [
          "disable_sigint(f::Function) at c.jl:74"
        ]
      },
      {
        "name": "disassemble",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "disassemble(f::Function,t::(Any...,)) at deprecated.jl:26",
          "disassemble(f::Function,t::(Any...,),asm::Bool) at deprecated.jl:26"
        ]
      },
      {
        "name": "display",
        "summary": "Function",
        "help": "Base.display(x)\nBase.display(d::Display, x)\nBase.display(mime, x)\nBase.display(d::Display, mime, x)\n\n   Display \"x\" using the topmost applicable display in the display\n   stack, typically using the richest supported multimedia output for\n   \"x\", with plain-text \"STDOUT\" output as a fallback.  The\n   \"display(d, x)\" variant attempts to display \"x\" on the given\n   display \"d\" only, throwing a \"MethodError\" if \"d\" cannot\n   display objects of this type.\n\n   There are also two variants with a \"mime\" argument (a MIME type\n   string, such as \"\"image/png\"\"), which attempt to display \"x\"\n   using the requesed MIME type *only*, throwing a \"MethodError\" if\n   this type is not supported by either the display(s) or by \"x\".\n   With these variants, one can also supply the \"raw\" data in the\n   requested MIME type by passing \"x::String\" (for MIME types with\n   text-based storage, such as text/html or application/postscript) or\n   \"x::Vector{Uint8}\" (for binary MIME types).\n",
        "methods": 
        [
          "display(d::Display,mime::String,x) at multimedia.jl:108",
          "display(mime::String,x) at multimedia.jl:109",
          "display(d::TextDisplay,M::MIME{:text/plain},x) at multimedia.jl:117",
          "display(d::TextDisplay,x) at multimedia.jl:118",
          "display(m::MIME{mime},x) at multimedia.jl:168",
          "display(d::REPLDisplay{R<:AbstractREPL},::MIME{:text/plain},x) at REPL.jl:112",
          "display(d::REPLDisplay{R<:AbstractREPL},x) at REPL.jl:117",
          "display(x) at multimedia.jl:160"
        ]
      },
      {
        "name": "displayable",
        "summary": "Function",
        "help": "Base.displayable(mime) -> Bool\nBase.displayable(d::Display, mime) -> Bool\n\n   Returns a boolean value indicating whether the given \"mime\" type\n   (string) is displayable by any of the displays in the current\n   display stack, or specifically by the display \"d\" in the second\n   variant.\n",
        "methods": 
        [
          "displayable(d::Display,mime::String) at multimedia.jl:110",
          "displayable(mime::String) at multimedia.jl:111",
          "displayable{D<:Display,mime}(d::D<:Display,::MIME{mime}) at multimedia.jl:175",
          "displayable(m::MIME{mime}) at multimedia.jl:179"
        ]
      },
      {
        "name": "distribute",
        "summary": "Function",
        "help": "Base.distribute(a)\n\n   Convert a local array to distributed.\n",
        "methods": 
        [
          "distribute(a::AbstractArray{T,N}) at darray.jl:166"
        ]
      },
      {
        "name": "div",
        "summary": "Function",
        "help": "Base.div(a, b)\n\n   Compute a/b, truncating to an integer\n",
        "methods": 
        [
          "div(x::Bool,y::Bool) at bool.jl:57",
          "div(x::Signed,y::Unsigned) at int.jl:79",
          "div(x::Unsigned,y::Signed) at int.jl:80",
          "div(A::BitArray{N},B::BitArray{N}) at bitarray.jl:892",
          "div(A::BitArray{N},B::Array{Bool,N}) at bitarray.jl:896",
          "div(A::Array{Bool,N},B::BitArray{N}) at bitarray.jl:897",
          "div{S,T}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:724",
          "div{T<:Union(Int8,Int64,Int16,Int32)}(x::T<:Union(Int8,Int64,Int16,Int32),y::T<:Union(Int8,Int64,Int16,Int32)) at int.jl:97",
          "div{T<:Union(Uint16,Uint8,Uint32,Uint64)}(x::T<:Union(Uint16,Uint8,Uint32,Uint64),y::T<:Union(Uint16,Uint8,Uint32,Uint64)) at int.jl:98",
          "div(x::Int128,y::Int128) at int.jl:592",
          "div(x::Uint128,y::Uint128) at int.jl:593",
          "div(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:148",
          "div(x::Rational{T<:Integer},y::Real) at rational.jl:149",
          "div(x::Real,y::Rational{T<:Integer}) at rational.jl:150",
          "div(x::BigInt,y::BigInt) at gmp.jl:193",
          "div{T<:Real}(x::T<:Real,y::T<:Real) at operators.jl:118",
          "div(x::Real,y::Real) at promotion.jl:172",
          "div{S,T<:Real}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Range{T<:Real}) at array.jl:732",
          "div{S<:Real,T}(A::Range{S<:Real},B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:741",
          "div(x::Bool,B::BitArray{N}) at bitarray.jl:902",
          "div(x::Number,B::BitArray{N}) at bitarray.jl:906",
          "div{T}(A::Number,B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:754",
          "div(B::BitArray{N},x::Bool) at bitarray.jl:899",
          "div(B::BitArray{N},x::Number) at bitarray.jl:936",
          "div{T}(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Number) at array.jl:761"
        ]
      },
      {
        "name": "divrem",
        "summary": "Function",
        "help": "Base.divrem(x, y)\n\n   Compute \"x/y\" and \"x%y\" at the same time\n",
        "methods": 
        [
          "divrem(x::BigInt,y::BigInt) at gmp.jl:318",
          "divrem(x,y) at number.jl:21"
        ]
      },
      {
        "name": "dlclose",
        "summary": "Function",
        "help": "Base.dlclose(handle)\n\n   Close shared library referenced by handle.\n",
        "methods": 
        [
          "dlclose(p::Ptr{T}) at c.jl:21"
        ]
      },
      {
        "name": "dlopen",
        "summary": "Function",
        "help": "Base.dlopen(libfile::String[, flags::Integer])\n\n   Load a shared library, returning an opaque handle.\n\n   The optional flags argument is a bitwise-or of zero or more of\n   RTLD_LOCAL, RTLD_GLOBAL, RTLD_LAZY, RTLD_NOW, RTLD_NODELETE,\n   RTLD_NOLOAD, RTLD_DEEPBIND, and RTLD_FIRST.  These are converted to\n   the corresponding flags of the POSIX (and/or GNU libc and/or MacOS)\n   dlopen command, if possible, or are ignored if the specified\n   functionality is not available on the current platform.  The\n   default is RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL.  An important usage\n   of these flags, on POSIX platforms, is to specify\n   RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL in order for the library's\n   symbols to be available for usage in other shared libraries, in\n   situations where there are dependencies between shared libraries.\n",
        "methods": 
        [
          "dlopen(s::String,flags::Integer) at c.jl:17",
          "dlopen(s::String) at c.jl:19"
        ]
      },
      {
        "name": "dlopen_e",
        "summary": "Function",
        "help": "Base.dlopen_e(libfile::String[, flags::Integer])\n\n   Similar to \"dlopen\", except returns a NULL pointer instead of\n   raising errors.\n",
        "methods": 
        [
          "dlopen_e(s::String,flags::Integer) at c.jl:18",
          "dlopen_e(s::String) at c.jl:20"
        ]
      },
      {
        "name": "dlsym",
        "summary": "Function",
        "help": "Base.dlsym(handle, sym)\n\n   Look up a symbol from a shared library handle, return callable\n   function pointer on success.\n",
        "methods": 
        [
          "dlsym(hnd,s::Union(Symbol,String)) at c.jl:15"
        ]
      },
      {
        "name": "dlsym_e",
        "summary": "Function",
        "help": "Base.dlsym_e(handle, sym)\n\n   Look up a symbol from a shared library handle, silently return NULL\n   pointer on lookup failure.\n",
        "methods": 
        [
          "dlsym_e(hnd,s::Union(Symbol,String)) at c.jl:16"
        ]
      },
      {
        "name": "done",
        "summary": "Function",
        "help": "Base.done(iter, state) -> Bool\n\n   Test whether we are done iterating\n",
        "methods": 
        [
          "done(mt::MethodTable,m::Method) at reflection.jl:125",
          "done(mt::MethodTable,i::()) at reflection.jl:126",
          "done(t::(Any...,),i::Int64) at tuple.jl:14",
          "done(r::FloatRange{T<:FloatingPoint},i) at range.jl:217",
          "done{T,S}(r::StepRange{T,S},i) at range.jl:223",
          "done(r::UnitRange{T<:Real},i) at range.jl:227",
          "done(x::Number,state) at number.jl:38",
          "done(B::BitArray{N},i::Int64) at bitarray.jl:201",
          "done(r::CalendarTimeRange{T<:AbstractCalendarDuration},i) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:406",
          "done(a::AbstractArray{T,N},i) at abstractarray.jl:247",
          "done(s::IntSet,i) at intset.jl:131",
          "done(v::Union(ValueIterator{T<:Associative{K,V}},KeyIterator{T<:Associative{K,V}}),state) at dict.jl:49",
          "done(t::ObjectIdDict,i) at dict.jl:191",
          "done(t::Dict{K,V},i) at dict.jl:575",
          "done(t::WeakKeyDict{K,V},i) at dict.jl:650",
          "done(s::Set{T},state) at set.jl:33",
          "done(e::Enumerate{I},state) at iterator.jl:16",
          "done(z::Zip{I<:(Any...,)},state::()) at iterator.jl:36",
          "done(z::Zip{I<:(Any...,)},state) at iterator.jl:38",
          "done(z::Zip2{I1,I2},st) at iterator.jl:58",
          "done(f::Filter{I},s) at iterator.jl:96",
          "done(i::Rest{I,S},st) at iterator.jl:109",
          "done(s::String,i) at string.jl:56",
          "done(itr::RegexMatchIterator,prev_match) at regex.jl:195",
          "done(::EnvHash,i) at env.jl:94",
          "done(t::Task,val) at task.jl:167",
          "done(itr::EachLine,nada) at io.jl:227",
          "done(pq::PriorityQueue{K,V},i) at collections.jl:272",
          "done(c::Combinations{T},s) at combinatorics.jl:270",
          "done(p::Permutations{T},s) at combinatorics.jl:304",
          "done(p::IntegerPartitions,xs) at combinatorics.jl:318",
          "done(f::FixedPartitions,s::Array{Int64,1}) at combinatorics.jl:384",
          "done(p::SetPartitions{T<:AbstractArray{T,1}},s) at combinatorics.jl:442",
          "done(p::FixedSetPartitions{T<:AbstractArray{T,1}},s) at combinatorics.jl:512",
          "done(d::SpDiagIterator{Tv,Ti},j) at sparse/sparsematrix.jl:1683",
          "done{T}(q::Deque{T},s::DequeIterator{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:128",
          "done(ct::Accumulator{T,V<:Number},state) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:40",
          "done(cc::ClassifiedCollections{K,Collection},state) at /home/samuel/.julia/v0.3/DataStructures/src/classifiedcollections.jl:39",
          "done{K,V}(t::HashDict{K,V,Int64},i) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:490",
          "done(t::HashDict{K,V,O<:Union(Nothing,Int64)},i) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:487",
          "done(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "done(s::OrderedSet{T},state) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:41",
          "done(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "done(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "done(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "done{T}(l::Cons{T},state::Cons{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:126",
          "done{T}(l::LinkedList{T},state::Nil{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:127",
          "done(it::Count{S<:Number},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:37",
          "done(it::Take{I},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:61",
          "done(it::Drop{I},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:90",
          "done(it::Cycle{I},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:117",
          "done(it::Repeat{O},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:135",
          "done(it::RepeatForever{O},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:150",
          "done(it::Chain,state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:199",
          "done(it::Product,state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:255",
          "done(it::Distinct{I},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:296",
          "done(it::Partition{I},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:368",
          "done(it::GroupBy{I},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:425",
          "done(it::IMap,state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:454",
          "done(it::Subsets,state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:498",
          "done(it::Iterate{T},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:512"
        ]
      },
      {
        "name": "dones",
        "summary": "Function",
        "help": "Base.dones(dims, ...)\n\n   Construct a distributed array of ones. Trailing arguments are the\n   same as those accepted by \"DArray()\".\n",
        "methods": 
        [
          "dones(d::Int64...) at darray.jl:155",
          "dones(args...) at darray.jl:154"
        ]
      },
      {
        "name": "dot",
        "summary": "Function",
        "help": "Base.dot(x, y)\n\n   Compute the dot product. For complex vectors, the first vector is\n   conjugated.\n\nBase.LinAlg.BLAS.dot(n, X, incx, Y, incy)\n\n   Dot product of two vectors consisting of \"n\" elements of array\n   \"X\" with stride \"incx\" and \"n\" elements of array \"Y\" with\n   stride \"incy\".\n",
        "methods": 
        [
          "dot{T<:Union(Float64,Float32)}(x::Array{T<:Union(Float64,Float32),1},y::Array{T<:Union(Float64,Float32),1}) at linalg/matmul.jl:32",
          "dot{T<:Union(Complex{Float64},Complex{Float32})}(x::Array{T<:Union(Complex{Float64},Complex{Float32}),1},y::Array{T<:Union(Complex{Float64},Complex{Float32}),1}) at linalg/matmul.jl:33",
          "dot{T<:Union(Float64,Float32),TI<:Integer}(x::Array{T<:Union(Float64,Float32),1},rx::Union(UnitRange{TI<:Integer},Range{TI<:Integer}),y::Array{T<:Union(Float64,Float32),1},ry::Union(UnitRange{TI<:Integer},Range{TI<:Integer})) at linalg/matmul.jl:35",
          "dot{T<:Union(Complex{Float64},Complex{Float32}),TI<:Integer}(x::Array{T<:Union(Complex{Float64},Complex{Float32}),1},rx::Union(UnitRange{TI<:Integer},Range{TI<:Integer}),y::Array{T<:Union(Complex{Float64},Complex{Float32}),1},ry::Union(UnitRange{TI<:Integer},Range{TI<:Integer})) at linalg/matmul.jl:42",
          "dot(x::BitArray{1},y::BitArray{1}) at linalg/bitarray.jl:3",
          "dot(x::AbstractArray{T,1},y::AbstractArray{T,1}) at linalg/matmul.jl:49",
          "dot(x::Number,y::Number) at linalg/matmul.jl:60"
        ]
      },
      {
        "name": "download",
        "summary": "Function",
        "help": "Base.download(url[, localfile])\n\n   Download a file from the given url, optionally renaming it to the\n   given local file name. Note that this function relies on the\n   availability of external tools such as \"curl\", \"wget\" or\n   \"fetch\" to download the file and is provided for convenience. For\n   production use or situations in which more options are need, please\n   use a package that provides the desired functionality instead.\n",
        "methods": 
        [
          "download(url::String,filename::String) at interactiveutil.jl:293",
          "download(url::String) at interactiveutil.jl:326"
        ]
      },
      {
        "name": "drand",
        "summary": "Function",
        "help": "Base.drand(dims, ...)\n\n   Construct a distributed uniform random array. Trailing arguments\n   are the same as those accepted by \"DArray()\".\n",
        "methods": 
        [
          "drand(d::Int64...) at darray.jl:159",
          "drand(args...) at darray.jl:158"
        ]
      },
      {
        "name": "drandn",
        "summary": "Function",
        "help": "Base.drandn(dims, ...)\n\n   Construct a distributed normal random array. Trailing arguments are\n   the same as those accepted by \"DArray()\".\n",
        "methods": 
        [
          "drandn(d::Int64...) at darray.jl:161",
          "drandn(args...) at darray.jl:160"
        ]
      },
      {
        "name": "dump",
        "summary": "Function",
        "help": "Base.dump(x)\n\n   Show all user-visible structure of a value.\n",
        "methods": 
        [
          "dump(io::IO,x::String,n::Int64,indent) at show.jl:687",
          "dump(io::IO,x::Dict{K,V},n::Int64,indent) at show.jl:695",
          "dump(io::IO,x::DataType,n::Int64,indent) at show.jl:711",
          "dump(io::IO,x::DataType,n::Int64) at show.jl:712",
          "dump(io::IO,x::DataType) at show.jl:713",
          "dump(io::IO,x::TypeVar,n::Int64,indent) at show.jl:714",
          "dump(io::IO,q::Deque{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:147",
          "dump(io::IO,x,n::Int64) at show.jl:685",
          "dump(io::IO,x) at show.jl:686",
          "dump(io::IO,x,n::Int64,indent) at show.jl:690",
          "dump(io::IO,args...) at show.jl:691",
          "dump(args...) at show.jl:692"
        ]
      },
      {
        "name": "dzeros",
        "summary": "Function",
        "help": "Base.dzeros(dims, ...)\n\n   Construct a distributed array of zeros. Trailing arguments are the\n   same as those accepted by \"DArray()\".\n",
        "methods": 
        [
          "dzeros(d::Int64...) at darray.jl:153",
          "dzeros(args...) at darray.jl:152"
        ]
      },
      {
        "name": "e",
        "summary": "MathConst{:e}",
        "help": "Base.e\n\n   The constant e\n",
        "methods": 
        [

        ]
      },
      {
        "name": "each_line",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "each_line(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "each_match",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "each_match(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "eachline",
        "summary": "Function",
        "help": "Base.eachline(stream)\n\n   Create an iterable object that will yield each line from a stream.\n",
        "methods": 
        [
          "eachline(stream::IO) at io.jl:223",
          "eachline(cmd::AbstractCmd,stdin) at process.jl:418",
          "eachline(cmd::AbstractCmd) at process.jl:424"
        ]
      },
      {
        "name": "eachmatch",
        "summary": "Function",
        "help": "Base.eachmatch(r::Regex, s::String[, overlap::Bool=false])\n\n   Search for all matches of a the regular expression \"r\" in \"s\"\n   and return a iterator over the matches. If overlap is true, the\n   matching sequences are allowed to overlap indices in the original\n   string, otherwise they must be from distinct character ranges.\n",
        "methods": 
        [
          "eachmatch(re::Regex,str::String) at regex.jl:235",
          "eachmatch(re::Regex,str::String,ovr::Bool) at regex.jl:232"
        ]
      },
      {
        "name": "eatwspace",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "eatwspace(io) at deprecated.jl:26"
        ]
      },
      {
        "name": "eatwspace_comment",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "eatwspace_comment(io,cmt) at deprecated.jl:26"
        ]
      },
      {
        "name": "edit",
        "summary": "Function",
        "help": "Base.edit(file::String[, line])\n\n   Edit a file optionally providing a line number to edit at. Returns\n   to the julia prompt when you quit the editor.\n\nBase.edit(function[, types])\n\n   Edit the definition of a function, optionally specifying a tuple of\n   types to indicate which method to edit.\n\nBase.Pkg.edit()\n\n   Opens \"Pkg.dir(\"REQUIRE\")\" in the editor specified by the\n   \"VISUAL\" or \"EDITOR\" environment variables; when the editor\n   command returns, it runs \"Pkg.resolve()\" to determine and install\n   a new optimal set of installed package versions.\n",
        "methods": 
        [
          "edit(file::String,line::Integer) at interactiveutil.jl:4",
          "edit(file::String) at interactiveutil.jl:47",
          "edit(f::Union(DataType,Function)) at interactiveutil.jl:54",
          "edit(f::Union(DataType,Function),t::(Type{T<:Top}...,)) at interactiveutil.jl:55",
          "edit(m::Method) at interactiveutil.jl:60"
        ]
      },
      {
        "name": "eig",
        "summary": "Function",
        "help": "Base.eig(A,[irange,][vl,][vu,][permute=true,][scale=true]) -> D, V\n\n   Compute eigenvalues and eigenvectors of \"A\". See \"eigfact()\"\n   for details on the \"balance\" keyword argument.\n\n   **Example**:\n\n      julia> eig(a = [1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])\n      ([1.0,3.0,18.0],\n      3x3 Array{Float64,2}:\n       1.0  0.0  0.0\n       0.0  1.0  0.0\n       0.0  0.0  1.0)\n\n   \"eig\" is a wrapper around \"eigfact()\", extracting all parts of\n   the factorization to a tuple; where possible, using \"eigfact()\"\n   is recommended.\n\nBase.eig(A, B) -> D, V\n\n   Computes generalized eigenvalues and vectors of \"A\" with respect\n   to \"B\".\n\n   \"eig\" is a wrapper around \"eigfact()\", extracting all parts of\n   the factorization to a tuple; where possible, using \"eigfact()\"\n   is recommended.\n",
        "methods": 
        [
          "eig(A::Union(AbstractArray{T,2},Number),args...) at linalg/factorization.jl:559"
        ]
      },
      {
        "name": "eigfact",
        "summary": "Function",
        "help": "Base.eigfact(A,[il,][iu,][vl,][vu,][permute=true,][scale=true])\n\n   Compute the eigenvalue decomposition of \"A\" and return an\n   \"Eigen\" object. If \"F\" is the factorization object, the\n   eigenvalues can be accessed with \"F[:values]\" and the\n   eigenvectors with \"F[:vectors]\". The following functions are\n   available for \"Eigen\" objects: \"inv\", \"det\".\n\n   If \"A\" is \"Symmetric\", \"Hermitian\" or \"SymTridiagonal\", it\n   is possible to calculate only a subset of the eigenvalues by\n   specifying either a *UnitRange`* \"irange\" covering indices of the\n   sorted eigenvalues or a pair \"vl\" and \"vu\" for the lower and\n   upper boundaries of the eigenvalues.\n\n   For general non-symmetric matrices it is possible to specify how\n   the matrix is balanced before the eigenvector calculation. The\n   option \"permute=true\" permutes the matrix to become closer to\n   upper triangular, and \"scale=true\" scales the matrix by its\n   diagonal elements to make rows and columns more equal in norm. The\n   default is \"true\" for both options.\n\nBase.eigfact(A, B)\n\n   Compute the generalized eigenvalue decomposition of \"A\" and \"B\"\n   and return an \"GeneralizedEigen\" object. If \"F\" is the\n   factorization object, the eigenvalues can be accessed with\n   \"F[:values]\" and the eigenvectors with \"F[:vectors]\".\n",
        "methods": 
        [
          "eigfact(A::Triangular{T<:Number}) at linalg/triangular.jl:206",
          "eigfact(D::Diagonal{T}) at linalg/diagonal.jl:121",
          "eigfact(M::Bidiagonal{T}) at linalg/bidiag.jl:210",
          "eigfact{TA,TB}(A::AbstractArray{TA,2},B::AbstractArray{TB,2}) at linalg/factorization.jl:617",
          "eigfact{T}(A::AbstractArray{T,2},args...) at linalg/factorization.jl:551",
          "eigfact(x::Number) at linalg/factorization.jl:552"
        ]
      },
      {
        "name": "eigfact!",
        "summary": "Function",
        "help": "Base.eigfact!(A[, B])\n\n   \"eigfact!\" is the same as \"eigfact()\", but saves space by\n   overwriting the input A (and B), instead of creating a copy.\n",
        "methods": 
        [
          "eigfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(m::SymTridiagonal{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/tridiag.jl:60",
          "eigfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(m::SymTridiagonal{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},irange::UnitRange{T<:Real}) at linalg/tridiag.jl:61",
          "eigfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(m::SymTridiagonal{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},vl::Real,vu::Real) at linalg/tridiag.jl:62",
          "eigfact!{T<:Union(Float64,Float32)}(A::Union(SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2})) at linalg/factorization.jl:525",
          "eigfact!{T<:Union(Complex{Float64},Complex{Float32})}(A::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:546",
          "eigfact!{T<:Union(Float64,Float32)}(A::Union(SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2}),B::Union(SubArray{T<:Union(Float64,Float32),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Float32),2})) at linalg/factorization.jl:592",
          "eigfact!{T<:Union(Complex{Float64},Complex{Float32})}(A::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),2},SubArray{T<:Union(Complex{Float64},Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:613",
          "eigfact!{T<:Union(Complex{Float64},Complex{Float32})}(A::Hermitian{T<:Union(Complex{Float64},Complex{Float32})},B::Hermitian{T<:Union(Complex{Float64},Complex{Float32})}) at linalg/symmetric.jl:56",
          "eigfact!{T<:Union(Float64,Float32)}(A::Union(Symmetric{T<:Union(Float64,Float32)},Hermitian{T<:Union(Float64,Float32)},Hermitian{Complex{T<:Union(Float64,Float32)}})) at linalg/symmetric.jl:42",
          "eigfact!{T<:Union(Float64,Float32)}(A::Union(Symmetric{T<:Union(Float64,Float32)},Hermitian{T<:Union(Float64,Float32)}),B::Union(Symmetric{T<:Union(Float64,Float32)},Hermitian{T<:Union(Float64,Float32)})) at linalg/symmetric.jl:52",
          "eigfact!{T<:Union(Float64,Float32)}(A::Union(Symmetric{T<:Union(Float64,Float32)},Hermitian{T<:Union(Float64,Float32)},Hermitian{Complex{T<:Union(Float64,Float32)}}),irange::UnitRange{T<:Real}) at linalg/symmetric.jl:43",
          "eigfact!{T<:Union(Float64,Float32)}(A::Union(Symmetric{T<:Union(Float64,Float32)},Hermitian{T<:Union(Float64,Float32)},Hermitian{Complex{T<:Union(Float64,Float32)}}),vl::Real,vh::Real) at linalg/symmetric.jl:44"
        ]
      },
      {
        "name": "eigmax",
        "summary": "Function",
        "help": "Base.eigmax(A)\n\n   Returns the largest eigenvalue of \"A\".\n",
        "methods": 
        [
          "eigmax(m::SymTridiagonal{T}) at linalg/tridiag.jl:68",
          "eigmax{T<:Real}(A::Union(Hermitian{Complex{T<:Real}},Symmetric{T<:Real},Hermitian{T<:Real})) at linalg/symmetric.jl:48",
          "eigmax(A::Union(AbstractArray{T,2},Number)) at linalg/factorization.jl:579"
        ]
      },
      {
        "name": "eigmin",
        "summary": "Function",
        "help": "Base.eigmin(A)\n\n   Returns the smallest eigenvalue of \"A\".\n",
        "methods": 
        [
          "eigmin(m::SymTridiagonal{T}) at linalg/tridiag.jl:69",
          "eigmin{T<:Real}(A::Union(Hermitian{Complex{T<:Real}},Symmetric{T<:Real},Hermitian{T<:Real})) at linalg/symmetric.jl:49",
          "eigmin(A::Union(AbstractArray{T,2},Number)) at linalg/factorization.jl:583"
        ]
      },
      {
        "name": "eigs",
        "summary": "Function",
        "help": "Base.eigs(A[, B], ; nev=6, which=\"LM\", tol=0.0, maxiter=1000, sigma=nothing, ritzvec=true, v0=zeros((0, ))) -> (d[, v], nconv, niter, nmult, resid)\n\n   \"eigs\" computes eigenvalues \"d\" of \"A\" using Lanczos or\n   Arnoldi iterations for real symmetric or general nonsymmetric\n   matrices respectively. If \"B\" is provided, the generalized eigen-\n   problem is solved.  The following keyword arguments are supported:\n      * \"nev\": Number of eigenvalues\n\n      * \"which\": type of eigenvalues to compute. See the note below.\n\n        +-----------+------------------------------------------------------------------------------------------------------------------------+\n        | \\\"which\\\" | type of eigenvalues                                                                                                    |\n        +-----------+------------------------------------------------------------------------------------------------------------------------+\n        | \\\"\\\"LM\\\"\\ | eigenvalues of largest magnitude                                                                                       |\n        +-----------+------------------------------------------------------------------------------------------------------------------------+\n        | \\\"\\\"SM\\\"\\ | eigenvalues of smallest magnitude                                                                                      |\n        +-----------+------------------------------------------------------------------------------------------------------------------------+\n        | \\\"\\\"LA\\\"\\ | largest algebraic eigenvalues (real symmetric \\\"A\\\" only)                                                              |\n        +-----------+------------------------------------------------------------------------------------------------------------------------+\n        | \\\"\\\"SA\\\"\\ | smallest algebraic eigenvalues (real symmetric \\\"A\\\" only)                                                             |\n        +-----------+------------------------------------------------------------------------------------------------------------------------+\n        | \\\"\\\"BE\\\"\\ | compute half of the eigenvalues from each end of the spectrum, biased in favor of the high end. (symmetric \\\"A\\\" only) |\n        +-----------+------------------------------------------------------------------------------------------------------------------------+\n        | \\\"\\\"LR\\\"\\ | eigenvalues of largest real part (nonsymmetric \\\"A\\\" only)                                                             |\n        +-----------+------------------------------------------------------------------------------------------------------------------------+\n        | \\\"\\\"SR\\\"\\ | eigenvalues of smallest real part (nonsymmetric \\\"A\\\" only)                                                            |\n        +-----------+------------------------------------------------------------------------------------------------------------------------+\n        | \\\"\\\"LI\\\"\\ | eigenvalues of largest imaginary part (nonsymmetric \\\"A\\\" only)                                                        |\n        +-----------+------------------------------------------------------------------------------------------------------------------------+\n        | \\\"\\\"SI\\\"\\ | eigenvalues of smallest imaginary part (nonsymmetric \\\"A\\\" only)                                                       |\n        +-----------+------------------------------------------------------------------------------------------------------------------------+\n\n      * \"tol\": tolerance (tol \\le 0.0 defaults to\n        \"DLAMCH('EPS')\")\n\n      * \"maxiter\": Maximum number of iterations\n\n      * \"sigma\": Specifies the level shift used in inverse\n        iteration. If \"nothing\" (default), defaults to ordinary\n        (forward) iterations. Otherwise, find eigenvalues close to\n        \"sigma\" using shift and invert iterations.\n\n      * \"ritzvec\": Returns the Ritz vectors \"v\" (eigenvectors) if\n        \"true\"\n\n      * \"v0\": starting vector from which to start the iterations\n\n   \"eigs\" returns the \"nev\" requested eigenvalues in \"d\", the\n   corresponding Ritz vectors \"v\" (only if \"ritzvec=true\"), the\n   number of converged eigenvalues \"nconv\", the number of iterations\n   \"niter\" and the number of matrix vector multiplications\n   \"nmult\", as well as the final residual vector \"resid\".\n\n   Note: The \"sigma\" and \"which\" keywords interact: the description of\n     eigenvalues searched for by \"which\" do _not_ necessarily refer\n     to the eigenvalues of \"A\", but rather the linear operator\n     constructed by the specification of the iteration mode implied by\n     \"sigma\".\n\n     +-----------------+------------------------------------+------------------------------------+\n     | \\\"sigma\\\"       | iteration mode                     | \\\"which\\\" refers to eigenvalues of |\n     +-----------------+------------------------------------+------------------------------------+\n     | \\\"nothing\\\"     | ordinary (forward)                 | A                                  |\n     +-----------------+------------------------------------+------------------------------------+\n     | real or complex | inverse with level shift \\\"sigma\\\" | (A - \\\\sigma I )^{-1}              |\n     +-----------------+------------------------------------+------------------------------------+\n",
        "methods": 
        [
          "eigs(A) at linalg/arnoldi.jl:5",
          "eigs(A,B) at linalg/arnoldi.jl:12"
        ]
      },
      {
        "name": "eigvals",
        "summary": "Function",
        "help": "Base.eigvals(A,[irange,][vl,][vu])\n\n   Returns the eigenvalues of \"A\". If \"A\" is \"Symmetric()\",\n   \"Hermitian()\" or \"SymTridiagonal()\", it is possible to\n   calculate only a subset of the eigenvalues by specifying either a\n   \"UnitRange()\" \"irange\" covering indices of the sorted\n   eigenvalues, or a pair \"vl\" and \"vu\" for the lower and upper\n   boundaries of the eigenvalues.\n\n   For general non-symmetric matrices it is possible to specify how\n   the matrix is balanced before the eigenvector calculation. The\n   option \"permute=true\" permutes the matrix to become closer to\n   upper triangular, and \"scale=true\" scales the matrix by its\n   diagonal elements to make rows and columns more equal in norm. The\n   default is \"true\" for both options.\n",
        "methods": 
        [
          "eigvals(A::Triangular{T<:Number}) at linalg/triangular.jl:169",
          "eigvals{T<:Number}(D::Diagonal{T<:Number}) at linalg/diagonal.jl:118",
          "eigvals(D::Diagonal{T}) at linalg/diagonal.jl:119",
          "eigvals(M::Bidiagonal{T}) at linalg/bidiag.jl:184",
          "eigvals{TA,TB}(A::AbstractArray{TA,2},B::AbstractArray{TB,2}) at linalg/factorization.jl:629",
          "eigvals{T}(A::AbstractArray{T,2},args...) at linalg/factorization.jl:574",
          "eigvals{T<:Number}(x::T<:Number) at linalg/factorization.jl:575"
        ]
      },
      {
        "name": "eigvecs",
        "summary": "Function",
        "help": "Base.eigvecs(A, [eigvals,][permute=true,][scale=true])\n\n   Returns the eigenvectors of \"A\". The \"permute\" and \"scale\"\n   keywords are the same as for \"eigfact()\".\n\n   For \"SymTridiagonal()\" matrices, if the optional vector of\n   eigenvalues \"eigvals\" is specified, returns the specific\n   corresponding eigenvectors.\n",
        "methods": 
        [
          "eigvecs{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Eigenvalue<:Real}(m::SymTridiagonal{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},eigvals::Array{Eigenvalue<:Real,1}) at linalg/tridiag.jl:73",
          "eigvecs(m::SymTridiagonal{T}) at linalg/tridiag.jl:72",
          "eigvecs{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Triangular{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/triangular.jl:58",
          "eigvecs{T}(A::Triangular{T}) at linalg/triangular.jl:173",
          "eigvecs(D::Diagonal{T}) at linalg/diagonal.jl:120",
          "eigvecs{T}(M::Bidiagonal{T}) at linalg/bidiag.jl:186",
          "eigvecs(A::Union(AbstractArray{T,2},Number),args...) at linalg/factorization.jl:563"
        ]
      },
      {
        "name": "eltype",
        "summary": "Function",
        "help": "Base.eltype(collection)\n\n   Determine the type of the elements generated by iterating\n   \"collection\". For associative collections, this will be a\n   \"(key,value)\" tuple type.\n",
        "methods": 
        [
          "eltype{T}(x::(T...,)) at tuple.jl:25",
          "eltype(x::Number) at number.jl:8",
          "eltype{T<:Number}(::Type{T<:Number}) at number.jl:9",
          "eltype{T}(::Ptr{T}) at pointer.jl:61",
          "eltype{T,n}(::AbstractArray{T,n}) at abstractarray.jl:11",
          "eltype{T,n}(::Type{AbstractArray{T,n}}) at abstractarray.jl:12",
          "eltype{T<:AbstractArray{T,N}}(::Type{T<:AbstractArray{T,N}}) at abstractarray.jl:13",
          "eltype(s::IntSet) at intset.jl:15",
          "eltype(v::KeyIterator{T<:Associative{K,V}}) at dict.jl:45",
          "eltype(v::ValueIterator{T<:Associative{K,V}}) at dict.jl:46",
          "eltype{K,V}(a::Associative{K,V}) at dict.jl:95",
          "eltype{T}(s::Set{T}) at set.jl:14",
          "eltype(e::Enumerate{I}) at iterator.jl:18",
          "eltype(z::Zip{I<:(Any...,)}) at iterator.jl:46",
          "eltype(z::Zip2{I1,I2}) at iterator.jl:60",
          "eltype(f::Filter{I}) at iterator.jl:98",
          "eltype(r::Rest{I,S}) at iterator.jl:111",
          "eltype(::String) at string.jl:73",
          "eltype{T<:String}(::Type{T<:String}) at string.jl:74",
          "eltype(itr::RegexMatchIterator) at regex.jl:193",
          "eltype(itr::EachLine) at io.jl:234",
          "eltype{T}(c::Combinations{UnitRange{T}}) at combinatorics.jl:237",
          "eltype{T}(c::Combinations{Range{T}}) at combinatorics.jl:238",
          "eltype(c::Combinations{T}) at combinatorics.jl:236",
          "eltype{T}(c::Permutations{UnitRange{T}}) at combinatorics.jl:277",
          "eltype{T}(c::Permutations{Range{T}}) at combinatorics.jl:278",
          "eltype(c::Permutations{T}) at combinatorics.jl:276",
          "eltype{T}(J::UniformScaling{T}) at linalg/uniformscaling.jl:10",
          "eltype{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodDense{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/cholmod.jl:310",
          "eltype{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodFactor{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:311",
          "eltype{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:312",
          "eltype{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodTriplet{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:313",
          "eltype{T}(s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:22",
          "eltype{S}(it::Count{S}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:29",
          "eltype(it::Take{I}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:47",
          "eltype(it::Drop{I}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:73",
          "eltype(it::Cycle{I}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:99",
          "eltype{O}(it::Repeat{O}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:126",
          "eltype{O}(r::RepeatForever{O}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:142",
          "eltype(it::Chain) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:164",
          "eltype(p::Product) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:211",
          "eltype(it::Distinct{I}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:270",
          "eltype(it::Partition{I}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:311",
          "eltype{I}(it::GroupBy{I}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:385",
          "eltype(it::Subsets) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:464",
          "eltype(x) at abstractarray.jl:10"
        ]
      },
      {
        "name": "empty!",
        "summary": "Function",
        "help": "Base.empty!(collection) -> collection\n\n   Remove all elements from a \"collection\".\n",
        "methods": 
        [
          "empty!(a::Array{T,1}) at array.jl:651",
          "empty!(B::BitArray{1}) at bitarray.jl:779",
          "empty!(s::IntSet) at intset.jl:95",
          "empty!(t::ObjectIdDict) at dict.jl:188",
          "empty!{K,V}(h::Dict{K,V}) at dict.jl:357",
          "empty!(wkh::WeakKeyDict{K,V}) at dict.jl:644",
          "empty!{T}(s::Set{T}) at set.jl:30",
          "empty!{T}(q::Deque{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:173",
          "empty!{K,V}(h::HashDict{K,V,Int64}) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:247",
          "empty!{K,V}(h::HashDict{K,V,O<:Union(Nothing,Int64)}) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:237",
          "empty!(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "empty!{T}(s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:38",
          "empty!(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "empty!(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "empty!(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11"
        ]
      },
      {
        "name": "endof",
        "summary": "Function",
        "help": "Base.endof(collection) -> Integer\n\n   Returns the last index of the collection.\n\n   **Example**:\n\n      julia> endof([1,2,4])\n      3\n",
        "methods": 
        [
          "endof(t::(Any...,)) at tuple.jl:4",
          "endof(x::Number) at number.jl:13",
          "endof(a::AbstractArray{T,N}) at abstractarray.jl:24",
          "endof(s::ASCIIString) at ascii.jl:10",
          "endof(s::UTF8String) at utf8.jl:32",
          "endof(s::UTF16String) at utf16.jl:11",
          "endof(s::GenericString) at string.jl:561",
          "endof(s::UTF32String) at string.jl:575",
          "endof(s::SubString{T<:String}) at string.jl:641",
          "endof(s::RepString) at string.jl:692",
          "endof(s::RevString{T<:String}) at string.jl:732",
          "endof(s::RopeString) at string.jl:787",
          "endof(s::String) at string.jl:12"
        ]
      },
      {
        "name": "ends_with",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "ends_with(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "endswith",
        "summary": "Function",
        "help": "Base.endswith(string, suffix | chars)\n\n   Returns \"true\" if \"string\" ends with \"suffix\". If the second\n   argument is a vector or set of characters, tests whether the last\n   character of \"string\" belongs to that set.\n",
        "methods": 
        [
          "endswith(a::String,b::String) at string.jl:503",
          "endswith(str::String,chars::Union(Char,Set{Char},AbstractArray{Char,1})) at string.jl:516"
        ]
      },
      {
        "name": "enumerate",
        "summary": "Function",
        "help": "Base.enumerate(iter)\n\n   Return an iterator that yields \"(i, x)\" where \"i\" is an index\n   starting at 1, and \"x\" is the \"ith\" value from the given\n   iterator. It's useful when you need not only the values *x* over\n   which you are iterating, but also the index *i* of the iterations.\n\n   **Example**:\n\n      julia> a = [\"a\", \"b\", \"c\"]\n      julia> for (index, value) in enumerate(a)\n                 println(\"$index $value\")\n             end\n      1 a\n      2 b\n      3 c\n",
        "methods": 
        [
          "enumerate(itr) at iterator.jl:8"
        ]
      },
      {
        "name": "eof",
        "summary": "Function",
        "help": "Base.eof(stream) -> Bool\n\n   Tests whether an I/O stream is at end-of-file. If the stream is not\n   yet exhausted, this function will block to wait for more data if\n   necessary, and then return \"false\". Therefore it is always safe\n   to read one byte after seeing \"eof\" return \"false\". \"eof\"\n   will return \"false\" as long as buffered data is still available,\n   even if the remote end of a connection is closed.\n",
        "methods": 
        [
          "eof(io::IOBuffer) at iobuffer.jl:153",
          "eof(s::IOStream) at io.jl:310",
          "eof(s::AsyncStream) at stream.jl:51",
          "eof(s::Session) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:395"
        ]
      },
      {
        "name": "eps",
        "summary": "Function",
        "help": "Base.eps([type])\n\n   The distance between 1.0 and the next larger representable\n   floating-point value of \"type\". Only floating-point types are\n   sensible arguments. If \"type\" is omitted, then \"eps(Float64)\"\n   is returned.\n\nBase.eps(x)\n\n   The distance between \"x\" and the next larger representable\n   floating-point value of the same type as \"x\".\n",
        "methods": 
        [
          "eps(x::FloatingPoint) at float.jl:291",
          "eps(::Type{Float16}) at float.jl:292",
          "eps(::Type{Float32}) at float.jl:293",
          "eps(::Type{Float64}) at float.jl:294",
          "eps() at float.jl:295",
          "eps(::Type{BigFloat}) at mpfr.jl:686"
        ]
      },
      {
        "name": "erf",
        "summary": "Function",
        "help": "Base.erf(x)\n\n   Compute the error function of \"x\", defined by\n   \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{-t^2} dt for arbitrary complex\n   \"x\".\n",
        "methods": 
        [
          "erf(x::Float64) at math.jl:253",
          "erf(x::Float32) at math.jl:254",
          "erf(x::BigFloat) at mpfr.jl:397",
          "erf(x::FloatingPoint) at math.jl:264",
          "erf(x::Real) at math.jl:255",
          "erf{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "erf{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "erf{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357",
          "erf(z::Complex{Float64}) at math.jl:1239",
          "erf(z::Complex{Float32}) at math.jl:1240",
          "erf(z::Complex{T<:Real}) at math.jl:1241"
        ]
      },
      {
        "name": "erfc",
        "summary": "Function",
        "help": "Base.erfc(x)\n\n   Compute the complementary error function of \"x\", defined by 1 -\n   \\operatorname{erf}(x).\n",
        "methods": 
        [
          "erfc(x::Float64) at math.jl:253",
          "erfc(x::Float32) at math.jl:254",
          "erfc(x::BigFloat) at mpfr.jl:397",
          "erfc(x::FloatingPoint) at math.jl:264",
          "erfc(x::Real) at math.jl:255",
          "erfc{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "erfc{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "erfc{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357",
          "erfc(z::Complex{Float64}) at math.jl:1239",
          "erfc(z::Complex{Float32}) at math.jl:1240",
          "erfc(z::Complex{T<:Real}) at math.jl:1241"
        ]
      },
      {
        "name": "erfcinv",
        "summary": "Function",
        "help": "Base.erfcinv(x)\n\n   Compute the inverse error complementary function of a real \"x\",\n   defined by \\operatorname{erfc}(\\operatorname{erfcinv}(x)) = x.\n",
        "methods": 
        [
          "erfcinv(y::Float64) at math.jl:1379",
          "erfcinv(y::Float32) at math.jl:1431",
          "erfcinv(x::Integer) at math.jl:1453",
          "erfcinv{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "erfcinv{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "erfcinv{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "erfcx",
        "summary": "Function",
        "help": "Base.erfcx(x)\n\n   Compute the scaled complementary error function of \"x\", defined\n   by e^{x^2} \\operatorname{erfc}(x).  Note also that\n   \\operatorname{erfcx}(-ix) computes the Faddeeva function w(x).\n",
        "methods": 
        [
          "erfcx(z::Complex{Float64}) at math.jl:1239",
          "erfcx(z::Complex{Float32}) at math.jl:1240",
          "erfcx(z::Complex{T<:Real}) at math.jl:1241",
          "erfcx(x::Float64) at math.jl:1248",
          "erfcx(x::Float32) at math.jl:1249",
          "erfcx(x::Integer) at math.jl:1250",
          "erfcx{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "erfcx{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "erfcx{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "erfi",
        "summary": "Function",
        "help": "Base.erfi(x)\n\n   Compute the imaginary error function of \"x\", defined by -i\n   \\operatorname{erf}(ix).\n",
        "methods": 
        [
          "erfi(z::Complex{Float64}) at math.jl:1239",
          "erfi(z::Complex{Float32}) at math.jl:1240",
          "erfi(z::Complex{T<:Real}) at math.jl:1241",
          "erfi(x::Float64) at math.jl:1248",
          "erfi(x::Float32) at math.jl:1249",
          "erfi(x::Integer) at math.jl:1250",
          "erfi{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "erfi{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "erfi{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "erfinv",
        "summary": "Function",
        "help": "Base.erfinv(x)\n\n   Compute the inverse error function of a real \"x\", defined by\n   \\operatorname{erf}(\\operatorname{erfinv}(x)) = x.\n",
        "methods": 
        [
          "erfinv(x::Float64) at math.jl:1263",
          "erfinv(x::Float32) at math.jl:1331",
          "erfinv(x::Integer) at math.jl:1373",
          "erfinv{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "erfinv{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "erfinv{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "errno",
        "summary": "Function",
        "help": "Base.errno([code])\n\n   Get the value of the C library's \"errno\". If an argument is\n   specified, it is used to set the value of \"errno\".\n\n   The value of \"errno\" is only valid immediately after a \"ccall\"\n   to a C library routine that sets it. Specifically, you cannot call\n   \"errno\" at the next prompt in a REPL, because lots of code is\n   executed between prompts.\n",
        "methods": 
        [
          "errno() at error.jl:35",
          "errno(e::Integer) at error.jl:36"
        ]
      },
      {
        "name": "error",
        "summary": "Function",
        "help": "Base.error(message::String)\n\n   Raise an error with the given message\n",
        "methods": 
        [
          "error(e::Exception) at error.jl:19",
          "error{E<:Exception}(::Type{E<:Exception}) at error.jl:20",
          "error(s::String) at error.jl:21",
          "error(s...) at error.jl:22"
        ]
      },
      {
        "name": "error_show",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "error_show(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "esc",
        "summary": "Function",
        "help": "Base.esc(e::ANY)\n\n   Only valid in the context of an Expr returned from a macro.\n   Prevents the macro hygine pass from turning embedded variables into\n   gensym variables. See the *Macros* section of the Metaprogramming\n   chapter of the manual for more details and examples.\n",
        "methods": 
        [
          "esc(e::ANY) at base.jl:193"
        ]
      },
      {
        "name": "escape_string",
        "summary": "Function",
        "help": "Base.escape_string(str::String) -> String\n\n   General escaping of traditional C and Unicode escape sequences. See\n   \"print_escaped()\" for more general escaping.\n",
        "methods": 
        [
          "escape_string(s::String) at string.jl:874"
        ]
      },
      {
        "name": "eta",
        "summary": "Function",
        "help": "Base.eta(x)\n\n   Dirichlet eta function \\eta(s) =\n   \\sum^\\infty_{n=1}(-)^{n-1}/n^{s}.\n",
        "methods": 
        [
          "eta(z::Union(Float64,Complex{Float64})) at math.jl:1192",
          "eta(x::Integer) at math.jl:1223",
          "eta(x::Real) at math.jl:1224",
          "eta(z::Complex{T<:Real}) at math.jl:1225",
          "eta{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "eta{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "eta{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "etree",
        "summary": "Function",
        "help": "Base.etree(A[, post])\n\n   Compute the elimination tree of a symmetric sparse matrix \"A\"\n   from \"triu(A)\" and, optionally, its post-ordering permutation.\n",
        "methods": 
        [
          "etree(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/csparse.jl:261",
          "etree{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti},postorder::Bool) at sparse/csparse.jl:216"
        ]
      },
      {
        "name": "eu",
        "summary": "MathConst{:e}",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "eulergamma",
        "summary": "MathConst{:γ}",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "evalfile",
        "summary": "Function",
        "help": "Base.evalfile(path::String)\n\n   Evaluate all expressions in the given file, and return the value of\n   the last one. No other processing (path searching, fetching from\n   node 1, etc.) is performed.\n",
        "methods": 
        [
          "evalfile(path::String) at loading.jl:168",
          "evalfile(path::String,args::Array{UTF8String,1}) at loading.jl:168",
          "evalfile(path::String,args::Array{T,1}) at loading.jl:175"
        ]
      },
      {
        "name": "exit",
        "summary": "Function",
        "help": "Base.exit([code])\n\n   Quit (or control-D at the prompt). The default exit code is zero,\n   indicating that the processes completed successfully.\n",
        "methods": 
        [
          "exit(n) at client.jl:36",
          "exit() at client.jl:37"
        ]
      },
      {
        "name": "exp",
        "summary": "Function",
        "help": "Base.exp(x)\n\n   Compute e^x\n",
        "methods": 
        [
          "exp(a::Complex{Float16}) at float16.jl:134",
          "exp(z::Complex{T<:Real}) at complex.jl:330",
          "exp(x::Float64) at math.jl:253",
          "exp(x::Float32) at math.jl:254",
          "exp(a::Float16) at float16.jl:133",
          "exp(x::BigFloat) at mpfr.jl:397",
          "exp(x::FloatingPoint) at math.jl:264",
          "exp(x::Real) at math.jl:255",
          "exp{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "exp{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "exp{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "exp{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "exp10",
        "summary": "Function",
        "help": "Base.exp10(x)\n\n   Compute 10^x\n",
        "methods": 
        [
          "exp10{T}(z::Complex{T}) at complex.jl:435",
          "exp10(x::Float64) at math.jl:268",
          "exp10(x::Float32) at math.jl:269",
          "exp10(x::Integer) at math.jl:270",
          "exp10{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "exp10{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "exp10{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "exp10{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357",
          "exp10(x::BigFloat) at mpfr.jl:397"
        ]
      },
      {
        "name": "exp2",
        "summary": "Function",
        "help": "Base.exp2(x)\n\n   Compute 2^x\n",
        "methods": 
        [
          "exp2{T}(z::Complex{T}) at complex.jl:429",
          "exp2(x::Float64) at math.jl:253",
          "exp2(x::Float32) at math.jl:254",
          "exp2(x::BigFloat) at mpfr.jl:397",
          "exp2(x::FloatingPoint) at math.jl:262",
          "exp2(x::Real) at math.jl:255",
          "exp2{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "exp2{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "exp2{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "exp2{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "expand",
        "summary": "Function",
        "help": "Base.expand(x)\n\n   Takes the expression x and returns an equivalent expression in\n   lowered form\n",
        "methods": 
        [
          "expand(x) at expr.jl:57"
        ]
      },
      {
        "name": "expanduser",
        "summary": "Function",
        "help": "Base.expanduser(path::String) -> String\n\n   On Unix systems, replace a tilde character at the start of a path\n   with the current user's home directory.\n",
        "methods": 
        [
          "expanduser(path::String) at path.jl:135"
        ]
      },
      {
        "name": "expm",
        "summary": "Function",
        "help": "Base.expm(A)\n\n   Matrix exponential.\n",
        "methods": 
        [
          "expm{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/dense.jl:203",
          "expm{T<:Integer}(A::Union(SubArray{T<:Integer,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Integer,2})) at linalg/dense.jl:204",
          "expm(x::Number) at linalg/dense.jl:205",
          "expm{T<:Real}(A::Union(Hermitian{Complex{T<:Real}},Symmetric{T<:Real},Hermitian{T<:Real})) at linalg/symmetric.jl:63",
          "expm(D::Diagonal{T}) at linalg/diagonal.jl:88"
        ]
      },
      {
        "name": "expm1",
        "summary": "Function",
        "help": "Base.expm1(x)\n\n   Accurately compute e^x-1\n",
        "methods": 
        [
          "expm1(z::Complex{T<:Real}) at complex.jl:352",
          "expm1(x::Float64) at math.jl:253",
          "expm1(x::Float32) at math.jl:254",
          "expm1(x::BigFloat) at mpfr.jl:397",
          "expm1(x::FloatingPoint) at math.jl:264",
          "expm1(x::Real) at math.jl:255",
          "expm1(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:464",
          "expm1{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "expm1{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "expm1{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "exponent",
        "summary": "Function",
        "help": "Base.exponent(x) -> Int\n\n   Get the exponent of a normalized floating-point number.\n",
        "methods": 
        [
          "exponent(x::Float64) at math.jl:365",
          "exponent(x::Float32) at math.jl:371",
          "exponent{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "exponent{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "exponent{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "exponent(x::Float16) at float16.jl:140",
          "exponent(x::BigFloat) at mpfr.jl:625"
        ]
      },
      {
        "name": "expr",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "expr(hd,a::Array{Any,1}) at deprecated.jl:26",
          "expr(hd,a...) at deprecated.jl:26"
        ]
      },
      {
        "name": "extrema",
        "summary": "Function",
        "help": "Base.extrema(itr)\n\n   Compute both the minimum and maximum element in a single pass, and\n   return them as a 2-tuple.\n",
        "methods": 
        [
          "extrema(r::Range{T}) at reduce.jl:556",
          "extrema{T<:Real}(A::AbstractArray{T<:Real,N}) at reduce.jl:580",
          "extrema(itr) at reduce.jl:559"
        ]
      },
      {
        "name": "eye",
        "summary": "Function",
        "help": "Base.eye(n)\n\n   n-by-n identity matrix\n\nBase.eye(m, n)\n\n   m-by-n identity matrix\n\nBase.eye(A)\n\n   Constructs an identity matrix of the same dimensions and type as\n   \"A\".\n",
        "methods": 
        [
          "eye{T}(::Type{Diagonal{T}},n::Int64) at linalg/diagonal.jl:86",
          "eye(T::Type{T<:Top},m::Integer,n::Integer) at array.jl:176",
          "eye(m::Integer,n::Integer) at array.jl:182",
          "eye(T::Type{T<:Top},n::Integer) at array.jl:183",
          "eye(n::Integer) at array.jl:184",
          "eye(S::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:397",
          "eye{T}(x::AbstractArray{T,2}) at array.jl:185"
        ]
      },
      {
        "name": "factor",
        "summary": "Function",
        "help": "Base.factor(n) -> Dict\n\n   Compute the prime factorization of an integer \"n\". Returns a\n   dictionary. The keys of the dictionary correspond to the factors,\n   and hence are of the same type as \"n\". The value associated with\n   each key indicates the number of times the factor appears in the\n   factorization.\n\n   **Example**: 100=2*2*5*5; then:\n\n      julia> factor(100)\n      [5=>2,2=>2]\n",
        "methods": 
        [
          "factor{T<:Integer}(n::T<:Integer) at primes.jl:79"
        ]
      },
      {
        "name": "factorial",
        "summary": "Function",
        "help": "Base.factorial(n)\n\n   Factorial of n\n\nBase.factorial(n, k)\n\n   Compute \"factorial(n)/factorial(k)\"\n",
        "methods": 
        [
          "factorial(n::Int128) at combinatorics.jl:33",
          "factorial(n::Uint128) at combinatorics.jl:34",
          "factorial(n::Union(Uint64,Int64)) at combinatorics.jl:35",
          "factorial(n::Union(Uint16,Uint8,Uint32,Int8,Int16,Int32)) at combinatorics.jl:41",
          "factorial(x::BigInt) at gmp.jl:396",
          "factorial{T<:Integer}(n::T<:Integer,k::T<:Integer) at combinatorics.jl:56",
          "factorial(n::Integer) at combinatorics.jl:45",
          "factorial(x::BigFloat) at mpfr.jl:469"
        ]
      },
      {
        "name": "factorize",
        "summary": "Function",
        "help": "Base.factorize(A)\n\n   Compute a convenient factorization (including LU, Cholesky, Bunch-\n   Kaufman, Triangular) of A, based upon the type of the input matrix.\n   The return value can then be reused for efficient solving of\n   multiple systems. For example: \"A=factorize(A); x=A\\\\b;\n   y=A\\\\C\".\n",
        "methods": 
        [
          "factorize{T}(A::Array{T,2}) at linalg/dense.jl:333",
          "factorize(A::Tridiagonal{T}) at linalg/lu.jl:217",
          "factorize(A::Union(Symmetric{T},Hermitian{T})) at linalg/symmetric.jl:39",
          "factorize(A::SparseMatrixCSC{Tv,Ti<:Integer}) at linalg/cholmod.jl:1042"
        ]
      },
      {
        "name": "factorize!",
        "summary": "Function",
        "help": "Base.factorize!(A)\n\n   \"factorize!\" is the same as \"factorize()\", but saves space by\n   overwriting the input \"A\", instead of creating a copy.\n",
        "methods": 
        [
          "factorize!(A) at deprecated.jl:26"
        ]
      },
      {
        "name": "falses",
        "summary": "Function",
        "help": "Base.falses(dims)\n\n   Create a \"BitArray\" with all values set to false\n",
        "methods": 
        [
          "falses(args...) at bitarray.jl:227"
        ]
      },
      {
        "name": "fd",
        "summary": "Function",
        "help": "Base.fd(stream)\n\n   Returns the file descriptor backing the stream or file. Note that\n   this function only applies to synchronous *File*'s and *IOStream*'s\n   not to any of the asynchronous streams.\n",
        "methods": 
        [
          "fd(s::IOStream) at io.jl:264",
          "fd(f::File) at fs.jl:241"
        ]
      },
      {
        "name": "fdio",
        "summary": "Function",
        "help": "Base.fdio([name::String], fd::Integer[, own::Bool]) -> IOStream\n\n   Create an \"IOStream\" object from an integer file descriptor. If\n   \"own\" is true, closing this object will close the underlying\n   descriptor. By default, an \"IOStream\" is closed when it is\n   garbage collected. \"name\" allows you to associate the descriptor\n   with a named file.\n",
        "methods": 
        [
          "fdio(name::String,fd::Integer) at io.jl:340",
          "fdio(name::String,fd::Integer,own::Bool) at io.jl:340",
          "fdio(fd::Integer) at io.jl:345",
          "fdio(fd::Integer,own::Bool) at io.jl:345"
        ]
      },
      {
        "name": "fetch",
        "summary": "Function",
        "help": "Base.fetch(RemoteRef)\n\n   Wait for and get the value of a remote reference.\n\nBase.Profile.fetch() -> data\n\n   Returns a reference to the internal buffer of backtraces. Note that\n   subsequent operations, like \"Profile.clear()\", can affect\n   \"data\" unless you first make a copy. Note that the values in\n   \"data\" have meaning only on this machine in the current session,\n   because it depends on the exact memory addresses used in JIT-\n   compiling. This function is primarily for internal use;\n   \"Profile.retrieve()\" may be a better choice for most users.\n",
        "methods": 
        [
          "fetch(r::RemoteRef) at multi.jl:751",
          "fetch(x::ANY) at multi.jl:752"
        ]
      },
      {
        "name": "fft",
        "summary": "Function",
        "help": "Base.fft(A[, dims])\n\n   Performs a multidimensional FFT of the array \"A\".  The optional\n   \"dims\" argument specifies an iterable subset of dimensions (e.g.\n   an integer, range, tuple, or array) to transform along.  Most\n   efficient if the size of \"A\" along the transformed dimensions is\n   a product of small primes; see \"nextprod()\".  See also\n   \"plan_fft()\" for even greater efficiency.\n\n   A one-dimensional FFT computes the one-dimensional discrete Fourier\n   transform (DFT) as defined by\n\n      \\operatorname{DFT}(A)[k] =\n      \\sum_{n=1}^{\\operatorname{length}(A)}\n      \\exp\\left(-i\\frac{2\\pi\n      (n-1)(k-1)}{\\operatorname{length}(A)} \\right) A[n].\n\n   A multidimensional FFT simply performs this operation along each\n   transformed dimension of \"A\".\n",
        "methods": 
        [
          "fft{T<:Union(Complex{Float64},Complex{Float32})}(X::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),N},SubArray{T<:Union(Complex{Float64},Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),region) at fftw.jl:422",
          "fft{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region) at fftw.jl:438",
          "fft(X::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at fftw.jl:480",
          "fft(x::Number) at fftw.jl:681",
          "fft(x::Number,dims) at fftw.jl:690"
        ]
      },
      {
        "name": "fft!",
        "summary": "Function",
        "help": "Base.fft!(A[, dims])\n\n   Same as \"fft()\", but operates in-place on \"A\", which must be an\n   array of complex floating-point numbers.\n",
        "methods": 
        [
          "fft!{T<:Union(Complex{Float64},Complex{Float32})}(X::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),N},SubArray{T<:Union(Complex{Float64},Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),region) at fftw.jl:431",
          "fft!(X::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at fftw.jl:481"
        ]
      },
      {
        "name": "fftshift",
        "summary": "Function",
        "help": "Base.fftshift(x)\n\n   Swap the first and second halves of each dimension of \"x\".\n\nBase.fftshift(x, dim)\n\n   Swap the first and second halves of the given dimension of array\n   \"x\".\n",
        "methods": 
        [
          "fftshift(x) at dsp.jl:145",
          "fftshift(x,dim) at dsp.jl:148"
        ]
      },
      {
        "name": "fieldoffsets",
        "summary": "Function",
        "help": "Base.fieldoffsets(type)\n\n   The byte offset of each field of a type relative to the data start.\n   For example, we could use it in the following manner to summarize\n   information about a struct type:\n\n      structinfo(T) = [zip(fieldoffsets(T),names(T),T.types)...]\n      structinfo(StatStruct)\n",
        "methods": 
        [
          "fieldoffsets(x::DataType) at reflection.jl:45"
        ]
      },
      {
        "name": "filemode",
        "summary": "Function",
        "help": "Base.filemode(file)\n\n   Equivalent to stat(file).mode\n",
        "methods": 
        [
          "filemode(path...) at stat.jl:112"
        ]
      },
      {
        "name": "filesize",
        "summary": "Function",
        "help": "Base.filesize(path...)\n\n   Equivalent to stat(file).size\n",
        "methods": 
        [
          "filesize(path...) at stat.jl:113"
        ]
      },
      {
        "name": "fill",
        "summary": "Function",
        "help": "Base.fill(v, dims)\n\n   Create an array filled with \"v\"\n",
        "methods": 
        [
          "fill(gc::GraphicsContext)",
          "fill(v,dims::(Int64...,)) at array.jl:161",
          "fill(v,dims::Integer...) at array.jl:162"
        ]
      },
      {
        "name": "fill!",
        "summary": "Function",
        "help": "Base.fill!(A, x)\n\n   Fill array \"A\" with value \"x\"\n",
        "methods": 
        [
          "fill!{T<:Union(Uint8,Int8)}(a::Array{T<:Union(Uint8,Int8),N},x::Integer) at array.jl:146",
          "fill!{T<:Union(FloatingPoint,Integer)}(a::Array{T<:Union(FloatingPoint,Integer),N},x) at array.jl:151",
          "fill!(B::BitArray{N},x) at bitarray.jl:215",
          "fill!(S::SharedArray{T,N},v) at sharedarray.jl:220",
          "fill!{T}(A::AbstractArray{T,1},x) at multidimensional.jl:141",
          "fill!{T}(A::AbstractArray{T,2},x) at multidimensional.jl:141",
          "fill!{T}(A::AbstractArray{T,3},x) at multidimensional.jl:141",
          "fill!{T}(A::AbstractArray{T,4},x) at multidimensional.jl:141",
          "fill!{T,N}(A::AbstractArray{T,N},x) at cartesian.jl:100"
        ]
      },
      {
        "name": "filt",
        "summary": "Function",
        "help": "Base.filt(b, a, x)\n\n   Apply filter described by vectors \"a\" and \"b\" to vector \"x\".\n",
        "methods": 
        [
          "filt{T<:Number}(b::Union(AbstractArray{T<:Number,1},T<:Number),a::Union(AbstractArray{T<:Number,1},T<:Number),x::AbstractArray{T<:Number,1}) at dsp.jl:14"
        ]
      },
      {
        "name": "filter",
        "summary": "Function",
        "help": "Base.filter(function, collection)\n\n   Return a copy of \"collection\", removing elements for which\n   \"function\" is false. For associative collections, the function is\n   passed two arguments (key and value).\n",
        "methods": 
        [
          "filter(f::Function,a::Array{T,1}) at array.jl:1219",
          "filter(f::Function,Bs::BitArray{N}) at bitarray.jl:1468",
          "filter(f::Function,As::AbstractArray{T,N}) at array.jl:1204",
          "filter(f::Function,d::Associative{K,V}) at dict.jl:93",
          "filter(f::Function,s::Set{T}) at set.jl:119",
          "filter(f::Function,s::String) at string.jl:824",
          "filter(f::Function,s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:94",
          "filter{T}(f::Function,l::LinkedList{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:77",
          "filter(flt::Function,itr) at iterator.jl:68",
          "filter(r::Regex,d::Dict{K,V}) at regex.jl:243",
          "filter(r::Regex,v) at regex.jl:240"
        ]
      },
      {
        "name": "filter!",
        "summary": "Function",
        "help": "Base.filter!(function, collection)\n\n   Update \"collection\", removing elements for which \"function\" is\n   false. For associative collections, the function is passed two\n   arguments (key and value).\n",
        "methods": 
        [
          "filter!(f::Function,a::Array{T,1}) at array.jl:1207",
          "filter!(f::Function,d::Associative{K,V}) at dict.jl:86",
          "filter!(f::Function,s::Set{T}) at set.jl:111",
          "filter!(r::Regex,d::Dict{K,V}) at regex.jl:242",
          "filter!(r::Regex,v) at regex.jl:239",
          "filter!(f::Function,s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:87"
        ]
      },
      {
        "name": "finalizer",
        "summary": "Function",
        "help": "Base.finalizer(x, function)\n\n   Register a function \"f(x)\" to be called when there are no\n   program-accessible references to \"x\". The behavior of this\n   function is unpredictable if \"x\" is of a bits type.\n",
        "methods": 
        [
          "finalizer(o::ANY,f::Union(Ptr{T},Function)) at base.jl:116"
        ]
      },
      {
        "name": "find",
        "summary": "Function",
        "help": "Base.find(A)\n\n   Return a vector of the linear indexes of the non-zeros in \"A\"\n   (determined by \"A[i]!=0\").  A common use of this is to convert a\n   boolean array to an array of indexes of the \"true\" elements.\n\nBase.find(f, A)\n\n   Return a vector of the linear indexes of  \"A\" where \"f\" returns\n   true.\n",
        "methods": 
        [
          "find(testf::Function,A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:1047",
          "find(B::BitArray{N}) at bitarray.jl:1332",
          "find(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:1059",
          "find(x::Number) at array.jl:1071",
          "find(testf::Function,x) at array.jl:1072",
          "find(S::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:284"
        ]
      },
      {
        "name": "find_library",
        "summary": "Function",
        "help": "Base.find_library(names, locations)\n\n   Searches for the first library in \"names\" in the paths in the\n   \"locations\" list, \"DL_LOAD_PATH\", or system library paths (in\n   that order) which can successfully be dlopen'd. On success, the\n   return value will be one of the names (potentially prefixed by one\n   of the paths in locations). This string can be assigned to a\n   \"global const\" and used as the library name in future\n   \"ccall\"'s. On failure, it returns the empty string.\n",
        "methods": 
        [
          "find_library{T<:Union(UTF8String,ASCIIString)}(libnames::Array{T<:Union(UTF8String,ASCIIString),1}) at c.jl:81",
          "find_library{T<:Union(UTF8String,ASCIIString),S<:Union(UTF8String,ASCIIString)}(libnames::Array{T<:Union(UTF8String,ASCIIString),1},extrapaths::Array{S<:Union(UTF8String,ASCIIString),1}) at c.jl:81",
          "find_library(pkg,libname,files) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:11"
        ]
      },
      {
        "name": "findfirst",
        "summary": "Function",
        "help": "Base.findfirst(A)\n\n   Return the index of the first non-zero value in \"A\" (determined\n   by \"A[i]!=0\").\n\nBase.findfirst(A, v)\n\n   Return the index of the first element equal to \"v\" in \"A\".\n\nBase.findfirst(predicate, A)\n\n   Return the index of the first element of \"A\" for which\n   \"predicate\" returns true.\n",
        "methods": 
        [
          "findfirst(testf::Function,A) at array.jl:1042",
          "findfirst(A) at array.jl:1020",
          "findfirst(A,v) at array.jl:1031"
        ]
      },
      {
        "name": "findin",
        "summary": "Function",
        "help": "Base.findin(a, b)\n\n   Returns the indices of elements in collection \"a\" that appear in\n   collection \"b\"\n",
        "methods": 
        [
          "findin{T1<:Integer,T2<:Integer}(r::UnitRange{T1<:Integer},span::UnitRange{T2<:Integer}) at range.jl:405",
          "findin{T1<:Integer,T2<:Integer}(r::Range{T1<:Integer},span::UnitRange{T2<:Integer}) at range.jl:410",
          "findin(a,b::UnitRange{T<:Real}) at array.jl:1155",
          "findin(a,b) at array.jl:1167"
        ]
      },
      {
        "name": "findmax",
        "summary": "Function",
        "help": "Base.findmax(itr) -> (x, index)\n\n   Returns the maximum element and its index.\n\nBase.findmax(A, dims) -> (maxval, index)\n\n   For an array input, returns the value and index of the maximum over\n   the given dimensions.\n",
        "methods": 
        [
          "findmax(a::BitArray{N}) at linalg/bitarray.jl:184",
          "findmax{T}(A::AbstractArray{T,N},region) at reducedim.jl:279",
          "findmax(a) at array.jl:1112"
        ]
      },
      {
        "name": "findmin",
        "summary": "Function",
        "help": "Base.findmin(itr) -> (x, index)\n\n   Returns the minimum element and its index.\n\nBase.findmin(A, dims) -> (minval, index)\n\n   For an array input, returns the value and index of the minimum over\n   the given dimensions.\n",
        "methods": 
        [
          "findmin(a::BitArray{N}) at linalg/bitarray.jl:197",
          "findmin{T}(A::AbstractArray{T,N},region) at reducedim.jl:273",
          "findmin(a) at array.jl:1128"
        ]
      },
      {
        "name": "findn",
        "summary": "Function",
        "help": "Base.findn(A)\n\n   Return a vector of indexes for each dimension giving the locations\n   of the non-zeros in \"A\" (determined by \"A[i]!=0\").\n",
        "methods": 
        [
          "findn(B::BitArray{1}) at multidimensional.jl:414",
          "findn(B::BitArray{2}) at multidimensional.jl:414",
          "findn(B::BitArray{3}) at multidimensional.jl:414",
          "findn(B::BitArray{4}) at multidimensional.jl:414",
          "findn{N}(B::BitArray{N}) at cartesian.jl:100",
          "findn(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at array.jl:1077",
          "findn{Tv,Ti}(S::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:290",
          "findn{T}(A::AbstractArray{T,1}) at multidimensional.jl:85",
          "findn(A::AbstractArray{T,1}) at array.jl:1074",
          "findn{T}(A::AbstractArray{T,2}) at multidimensional.jl:85",
          "findn{T}(A::AbstractArray{T,3}) at multidimensional.jl:85",
          "findn{T}(A::AbstractArray{T,4}) at multidimensional.jl:85",
          "findn{T,N}(A::AbstractArray{T,N}) at cartesian.jl:100"
        ]
      },
      {
        "name": "findn_nzs",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "findn_nzs(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "findnext",
        "summary": "Function",
        "help": "Base.findnext(A, i)\n\n   Find the next index >= \"i\" of a non-zero element of \"A\", or\n   \"0\" if not found.\n\nBase.findnext(predicate, A, i)\n\n   Find the next index >= \"i\" of an element of \"A\" for which\n   \"predicate\" returns true, or \"0\" if not found.\n\nBase.findnext(A, v, i)\n\n   Find the next index >= \"i\" of an element of \"A\" equal to \"v\"\n   (using \"==\"), or \"0\" if not found.\n",
        "methods": 
        [
          "findnext(B::BitArray{N},start::Integer) at bitarray.jl:1255",
          "findnext(A,start::Integer) at array.jl:1013",
          "findnext(testf::Function,B::BitArray{N},start::Integer) at bitarray.jl:1321",
          "findnext(testf::Function,A,start::Integer) at array.jl:1035",
          "findnext(B::BitArray{N},v,start::Integer) at bitarray.jl:1313",
          "findnext(A,v,start::Integer) at array.jl:1024"
        ]
      },
      {
        "name": "findnz",
        "summary": "Function",
        "help": "Base.findnz(A)\n\n   Return a tuple \"(I, J, V)\" where \"I\" and \"J\" are the row and\n   column indexes of the non-zero values in matrix \"A\", and \"V\" is\n   a vector of the non-zero values.\n",
        "methods": 
        [
          "findnz(B::BitArray{2}) at bitarray.jl:1382",
          "findnz{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at array.jl:1092",
          "findnz{Tv,Ti}(S::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:313",
          "findnz{Tv,Ti}(A::CholmodSparse{Tv,Ti}) at linalg/cholmod.jl:948",
          "findnz(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:969"
        ]
      },
      {
        "name": "finfer",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "finfer(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "first",
        "summary": "Function",
        "help": "Base.first(coll)\n\n   Get the first element of an iterable collection.\n",
        "methods": 
        [
          "first{T}(r::OrdinalRange{T,S}) at range.jl:194",
          "first(r::FloatRange{T<:FloatingPoint}) at range.jl:195",
          "first(x::Number) at number.jl:18",
          "first(a::AbstractArray{T,N}) at abstractarray.jl:25",
          "first(s::IntSet) at intset.jl:145",
          "first(a) at abstractarray.jl:26"
        ]
      },
      {
        "name": "fld",
        "summary": "Function",
        "help": "Base.fld(a, b)\n\n   Largest integer less than or equal to a/b\n",
        "methods": 
        [
          "fld(x::Bool,y::Bool) at bool.jl:58",
          "fld(x::Signed,y::Unsigned) at int.jl:85",
          "fld(x::Unsigned,y::Signed) at int.jl:86",
          "fld{T<:Unsigned}(x::T<:Unsigned,y::T<:Unsigned) at int.jl:105",
          "fld(x::BigInt,y::BigInt) at gmp.jl:193",
          "fld{T<:Integer}(x::T<:Integer,y::T<:Integer) at int.jl:106",
          "fld(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:152",
          "fld(x::Rational{T<:Integer},y::Real) at rational.jl:153",
          "fld(x::Real,y::Rational{T<:Integer}) at rational.jl:154",
          "fld{T<:Real}(x::T<:Real,y::T<:Real) at operators.jl:119",
          "fld(x::Real,y::Real) at promotion.jl:173"
        ]
      },
      {
        "name": "flipbits!",
        "summary": "Function",
        "help": "Base.flipbits!(B::BitArray{N}) -> BitArray{N}\n\n   Performs a bitwise not operation on B. See *~ operator*.\n",
        "methods": 
        [
          "flipbits!(B::BitArray{N}) at bitarray.jl:836"
        ]
      },
      {
        "name": "flipdim",
        "summary": "Function",
        "help": "Base.flipdim(A, d)\n\n   Reverse \"A\" in dimension \"d\".\n",
        "methods": 
        [
          "flipdim{T}(A::Array{T,N},d::Integer) at array.jl:869",
          "flipdim(A::BitArray{N},d::Integer) at bitarray.jl:1106",
          "flipdim(A::AbstractArray{T,1},d::Integer) at abstractarray.jl:377",
          "flipdim(A::AbstractArray{T,N},d::Integer) at abstractarray.jl:383"
        ]
      },
      {
        "name": "fliplr",
        "summary": "Function",
        "help": "Base.fliplr(A)\n\n   Equivalent to \"flipdim(A,2)\".\n",
        "methods": 
        [
          "fliplr(A::AbstractArray{T,N}) at abstractarray.jl:408"
        ]
      },
      {
        "name": "flipsign",
        "summary": "Function",
        "help": "Base.flipsign(x, y)\n\n   Return \"x\" with its sign flipped if \"y\" is negative. For\n   example \"abs(x) = flipsign(x,x)\".\n",
        "methods": 
        [
          "flipsign(x::Int64,y::Int64) at int.jl:60",
          "flipsign(x::Int128,y::Int128) at int.jl:61",
          "flipsign{T<:Signed}(x::T<:Signed,y::T<:Signed) at int.jl:63",
          "flipsign(x::Signed,y::Signed) at int.jl:64",
          "flipsign(x::Signed,y::Float32) at int.jl:65",
          "flipsign(x::Signed,y::Float64) at int.jl:66",
          "flipsign(x::Signed,y::Real) at int.jl:67",
          "flipsign(x::Float64,y::Float64) at floatfuncs.jl:9",
          "flipsign(x::Float32,y::Float32) at floatfuncs.jl:10",
          "flipsign(x::Float32,y::Real) at floatfuncs.jl:11",
          "flipsign(x::Float64,y::Real) at floatfuncs.jl:12",
          "flipsign{T1<:Real,T2<:Real}(::T1<:Real,::AbstractArray{T2<:Real,N}) at operators.jl:365",
          "flipsign{T1<:Real,T2<:Real}(::AbstractArray{T1<:Real,N},::T2<:Real) at operators.jl:367",
          "flipsign{T1<:Real,T2<:Real}(::AbstractArray{T1<:Real,N},::AbstractArray{T2<:Real,N}) at operators.jl:371"
        ]
      },
      {
        "name": "flipud",
        "summary": "Function",
        "help": "Base.flipud(A)\n\n   Equivalent to \"flipdim(A,1)\".\n",
        "methods": 
        [
          "flipud(A::AbstractArray{T,N}) at abstractarray.jl:407"
        ]
      },
      {
        "name": "float",
        "summary": "Function",
        "help": "Base.float(x)\n\n   Convert a number, array, or string to a \"FloatingPoint\" data\n   type. For numeric data, the smallest suitable \"FloatingPoint\"\n   type is used. For strings, it converts to \"Float64\".\n",
        "methods": 
        [
          "float(z::Complex{T<:Real}) at complex.jl:60",
          "float(r::StepRange{T,S}) at abstractarray.jl:327",
          "float(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "float(r::FloatRange{T<:FloatingPoint}) at abstractarray.jl:334",
          "float(S::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:176",
          "float{T<:FloatingPoint}(x::AbstractArray{T<:FloatingPoint,N}) at abstractarray.jl:315",
          "float{S<:String}(a::AbstractArray{S<:String,N}) at string.jl:1603",
          "float(A::AbstractArray{T,N}) at abstractarray.jl:318",
          "float(x::String) at string.jl:1595",
          "float(x) at float.jl:56"
        ]
      },
      {
        "name": "float16",
        "summary": "Function",
        "help": "Base.float16(x)\n\n   Convert a number or array to \"Float16\" data type\n",
        "methods": 
        [
          "float16(z::Complex{T<:Real}) at complex.jl:60",
          "float16(r::StepRange{T,S}) at abstractarray.jl:327",
          "float16(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "float16(r::FloatRange{T<:FloatingPoint}) at abstractarray.jl:334",
          "float16{S,N}(x::AbstractArray{S,N}) at abstractarray.jl:312",
          "float16(x) at float.jl:53"
        ]
      },
      {
        "name": "float32",
        "summary": "Function",
        "help": "Base.float32(x)\n\n   Convert a number or array to \"Float32\" data type\n",
        "methods": 
        [
          "float32(z::Complex{T<:Real}) at complex.jl:60",
          "float32(r::StepRange{T,S}) at abstractarray.jl:327",
          "float32(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "float32(r::FloatRange{T<:FloatingPoint}) at abstractarray.jl:334",
          "float32{S<:String}(a::AbstractArray{S<:String,N}) at string.jl:1603",
          "float32{S,N}(x::AbstractArray{S,N}) at abstractarray.jl:312",
          "float32(s::String) at string.jl:1588",
          "float32(x) at float.jl:54"
        ]
      },
      {
        "name": "float32_isvalid",
        "summary": "Function",
        "help": "Base.float32_isvalid(x, out::Vector{Float32}) -> Bool\n\n   Convert a number or array to \"Float32\" data type, returning true\n   if successful. The result of the conversion is stored in\n   \"out[1]\".\n",
        "methods": 
        [
          "float32_isvalid(s::SubString{T<:String},out::Array{Float32,1}) at string.jl:1573",
          "float32_isvalid(s::String,out::Array{Float32,1}) at string.jl:1568"
        ]
      },
      {
        "name": "float64",
        "summary": "Function",
        "help": "Base.float64(x)\n\n   Convert a number or array to \"Float64\" data type\n",
        "methods": 
        [
          "float64(z::Complex{T<:Real}) at complex.jl:60",
          "float64(r::StepRange{T,S}) at abstractarray.jl:327",
          "float64(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "float64(r::FloatRange{T<:FloatingPoint}) at abstractarray.jl:334",
          "float64{S<:String}(a::AbstractArray{S<:String,N}) at string.jl:1603",
          "float64{S,N}(x::AbstractArray{S,N}) at abstractarray.jl:312",
          "float64(s::String) at string.jl:1581",
          "float64(x) at float.jl:55"
        ]
      },
      {
        "name": "float64_isvalid",
        "summary": "Function",
        "help": "Base.float64_isvalid(x, out::Vector{Float64}) -> Bool\n\n   Convert a number or array to \"Float64\" data type, returning true\n   if successful. The result of the conversion is stored in\n   \"out[1]\".\n",
        "methods": 
        [
          "float64_isvalid(s::SubString{T<:String},out::Array{Float64,1}) at string.jl:1571",
          "float64_isvalid(s::String,out::Array{Float64,1}) at string.jl:1566"
        ]
      },
      {
        "name": "floor",
        "summary": "Function",
        "help": "Base.floor(x[, digits[, base]])\n\n   Returns the nearest integral value of the same type as \"x\" not\n   greater than \"x\". \"digits\" and \"base\" work as above.\n",
        "methods": 
        [
          "floor(x::Integer) at int.jl:370",
          "floor(x::Float64) at float.jl:108",
          "floor(x::Rational{T<:Integer}) at rational.jl:162",
          "floor(x::Float32) at math.jl:300",
          "floor{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "floor{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "floor{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "floor{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "floor(x::Float16) at float16.jl:103",
          "floor(x::BigFloat) at mpfr.jl:639",
          "floor(x,digits::Integer) at floatfuncs.jl:85",
          "floor(x,digits::Integer,base::Integer) at floatfuncs.jl:85"
        ]
      },
      {
        "name": "flush",
        "summary": "Function",
        "help": "Base.flush(stream)\n\n   Commit all currently buffered writes to the given stream.\n",
        "methods": 
        [
          "flush(s::IOStream) at io.jl:268",
          "flush(::AsyncStream) at stream.jl:273",
          "flush(d::TextDisplay) at multimedia.jl:121",
          "flush(t::TextTerminal) at Terminals.jl:94"
        ]
      },
      {
        "name": "flush_cstdio",
        "summary": "Function",
        "help": "Base.flush_cstdio()\n\n   Flushes the C \"stdout\" and \"stderr\" streams (which may have\n   been written to by external C code).\n",
        "methods": 
        [
          "flush_cstdio() at c.jl:78"
        ]
      },
      {
        "name": "foldl",
        "summary": "Function",
        "help": "Base.foldl(op, v0, itr)\n\n   Like \"reduce\", but with guaranteed left associativity.\n\nBase.foldl(op, itr)\n\n   Like \"foldl\", but using the first element as v0.\n",
        "methods": 
        [
          "foldl(op::Union(DataType,Function),v0,itr,i) at reduce.jl:57",
          "foldl(op::Union(DataType,Function),v0,itr) at reduce.jl:64",
          "foldl(op::Union(DataType,Function),itr) at reduce.jl:67"
        ]
      },
      {
        "name": "foldr",
        "summary": "Function",
        "help": "Base.foldr(op, v0, itr)\n\n   Like \"reduce\", but with guaranteed right associativity.\n\nBase.foldr(op, itr)\n\n   Like \"foldr\", but using the last element as v0.\n",
        "methods": 
        [
          "foldr(op::Union(DataType,Function),v0,itr) at reduce.jl:77",
          "foldr(op::Union(DataType,Function),v0,itr,i) at reduce.jl:77",
          "foldr(op::Union(DataType,Function),itr) at reduce.jl:89"
        ]
      },
      {
        "name": "frexp",
        "summary": "Function",
        "help": "Base.frexp(val)\n\n   Return \"(x,exp)\" such that \"x\" has a magnitude in the interval\n   \"[1/2, 1)\" or 0, and val = x \\times 2^{exp}.\n",
        "methods": 
        [
          "frexp(x::Float64) at math.jl:386",
          "frexp(x::Float32) at math.jl:390",
          "frexp(A::Array{Float64,N}) at math.jl:394",
          "frexp(A::Array{Float32,N}) at math.jl:403"
        ]
      },
      {
        "name": "full",
        "summary": "Function",
        "help": "Base.full(S)\n\n   Convert a sparse matrix \"S\" into a dense matrix.\n",
        "methods": 
        [
          "full{Tv}(S::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:169",
          "full{T}(M::SymTridiagonal{T}) at linalg/tridiag.jl:21",
          "full{T}(M::Tridiagonal{T}) at linalg/tridiag.jl:163",
          "full{T}(A::Union(QRCompactWYQ{T},QRPackedQ{T})) at linalg/factorization.jl:238",
          "full(A::HessenbergQ{T}) at linalg/factorization.jl:494",
          "full(A::Triangular{T<:Number}) at linalg/triangular.jl:91",
          "full(A::Symmetric{T}) at linalg/symmetric.jl:18",
          "full(A::Hermitian{T}) at linalg/symmetric.jl:19",
          "full{T}(W::Woodbury{T}) at linalg/woodbury.jl:56",
          "full(D::Diagonal{T}) at linalg/diagonal.jl:22",
          "full{T}(M::Bidiagonal{T}) at linalg/bidiag.jl:30",
          "full(A::TriangularRFP{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/rectfullpacked.jl:22",
          "full(x::AbstractArray{T,N}) at abstractarray.jl:321",
          "full{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(C::Cholesky{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/factorization.jl:52",
          "full(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:1023",
          "full(A::CholmodDense{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/cholmod.jl:1024"
        ]
      },
      {
        "name": "fullname",
        "summary": "Function",
        "help": "Base.fullname(m::Module)\n\n   Get the fully-qualified name of a module as a tuple of symbols. For\n   example, \"fullname(Base.Pkg)\" gives \"(:Base,:Pkg)\", and\n   \"fullname(Main)\" gives \"()\".\n",
        "methods": 
        [
          "fullname(m::Module) at reflection.jl:6"
        ]
      },
      {
        "name": "function_loc",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "function_loc(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "functionloc",
        "summary": "Function",
        "help": "Base.functionloc(f::Function, types)\n\n   Returns a tuple \"(filename,line)\" giving the location of a method\n   definition.\n",
        "methods": 
        [
          "functionloc(f::Union(DataType,Function)) at reflection.jl:157",
          "functionloc(f::Union(DataType,Function),types) at reflection.jl:157"
        ]
      },
      {
        "name": "functionlocs",
        "summary": "Function",
        "help": "Base.functionlocs(f::Function, types)\n\n   Returns an array of the results of \"functionloc\" for all matching\n   definitions.\n",
        "methods": 
        [
          "functionlocs(f::Union(DataType,Function)) at reflection.jl:143",
          "functionlocs(f::Union(DataType,Function),types) at reflection.jl:143"
        ]
      },
      {
        "name": "gamma",
        "summary": "Function",
        "help": "Base.gamma(x)\n\n   Compute the gamma function of \"x\"\n",
        "methods": 
        [
          "gamma(x::Float64) at math.jl:334",
          "gamma(x::Float32) at math.jl:335",
          "gamma(x::BigFloat) at mpfr.jl:547",
          "gamma(x::Real) at math.jl:336",
          "gamma{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "gamma{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "gamma{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357",
          "gamma(z::Complex{T<:Real}) at math.jl:757"
        ]
      },
      {
        "name": "gc",
        "summary": "Function",
        "help": "Base.gc()\n\n   Perform garbage collection. This should not generally be used.\n",
        "methods": 
        [
          "gc() at base.jl:122"
        ]
      },
      {
        "name": "gc_disable",
        "summary": "Function",
        "help": "Base.gc_disable()\n\n   Disable garbage collection. This should be used only with extreme\n   caution, as it can cause memory use to grow without bound.\n",
        "methods": 
        [
          "gc_disable() at base.jl:124"
        ]
      },
      {
        "name": "gc_enable",
        "summary": "Function",
        "help": "Base.gc_enable()\n\n   Re-enable garbage collection after calling \"gc_disable\".\n",
        "methods": 
        [
          "gc_enable() at base.jl:123"
        ]
      },
      {
        "name": "gcd",
        "summary": "Function",
        "help": "Base.gcd(x, y)\n\n   Greatest common (positive) divisor (or zero if x and y are both\n   zero).\n",
        "methods": 
        [
          "gcd(x::BigInt,y::BigInt) at gmp.jl:193",
          "gcd{T<:Integer}(a::T<:Integer,b::T<:Integer) at intfuncs.jl:4",
          "gcd(a::Integer) at intfuncs.jl:15",
          "gcd(a::Integer,b::Integer) at intfuncs.jl:17",
          "gcd(a::Integer,b::Integer...) at intfuncs.jl:19",
          "gcd{T<:Integer}(abc::AbstractArray{T<:Integer,N}) at intfuncs.jl:22"
        ]
      },
      {
        "name": "gcdx",
        "summary": "Function",
        "help": "Base.gcdx(x, y)\n\n   Greatest common (positive) divisor, also returning integer\n   coefficients \"u\" and \"v\" that solve \"ux+vy == gcd(x,y)\"\n",
        "methods": 
        [
          "gcdx(a::BigInt,b::BigInt) at gmp.jl:365",
          "gcdx{T<:Integer}(a::T<:Integer,b::T<:Integer) at intfuncs.jl:27",
          "gcdx(a::Integer,b::Integer) at intfuncs.jl:37"
        ]
      },
      {
        "name": "gensym",
        "summary": "Function",
        "help": "Base.gensym([tag])\n\n   Generates a symbol which will not conflict with other variable\n   names.\n",
        "methods": 
        [
          "gensym() at expr.jl:10",
          "gensym(s::ASCIIString) at expr.jl:12",
          "gensym(s::UTF8String) at expr.jl:13",
          "gensym(a::Array{Uint8,1}) at expr.jl:14",
          "gensym(ss::Union(UTF8String,ASCIIString)...) at expr.jl:16"
        ]
      },
      {
        "name": "get",
        "summary": "Function",
        "help": "Base.get(collection, key, default)\n\n   Return the value stored for the given key, or the given default\n   value if no mapping for the key is present.\n\nBase.get(f::Function, collection, key)\n\n   Return the value stored for the given key, or if no mapping for the\n   key is present, return \"f()\".  Use \"get!\" to also store the\n   default value in the dictionary.\n\n   This is intended to be called using \"do\" block syntax:\n\n      get(dict, key) do\n          # default value calculated here\n          time()\n      end\n",
        "methods": 
        [
          "get(A::AbstractArray{T,N},i::Integer,default) at abstractarray.jl:464",
          "get(A::AbstractArray{T,N},I::(),default) at abstractarray.jl:465",
          "get(A::AbstractArray{T,N},I::(Int64...,),default) at abstractarray.jl:466",
          "get(A::AbstractArray{T,N},I::Range{T},default) at abstractarray.jl:476",
          "get(A::Array{T,N},B::Array{T,N},I,default) at deprecated.jl:26",
          "get(A::AbstractArray{T,N},I::Union(AbstractArray{Range{Int64},1},AbstractArray{UnitRange{Int64},1},AbstractArray{A<:AbstractArray{Int64,1},1},(Union(Range{T},AbstractArray{Int64,1})...,)),default) at abstractarray.jl:485",
          "get(t::ObjectIdDict,key::ANY,default::ANY) at dict.jl:172",
          "get{K,V}(h::Dict{K,V},key,deflt) at dict.jl:518",
          "get{K,V}(deflt::Function,h::Dict{K,V},key) at dict.jl:523",
          "get{K}(wkh::WeakKeyDict{K,V},key,def) at dict.jl:637",
          "get{K}(def::Function,wkh::WeakKeyDict{K,V},key) at dict.jl:638",
          "get(::EnvHash,k::String,def) at env.jl:76",
          "get{K,V}(pq::PriorityQueue{K,V},key,deflt) at collections.jl:213",
          "get{K,V}(h::HashDict{K,V,O<:Union(Nothing,Int64)},key,deflt) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:416",
          "get(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "get(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "get(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "get(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "get(t::Trie{T},key::String,notfound) at /home/samuel/.julia/v0.3/DataStructures/src/trie.jl:54",
          "get(uri::URI,data::String) at /home/samuel/.julia/v0.3/Requests/src/Requests.jl:570",
          "get(uri::String) at /home/samuel/.julia/v0.3/Requests/src/Requests.jl:575",
          "get(uri::URI) at /home/samuel/.julia/v0.3/Requests/src/Requests.jl:576"
        ]
      },
      {
        "name": "get!",
        "summary": "Function",
        "help": "Base.get!(collection, key, default)\n\n   Return the value stored for the given key, or if no mapping for the\n   key is present, store \"key => default\", and return \"default\".\n\nBase.get!(f::Function, collection, key)\n\n   Return the value stored for the given key, or if no mapping for the\n   key is present, store \"key => f()\", and return \"f()\".\n\n   This is intended to be called using \"do\" block syntax:\n\n      get!(dict, key) do\n          # default value calculated here\n          time()\n      end\n",
        "methods": 
        [
          "get!{T}(X::AbstractArray{T,N},A::AbstractArray{T,N},I::Union(Range{T},AbstractArray{Int64,1}),default::T) at abstractarray.jl:469",
          "get!{T}(X::AbstractArray{T,N},A::AbstractArray{T,N},I::Union(AbstractArray{Range{Int64},1},AbstractArray{UnitRange{Int64},1},AbstractArray{A<:AbstractArray{Int64,1},1},(Union(Range{T},AbstractArray{Int64,1})...,)),default::T) at abstractarray.jl:479",
          "get!{K,V}(h::Dict{K,V},key0,default) at dict.jl:463",
          "get!{K,V}(default::Function,h::Dict{K,V},key0) at dict.jl:478",
          "get!{K}(wkh::WeakKeyDict{K,V},key,def) at dict.jl:639",
          "get!{K}(def::Function,wkh::WeakKeyDict{K,V},key) at dict.jl:640",
          "get!{K,V,F<:Union(DataType,Function)}(h::HashDict{K,V,O<:Union(Nothing,Int64)},key0,default::F<:Union(DataType,Function)) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:396",
          "get!{K,V}(h::HashDict{K,V,O<:Union(Nothing,Int64)},key0,default) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:380",
          "get!(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "get!(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "get!(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11"
        ]
      },
      {
        "name": "get_bigfloat_precision",
        "summary": "Function",
        "help": "Base.get_bigfloat_precision()\n\n   Get the precision (in bits) currently used for BigFloat arithmetic.\n",
        "methods": 
        [
          "get_bigfloat_precision() at mpfr.jl:589"
        ]
      },
      {
        "name": "get_bigfloat_rounding",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "get_bigfloat_rounding() at deprecated.jl:26"
        ]
      },
      {
        "name": "get_precision",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "get_precision(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "get_rounding",
        "summary": "Function",
        "help": "Base.get_rounding(T)\n\n   Get the current floating point rounding mode for type \"T\". Valid\n   modes are \"RoundNearest\", \"RoundToZero\", \"RoundUp\",\n   \"RoundDown\", and \"RoundFromZero\" (\"BigFloat\" only).\n",
        "methods": 
        [
          "get_rounding{T<:Union(Float64,Float32)}(::Type{T<:Union(Float64,Float32)}) at rounding.jl:50",
          "get_rounding(::Type{BigFloat}) at mpfr.jl:615",
          "get_rounding() at deprecated.jl:26"
        ]
      },
      {
        "name": "getaddrinfo",
        "summary": "Function",
        "help": "Base.getaddrinfo(host)\n\n   Gets the IP address of the \"host\" (may have to do a DNS lookup)\n",
        "methods": 
        [
          "getaddrinfo(cb::Function,host::ASCIIString) at socket.jl:527",
          "getaddrinfo(cb::Function,host::String) at socket.jl:531",
          "getaddrinfo(host::ASCIIString) at socket.jl:534",
          "getaddrinfo(host::String) at socket.jl:542"
        ]
      },
      {
        "name": "gethostname",
        "summary": "Function",
        "help": "Base.gethostname() -> String\n\n   Get the local machine's host name.\n",
        "methods": 
        [
          "gethostname() at libc.jl:79"
        ]
      },
      {
        "name": "getindex",
        "summary": "Function",
        "help": "Base.getindex(collection, key...)\n\n   Retrieve the value(s) stored at the given key or index within a\n   collection. The syntax \"a[i,j,...]\" is converted by the compiler\n   to \"getindex(a, i, j, ...)\".\n\nBase.getindex(type[, elements...])\n\n   Construct a 1-d array of the specified type. This is usually called\n   with the syntax \"Type[]\". Element values can be specified using\n   \"Type[a,b,c,...]\".\n\nBase.getindex(A, inds...)\n\n   Returns a subset of array \"A\" as specified by \"inds\", where\n   each \"ind\" may be an \"Int\", a \"Range\", or a \"Vector\".\n",
        "methods": 
        [
          "getindex(T::(Type{T<:Top}...,)) at array.jl:126",
          "getindex(t::(Any...,),i::Int64) at tuple.jl:6",
          "getindex(t::(Any...,),i::Real) at tuple.jl:7",
          "getindex(t::(Any...,),b::AbstractArray{Bool,N}) at tuple.jl:9",
          "getindex(t::(Any...,),r::AbstractArray{T,N}) at tuple.jl:8",
          "getindex{T}(r::FloatRange{T},i::Integer) at range.jl:239",
          "getindex(r::CalendarTimeRange{T<:AbstractCalendarDuration},i::Integer) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:397",
          "getindex{T}(r::Range{T},i::Integer) at range.jl:235",
          "getindex(r::Range{T},i::Real) at range.jl:232",
          "getindex(r::UnitRange{T<:Real},s::UnitRange{Int64}) at range.jl:244",
          "getindex(r::StepRange{T,S},s::Range{Int64}) at range.jl:257",
          "getindex(r::FloatRange{T<:FloatingPoint},s::UnitRange{T<:Real}) at range.jl:269",
          "getindex(x::Number) at number.jl:14",
          "getindex(x::Number,i::Integer) at number.jl:15",
          "getindex(x::Number,I::Integer...) at number.jl:16",
          "getindex(x::Number,I::Real...) at number.jl:17",
          "getindex{T}(s::SubArray{T,0,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)}) at subarray.jl:191",
          "getindex{T}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer) at subarray.jl:193",
          "getindex{T}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer,j::Integer) at subarray.jl:195",
          "getindex{T}(s::SubArray{T,2,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer,j::Integer) at subarray.jl:197",
          "getindex{T}(s::SubArray{T,3,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer,j::Integer,k::Integer) at subarray.jl:199",
          "getindex{T}(s::SubArray{T,4,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer,j::Integer,k::Integer,l::Integer) at subarray.jl:201",
          "getindex{T}(s::SubArray{T,5,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer,j::Integer,k::Integer,l::Integer,m::Integer) at subarray.jl:203",
          "getindex{T}(s::SubArray{T,2,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},ind::Integer) at multidimensional.jl:104",
          "getindex{T}(s::SubArray{T,3,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},ind::Integer) at multidimensional.jl:104",
          "getindex{T}(s::SubArray{T,4,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},ind::Integer) at multidimensional.jl:104",
          "getindex{T}(s::SubArray{T,5,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},ind::Integer) at multidimensional.jl:104",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer) at subarray.jl:220",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},is::Integer...) at subarray.jl:223",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Real) at subarray.jl:206",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i0::Real,i1::Real) at subarray.jl:207",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i0::Real,i1::Real,i2::Real) at subarray.jl:209",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i0::Real,i1::Real,i2::Real,i3::Real) at subarray.jl:211",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i0::Real,i1::Real,i2::Real,i3::Real,i4::Real) at subarray.jl:213",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i0::Real,i1::Real,i2::Real,i3::Real,i4::Real,i5::Real) at subarray.jl:215",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i0::Real,i1::Real,i2::Real,i3::Real,i4::Real,i5::Real,is::Real...) at subarray.jl:217",
          "getindex(A::Array{T,1},I::AbstractArray{Bool,1}) at array.jl:298",
          "getindex(A::Array{T,1},I::AbstractArray{Bool,N}) at array.jl:299",
          "getindex(a::Array{T,N}) at array.jl:244",
          "getindex(A::Array{T,N},i0::Real) at array.jl:246",
          "getindex(A::Array{T,N},i0::Real,i1::Real) at array.jl:247",
          "getindex(A::Array{T,N},i0::Real,i1::Real,i2::Real) at array.jl:248",
          "getindex(A::Array{T,N},i0::Real,i1::Real,i2::Real,i3::Real) at array.jl:250",
          "getindex(A::Array{T,N},i0::Real,i1::Real,i2::Real,i3::Real,i4::Real) at array.jl:252",
          "getindex(A::Array{T,N},i0::Real,i1::Real,i2::Real,i3::Real,i4::Real,i5::Real) at array.jl:254",
          "getindex(A::Array{T,N},i0::Real,i1::Real,i2::Real,i3::Real,i4::Real,i5::Real,I::Real...) at array.jl:257",
          "getindex(B::BitArray{0}) at bitarray.jl:358",
          "getindex(B::BitArray{N},i::Int64) at bitarray.jl:349",
          "getindex(B::BitArray{N},I_0::Int64,I_1::Int64) at multidimensional.jl:178",
          "getindex(B::BitArray{N},I_0::Int64,I_1::Int64,I_2::Int64) at multidimensional.jl:178",
          "getindex(B::BitArray{N},I_0::Int64,I_1::Int64,I_2::Int64,I_3::Int64) at multidimensional.jl:178",
          "getindex(B::BitArray{N},I_0::Int64,I_1::Int64,I_2::Int64,I_3::Int64,I_4::Int64) at multidimensional.jl:178",
          "getindex(B::BitArray{N},I_0::Int64,I::Int64...) at cartesian.jl:100",
          "getindex(B::BitArray{N},i::Real) at bitarray.jl:353",
          "getindex(B::BitArray{N}) at bitarray.jl:355",
          "getindex(d::DArray{T,N,A},i::Int64) at darray.jl:234",
          "getindex(d::DArray{T,N,A}) at darray.jl:245",
          "getindex(d::DArray{T,N,A},i::Int64...) at darray.jl:235",
          "getindex(d::DArray{T,N,A},I::Union(UnitRange{Int64},Int64)...) at darray.jl:246",
          "getindex(S::SharedArray{T,N}) at sharedarray.jl:209",
          "getindex(S::SharedArray{T,N},I::Real) at sharedarray.jl:210",
          "getindex(A::SparseMatrixCSC{Tv,Ti<:Integer},i::Integer) at sparse/sparsematrix.jl:715",
          "getindex{T}(A::SparseMatrixCSC{T,Ti<:Integer},i0::Integer,i1::Integer) at sparse/sparsematrix.jl:718",
          "getindex(A::SparseMatrixCSC{Tv,Ti<:Integer},I::Integer,J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1026",
          "getindex{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},i::Integer,J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:736",
          "getindex{T}(A::SymTridiagonal{T},i::Integer,j::Integer) at linalg/tridiag.jl:138",
          "getindex{T}(A::Tridiagonal{T},i::Integer,j::Integer) at linalg/tridiag.jl:197",
          "getindex{T}(A::Triangular{T},i::Integer,j::Integer) at linalg/triangular.jl:93",
          "getindex(A::Symmetric{T},i::Integer,j::Integer) at linalg/symmetric.jl:16",
          "getindex(A::Hermitian{T},i::Integer,j::Integer) at linalg/symmetric.jl:17",
          "getindex(D::Diagonal{T},i::Integer,j::Integer) at linalg/diagonal.jl:23",
          "getindex(D::Diagonal{T},i::Integer) at linalg/diagonal.jl:26",
          "getindex{T}(A::Bidiagonal{T},i::Integer,j::Integer) at linalg/bidiag.jl:25",
          "getindex(G::Givens{T},i::Integer,j::Integer) at linalg/givens.jl:204",
          "getindex(t::AbstractArray{T,N},i::Real) at abstractarray.jl:360",
          "getindex{T}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::UnitRange{Int64}) at subarray.jl:252",
          "getindex{T}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::Range{Int64}) at subarray.jl:255",
          "getindex{T}(S::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::AbstractArray{Bool,1}) at subarray.jl:246",
          "getindex{T}(S::SubArray{T,2,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::AbstractArray{Bool,2}) at subarray.jl:247",
          "getindex{T}(S::SubArray{T,3,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::AbstractArray{Bool,3}) at subarray.jl:248",
          "getindex{T}(S::SubArray{T,4,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::AbstractArray{Bool,4}) at subarray.jl:249",
          "getindex{T}(S::SubArray{T,5,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::AbstractArray{Bool,5}) at subarray.jl:250",
          "getindex{T,S<:Integer}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::AbstractArray{S<:Integer,1}) at subarray.jl:259",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::Union(AbstractArray{T,1},Real)...) at subarray.jl:334",
          "getindex(A::Array{T,N},I::UnitRange{Int64}) at array.jl:262",
          "getindex(A::Array{T,N},I::AbstractArray{Bool,1}) at array.jl:300",
          "getindex{T<:Real}(A::Array{T,N},I::AbstractArray{T<:Real,1}) at array.jl:271",
          "getindex(A::Range{T},I::AbstractArray{Bool,1}) at array.jl:277",
          "getindex{T<:Real}(A::Range{T},I::AbstractArray{T<:Real,1}) at array.jl:274",
          "getindex(A::Array{T,N},I::AbstractArray{Bool,N}) at array.jl:301",
          "getindex(B::BitArray{N},I0::UnitRange{Int64}) at multidimensional.jl:199",
          "getindex{T<:Real}(B::BitArray{N},I0::UnitRange{T<:Real}) at multidimensional.jl:203",
          "getindex(B::BitArray{N},I::AbstractArray{Bool,1}) at bitarray.jl:381",
          "getindex{T<:Real}(B::BitArray{N},I::AbstractArray{T<:Real,1}) at bitarray.jl:361",
          "getindex(B::BitArray{N},I::AbstractArray{Bool,N}) at bitarray.jl:381",
          "getindex(A::Array{T,N},I_1::Union(AbstractArray{T,1},Real)) at multidimensional.jl:49",
          "getindex(A::Array{T,N},I_1::Union(AbstractArray{T,1},Real),I_2::Union(AbstractArray{T,1},Real)) at multidimensional.jl:49",
          "getindex(A::Array{T,N},I_1::Union(AbstractArray{T,1},Real),I_2::Union(AbstractArray{T,1},Real),I_3::Union(AbstractArray{T,1},Real)) at multidimensional.jl:49",
          "getindex(A::Array{T,N},I_1::Union(AbstractArray{T,1},Real),I_2::Union(AbstractArray{T,1},Real),I_3::Union(AbstractArray{T,1},Real),I_4::Union(AbstractArray{T,1},Real)) at multidimensional.jl:49",
          "getindex(A::Array{T,N},I::Union(AbstractArray{T,1},Real)...) at multidimensional.jl:49",
          "getindex(B::BitArray{N},I_1::Union(AbstractArray{T,1},Real)) at multidimensional.jl:250",
          "getindex(B::BitArray{N},I_1::Union(AbstractArray{T,1},Real),I_2::Union(AbstractArray{T,1},Real)) at multidimensional.jl:250",
          "getindex(B::BitArray{N},I_1::Union(AbstractArray{T,1},Real),I_2::Union(AbstractArray{T,1},Real),I_3::Union(AbstractArray{T,1},Real)) at multidimensional.jl:250",
          "getindex(B::BitArray{N},I_1::Union(AbstractArray{T,1},Real),I_2::Union(AbstractArray{T,1},Real),I_3::Union(AbstractArray{T,1},Real),I_4::Union(AbstractArray{T,1},Real)) at multidimensional.jl:250",
          "getindex(B::BitArray{N},I::Union(AbstractArray{T,1},Real)...) at cartesian.jl:100",
          "getindex(S::SharedArray{T,N},I::AbstractArray{T,N}) at sharedarray.jl:211",
          "getindex(A::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{Bool,1},J::Integer) at sparse/sparsematrix.jl:1027",
          "getindex{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{T<:Integer,1},j::Integer) at sparse/sparsematrix.jl:735",
          "getindex(A::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{Bool,1},J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1028",
          "getindex{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{T<:Integer,1},J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1029",
          "getindex{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{Bool,1},J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1030",
          "getindex{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti},I::AbstractArray{T,1},J::AbstractArray{T,1}) at sparse/sparsematrix.jl:1001",
          "getindex(A::AbstractArray{T,N},I::AbstractArray{T,N}) at abstractarray.jl:364",
          "getindex(S::SharedArray{T,N},I_1) at sharedarray.jl:212",
          "getindex(S::SharedArray{T,N},I_1,I_2) at sharedarray.jl:212",
          "getindex(S::SharedArray{T,N},I_1,I_2,I_3) at sharedarray.jl:212",
          "getindex(S::SharedArray{T,N},I_1,I_2,I_3,I_4) at sharedarray.jl:212",
          "getindex(S::SharedArray{T,N},I_1,I_2,I_3,I_4,I_5) at sharedarray.jl:212",
          "getindex(S::SharedArray{T,N},I...) at sharedarray.jl:212",
          "getindex(A::AbstractArray{T,1},i1,i2,i3...) at abstractarray.jl:435",
          "getindex(A::AbstractArray{T,2},i1,i2,i3,i4...) at abstractarray.jl:441",
          "getindex{T<:Number}(::Type{T<:Number},r::Range{T}) at array.jl:130",
          "getindex{T<:Number}(::Type{T<:Number},r1::Range{T},rs::Range{T}...) at array.jl:134",
          "getindex(T::Union(DataType,TypeConstructor,UnionType),vals...) at array.jl:119",
          "getindex{K,V}(h::Dict{K,V},key) at dict.jl:513",
          "getindex{K}(wkh::WeakKeyDict{K,V},key) at dict.jl:646",
          "getindex(::EnvHash,k::String) at env.jl:75",
          "getindex{K,V}(pq::PriorityQueue{K,V},key) at collections.jl:208",
          "getindex{K,V}(h::HashDict{K,V,O<:Union(Nothing,Int64)},key) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:411",
          "getindex(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "getindex{K,V,F<:Union(DataType,Function)}(d::DefaultDictBase{K,V,F<:Union(DataType,Function),Dict{K,V}},key) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:63",
          "getindex{K,V,F}(d::DefaultDictBase{K,V,F,Dict{K,V}},key) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:70",
          "getindex(d::DefaultDictBase{K,V,F,D<:Associative{K,V}},key) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:57",
          "getindex(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "getindex(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "getindex(t::Associative{K,V},key) at dict.jl:128",
          "getindex(t::Associative{K,V},k1,k2,ks...) at dict.jl:137",
          "getindex(x::StateUpdate,s::Symbol) at inference.jl:1058",
          "getindex(s::ASCIIString,i::Int64) at ascii.jl:11",
          "getindex(s::ASCIIString,r::Array{T,1}) at ascii.jl:17",
          "getindex(s::ASCIIString,r::UnitRange{Int64}) at ascii.jl:18",
          "getindex(s::ASCIIString,indx::AbstractArray{Int64,1}) at ascii.jl:19",
          "getindex(s::UTF8String,i::Int64) at utf8.jl:54",
          "getindex(s::UTF8String,r::UnitRange{Int64}) at utf8.jl:101",
          "getindex(s::SubString{T<:String},i::Int64) at string.jl:635",
          "getindex(s::String,i::Int64) at string.jl:57",
          "getindex(s::String,i::Integer) at string.jl:58",
          "getindex(s::String,x::Real) at string.jl:59",
          "getindex(s::String,r::UnitRange{Int64}) at string.jl:660",
          "getindex{T<:Integer}(s::String,r::UnitRange{T<:Integer}) at string.jl:60",
          "getindex(s::String,v::AbstractArray{T,1}) at string.jl:62",
          "getindex(r::RemoteRef,args...) at darray.jl:227",
          "getindex(a::ZeroOffsetVector,i) at linalg/tridiag.jl:83",
          "getindex(C::Cholesky{T},d::Symbol) at linalg/factorization.jl:63",
          "getindex{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(C::CholeskyPivoted{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},d::Symbol) at linalg/factorization.jl:69",
          "getindex(A::QR{T},d::Symbol) at linalg/factorization.jl:194",
          "getindex(A::QRCompactWY{S},d::Symbol) at linalg/factorization.jl:199",
          "getindex{T}(A::QRPivoted{T},d::Symbol) at linalg/factorization.jl:204",
          "getindex(A::Hessenberg{T},d::Symbol) at linalg/factorization.jl:489",
          "getindex(A::Union(Eigen{T,V},GeneralizedEigen{T,V}),d::Symbol) at linalg/factorization.jl:517",
          "getindex(F::SVD{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Tr},d::Symbol) at linalg/factorization.jl:657",
          "getindex{T}(obj::GeneralizedSVD{T},d::Symbol) at linalg/factorization.jl:702",
          "getindex(F::Schur{Ty<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},d::Symbol) at linalg/factorization.jl:751",
          "getindex(F::GeneralizedSchur{Ty<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},d::Symbol) at linalg/factorization.jl:776",
          "getindex{T,S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})}(A::LU{T,S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})},d::Symbol) at linalg/lu.jl:95",
          "getindex(J::UniformScaling{T<:Number},i::Integer,j::Integer) at linalg/uniformscaling.jl:12",
          "getindex(lu::UmfpackLU{Tv<:Union(Float64,Complex{Float64}),Ti<:Union(Int64,Int32)},d::Symbol) at linalg/umfpack.jl:330",
          "getindex{T,V}(ct::Accumulator{T,V},x::T) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:29",
          "getindex{T,C}(cc::ClassifiedCollections{T,C},x::T) at /home/samuel/.julia/v0.3/DataStructures/src/classifiedcollections.jl:29",
          "getindex(t::Trie{T},key::String) at /home/samuel/.julia/v0.3/DataStructures/src/trie.jl:29",
          "getindex(dn::DistinguishedName,irdn::Integer,iava::Integer) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:233"
        ]
      },
      {
        "name": "getipaddr",
        "summary": "Function",
        "help": "Base.getipaddr() -> String\n\n   Get the IP address of the local machine, as a string of the form\n   \"x.x.x.x\".\n",
        "methods": 
        [
          "getipaddr() at socket.jl:547"
        ]
      },
      {
        "name": "getkey",
        "summary": "Function",
        "help": "Base.getkey(collection, key, default)\n\n   Return the key matching argument \"key\" if one exists in\n   \"collection\", otherwise return \"default\".\n",
        "methods": 
        [
          "getkey{K,V}(h::Dict{K,V},key,deflt) at dict.jl:531",
          "getkey{K}(wkh::WeakKeyDict{K,V},kk,deflt) at dict.jl:630",
          "getkey{K,V}(h::HashDict{K,V,O<:Union(Nothing,Int64)},key,deflt) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:424",
          "getkey(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "getkey(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "getkey(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "getkey(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11"
        ]
      },
      {
        "name": "getpid",
        "summary": "Function",
        "help": "Base.getpid() -> Int32\n\n   Get julia's process ID.\n",
        "methods": 
        [
          "getpid() at libc.jl:74"
        ]
      },
      {
        "name": "givens",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "givens{T}(f::T,g::T,i1::Integer,i2::Integer,size::Integer) at linalg/givens.jl:185",
          "givens{T}(A::AbstractArray{T,2},i1::Integer,i2::Integer,col::Integer) at linalg/givens.jl:192"
        ]
      },
      {
        "name": "golden",
        "summary": "MathConst{:φ}",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "gperm",
        "summary": "Function",
        "help": "Base.gperm(file)\n\n   Like uperm but gets the permissions of the group owning the file\n",
        "methods": 
        [
          "gperm(st::StatStruct) at stat.jl:81",
          "gperm(path...) at stat.jl:105"
        ]
      },
      {
        "name": "gradient",
        "summary": "Function",
        "help": "Base.gradient(F[, h])\n\n   Compute differences along vector \"F\", using \"h\" as the spacing\n   between points. The default spacing is one.\n",
        "methods": 
        [
          "gradient(F::Array{T,1},h::Array{T,1}) at linalg/dense.jl:88",
          "gradient(F::BitArray{1}) at linalg/bitarray.jl:70",
          "gradient(F::BitArray{1},h::Real) at linalg/bitarray.jl:71",
          "gradient(F::Array{T,1},h::BitArray{1}) at linalg/bitarray.jl:72",
          "gradient(F::BitArray{1},h::Array{T,1}) at linalg/bitarray.jl:73",
          "gradient(F::BitArray{1},h::BitArray{1}) at linalg/bitarray.jl:74",
          "gradient(F::AbstractArray{T,1}) at linalg/generic.jl:46",
          "gradient(F::AbstractArray{T,1},h::Real) at linalg/generic.jl:47"
        ]
      },
      {
        "name": "hankelh1",
        "summary": "Function",
        "help": "Base.hankelh1(nu, x)\n\n   Bessel function of the third kind of order \"nu\", H^{(1)}_\\nu(x).\n",
        "methods": 
        [
          "hankelh1{T1<:Number,T2<:Number}(::T1<:Number,::AbstractArray{T2<:Number,N}) at operators.jl:365",
          "hankelh1{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::T2<:Number) at operators.jl:367",
          "hankelh1{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::AbstractArray{T2<:Number,N}) at operators.jl:371",
          "hankelh1(nu,z) at math.jl:700"
        ]
      },
      {
        "name": "hankelh2",
        "summary": "Function",
        "help": "Base.hankelh2(nu, x)\n\n   Bessel function of the third kind of order \"nu\", H^{(2)}_\\nu(x).\n",
        "methods": 
        [
          "hankelh2{T1<:Number,T2<:Number}(::T1<:Number,::AbstractArray{T2<:Number,N}) at operators.jl:365",
          "hankelh2{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::T2<:Number) at operators.jl:367",
          "hankelh2{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::AbstractArray{T2<:Number,N}) at operators.jl:371",
          "hankelh2(nu,z) at math.jl:703"
        ]
      },
      {
        "name": "has",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "has(s::Set{T},x) at deprecated.jl:26",
          "has(s::IntSet,x) at deprecated.jl:26",
          "has(d,k) at deprecated.jl:26"
        ]
      },
      {
        "name": "hash",
        "summary": "Function",
        "help": "Base.hash(x[, h])\n\n   Compute an integer hash code such that \"isequal(x,y)\" implies\n   \"hash(x)==hash(y)\". The optional second argument \"h\" is a hash\n   code to be mixed with the result. New types should implement the\n   2-argument form.\n",
        "methods": 
        [
          "hash(::(),h::Uint64) at tuple.jl:88",
          "hash(x::(Any,),h::Uint64) at tuple.jl:89",
          "hash(x::(Any,Any),h::Uint64) at tuple.jl:90",
          "hash(x::(Any...,),h::Uint64) at tuple.jl:91",
          "hash(w::WeakRef,h::Uint64) at hashing.jl:4",
          "hash(x::Uint64,h::Uint64) at hashing.jl:59",
          "hash(x::Int64,h::Uint64) at hashing.jl:60",
          "hash(x::Float64,h::Uint64) at hashing.jl:61",
          "hash(x::Union(Char,Uint16,Uint8,Uint32,Int8,Bool,Int16,Int32),h::Uint64) at hashing.jl:63",
          "hash(x::Float32,h::Uint64) at hashing.jl:64",
          "hash(z::Complex{T<:Real},h::Uint64) at hashing.jl:74",
          "hash(x::Symbol,h::Uint64) at hashing.jl:79",
          "hash(x::Expr,h::Uint64) at hashing.jl:80",
          "hash{T<:Union(UTF8String,ASCIIString)}(s::Union(SubString{T<:Union(UTF8String,ASCIIString)},T<:Union(UTF8String,ASCIIString)),h::Uint64) at string.jl:680",
          "hash(s::String,h::Uint64) at string.jl:683",
          "hash(x::Prehashed) at multidimensional.jl:488",
          "hash(r::RemoteRef,h::Uint64) at multi.jl:451",
          "hash{T<:Union(Uint16,Uint8,Uint32,Uint64,Int8,Int64,Int16,Int32)}(x::Rational{T<:Union(Uint16,Uint8,Uint32,Uint64,Int8,Int64,Int16,Int32)},h::Uint64) at hashing2.jl:133",
          "hash(x::Float16,h::Uint64) at hashing2.jl:155",
          "hash(x::MathConst{sym},h::Uint64) at constants.jl:19",
          "hash(x::Real,h::Uint64) at hashing2.jl:30",
          "hash(r::Range{T},h::Uint64) at hashing2.jl:186",
          "hash(a::AbstractArray{T,N},h::Uint64) at hashing2.jl:160",
          "hash(a::Associative{K,V},h::Uint64) at hashing2.jl:169",
          "hash(s::Set{T},h::Uint64) at hashing2.jl:177",
          "hash(v::VersionNumber,h::Uint64) at version.jl:149",
          "hash(s::VersionSet,h::Uint64) at pkg/types.jl:47",
          "hash(li::LineInfo,h::Uint64) at profile.jl:73",
          "hash(s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:96",
          "hash(ct::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:71",
          "hash(x::ANY,h::Uint64) at hashing.jl:8",
          "hash(x) at hashing.jl:3"
        ]
      },
      {
        "name": "haskey",
        "summary": "Function",
        "help": "Base.haskey(collection, key) -> Bool\n\n   Determine whether a collection has a mapping for a given key.\n",
        "methods": 
        [
          "haskey(h::Dict{K,V},key) at dict.jl:527",
          "haskey{K}(wkh::WeakKeyDict{K,V},key) at dict.jl:645",
          "haskey(pq::PriorityQueue{K,V},key) at collections.jl:168",
          "haskey(h::HashDict{K,V,O<:Union(Nothing,Int64)},key) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:420",
          "haskey(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "haskey(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "haskey(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "haskey(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "haskey(d::Associative{K,V},k) at dict.jl:7",
          "haskey{T,V}(ct::Accumulator{T,V},x::T) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:31",
          "haskey{T,C}(cc::ClassifiedCollections{T,C},x::T) at /home/samuel/.julia/v0.3/DataStructures/src/classifiedcollections.jl:31",
          "haskey(t::Trie{T},key::String) at /home/samuel/.julia/v0.3/DataStructures/src/trie.jl:49"
        ]
      },
      {
        "name": "hcat",
        "summary": "Function",
        "help": "Base.hcat(A...)\n\n   Concatenate along dimension 2\n",
        "methods": 
        [
          "hcat() at abstractarray.jl:497",
          "hcat(B::BitArray{1}...) at bitarray.jl:1580",
          "hcat(A::Union(BitArray{2},BitArray{1})...) at bitarray.jl:1606",
          "hcat(X::SparseMatrixCSC{Tv,Ti<:Integer}...) at sparse/sparsematrix.jl:1495",
          "hcat{T}(V::AbstractArray{T,1}...) at abstractarray.jl:522",
          "hcat{T}(A::Union(AbstractArray{T,2},AbstractArray{T,1})...) at abstractarray.jl:547",
          "hcat{T<:Number}(X::T<:Number...) at abstractarray.jl:501",
          "hcat(X::Number...) at abstractarray.jl:514",
          "hcat(A::AbstractArray{T,N}...) at abstractarray.jl:722",
          "hcat{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32},B::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:776",
          "hcat{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64},B::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:776",
          "hcat{T}(X::T...) at abstractarray.jl:500",
          "hcat(X...) at abstractarray.jl:656"
        ]
      },
      {
        "name": "help",
        "summary": "Function",
        "help": "Base.help(name)\n\n   Get help for a function. \"name\" can be an object or a string.\n",
        "methods": 
        [
          "help(io::IO) at help.jl:66",
          "help(io::IO,fname::String) at help.jl:91",
          "help(io::IO,fname::String,obj) at help.jl:91",
          "help(io::IO,f::Function) at help.jl:165",
          "help(io::IO,t::DataType) at help.jl:166",
          "help(io::IO,t::Module) at help.jl:167",
          "help(io::IO,x) at help.jl:170",
          "help(args...) at help.jl:180"
        ]
      },
      {
        "name": "hessfact",
        "summary": "Function",
        "help": "Base.hessfact(A)\n\n   Compute the Hessenberg decomposition of \"A\" and return a\n   \"Hessenberg\" object. If \"F\" is the factorization object, the\n   unitary matrix can be accessed with \"F[:Q]\" and the Hessenberg\n   matrix with \"F[:H]\". When \"Q\" is extracted, the resulting type\n   is the \"HessenbergQ\" object, and may be converted to a regular\n   matrix with \"full()\".\n",
        "methods": 
        [
          "hessfact{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:478",
          "hessfact{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/factorization.jl:479"
        ]
      },
      {
        "name": "hessfact!",
        "summary": "Function",
        "help": "Base.hessfact!(A)\n\n   \"hessfact!\" is the same as \"hessfact()\", but saves space by\n   overwriting the input A, instead of creating a copy.\n",
        "methods": 
        [
          "hessfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:477"
        ]
      },
      {
        "name": "hex",
        "summary": "Function",
        "help": "Base.hex(n[, pad])\n\n   Convert an integer to a hexadecimal string, optionally specifying a\n   number of digits to pad to.\n",
        "methods": 
        [
          "hex(x::Unsigned,pad::Int64,neg::Bool) at intfuncs.jl:225",
          "hex(x::Unsigned,p::Int64) at intfuncs.jl:259",
          "hex(x::Unsigned) at intfuncs.jl:260",
          "hex(x::Char,p::Int64) at intfuncs.jl:261",
          "hex(x::Char) at intfuncs.jl:262",
          "hex(n::BigInt) at gmp.jl:421",
          "hex(x::Integer,p::Int64) at intfuncs.jl:263",
          "hex(x::Integer) at intfuncs.jl:264"
        ]
      },
      {
        "name": "hex2bytes",
        "summary": "Function",
        "help": "Base.hex2bytes(s::ASCIIString)\n\n   Convert an arbitrarily long hexadecimal string to its binary\n   representation. Returns an Array{Uint8, 1}, i.e. an array of bytes.\n",
        "methods": 
        [
          "hex2bytes(s::ASCIIString) at string.jl:1653"
        ]
      },
      {
        "name": "hex2num",
        "summary": "Function",
        "help": "Base.hex2num(str)\n\n   Convert a hexadecimal string to the floating point number it\n   represents\n",
        "methods": 
        [
          "hex2num(s::String) at floatfuncs.jl:32"
        ]
      },
      {
        "name": "hist",
        "summary": "Function",
        "help": "Base.hist(v[, n]) -> e, counts\n\n   Compute the histogram of \"v\", optionally using approximately\n   \"n\" bins. The return values are a range \"e\", which correspond\n   to the edges of the bins, and \"counts\" containing the number of\n   elements of \"v\" in each bin. Note: Julia does not ignore \"NaN\"\n   values in the computation.\n\nBase.hist(v, e) -> e, counts\n\n   Compute the histogram of \"v\" using a vector/range \"e\" as the\n   edges for the bins. The result will be a vector of length\n   \"length(e) - 1\", such that the element at location \"i\"\n   satisfies \"sum(e[i] .< v .<= e[i+1])\". Note: Julia does not\n   ignore \"NaN\" values in the computation.\n",
        "methods": 
        [
          "hist(v::AbstractArray{T,1},edg::AbstractArray{T,1}) at statistics.jl:494",
          "hist(v::AbstractArray{T,1},n::Integer) at statistics.jl:495",
          "hist(v::AbstractArray{T,1}) at statistics.jl:496",
          "hist(A::AbstractArray{T,2},edg::AbstractArray{T,1}) at statistics.jl:510",
          "hist(A::AbstractArray{T,2},n::Integer) at statistics.jl:511",
          "hist(A::AbstractArray{T,2}) at statistics.jl:512"
        ]
      },
      {
        "name": "hist2d",
        "summary": "Function",
        "help": "Base.hist2d(M, e1, e2) -> (edge1, edge2, counts)\n\n   Compute a \"2d histogram\" of a set of N points specified by N-by-2\n   matrix \"M\". Arguments \"e1\" and \"e2\" are bins for each\n   dimension, specified either as integer bin counts or vectors of bin\n   edges. The result is a tuple of \"edge1\" (the bin edges used in\n   the first dimension), \"edge2\" (the bin edges used in the second\n   dimension), and \"counts\", a histogram matrix of size\n   \"(length(edge1)-1, length(edge2)-1)\". Note: Julia does not ignore\n   \"NaN\" values in the computation.\n",
        "methods": 
        [
          "hist2d(v::AbstractArray{T,2},edg1::AbstractArray{T,1},edg2::AbstractArray{T,1}) at statistics.jl:535",
          "hist2d(v::AbstractArray{T,2},edg::AbstractArray{T,1}) at statistics.jl:538",
          "hist2d(v::AbstractArray{T,2},n1::Integer,n2::Integer) at statistics.jl:540",
          "hist2d(v::AbstractArray{T,2},n::Integer) at statistics.jl:542",
          "hist2d(v::AbstractArray{T,2}) at statistics.jl:543"
        ]
      },
      {
        "name": "histrange",
        "summary": "Function",
        "help": "Base.histrange(v, n)\n\n   Compute *nice* bin ranges for the edges of a histogram of \"v\",\n   using approximately \"n\" bins. The resulting step sizes will be 1,\n   2 or 5 multiplied by a power of 10. Note: Julia does not ignore\n   \"NaN\" values in the computation.\n",
        "methods": 
        [
          "histrange{T<:FloatingPoint,N}(v::AbstractArray{T<:FloatingPoint,N},n::Integer) at statistics.jl:420",
          "histrange{T<:Integer,N}(v::AbstractArray{T<:Integer,N},n::Integer) at statistics.jl:444"
        ]
      },
      {
        "name": "homedir",
        "summary": "Function",
        "help": "Base.homedir() -> String\n\n   Return the current user's home directory.\n",
        "methods": 
        [
          "homedir() at path.jl:10"
        ]
      },
      {
        "name": "htol",
        "summary": "Function",
        "help": "Base.htol(x)\n\n   Converts the endianness of a value from that used by the Host to\n   Little-endian.\n",
        "methods": 
        [
          "htol(x) at io.jl:20"
        ]
      },
      {
        "name": "hton",
        "summary": "Function",
        "help": "Base.hton(x)\n\n   Converts the endianness of a value from that used by the Host to\n   Network byte order (big-endian).\n",
        "methods": 
        [
          "hton(x) at io.jl:18"
        ]
      },
      {
        "name": "hvcat",
        "summary": "Function",
        "help": "Base.hvcat(rows::(Int...), values...)\n\n   Horizontal and vertical concatenation in one call. This function is\n   called for block matrix syntax. The first argument specifies the\n   number of arguments to concatenate in each block row. For example,\n   \"[a b;c d e]\" calls \"hvcat((2,3),a,b,c,d,e)\".\n\n   If the first argument is a single integer \"n\", then all block\n   rows are assumed to have \"n\" block columns.\n",
        "methods": 
        [
          "hvcat(nbc::Integer,as...) at abstractarray.jl:728",
          "hvcat(rows::(Int64...,)) at abstractarray.jl:779",
          "hvcat(rows::(Int64...,),X::SparseMatrixCSC{Tv,Ti<:Integer}...) at sparse/sparsematrix.jl:1527",
          "hvcat{T}(rows::(Int64...,),as::AbstractArray{T,2}...) at abstractarray.jl:737",
          "hvcat{T<:Number}(rows::(Int64...,),xs::T<:Number...) at abstractarray.jl:782",
          "hvcat(rows::(Int64...,),xs::Number...) at abstractarray.jl:815",
          "hvcat(rows::(Int64...,),as...) at abstractarray.jl:947"
        ]
      },
      {
        "name": "hypot",
        "summary": "Function",
        "help": "Base.hypot(x, y)\n\n   Compute the \\sqrt{x^2+y^2} avoiding overflow and underflow\n",
        "methods": 
        [
          "hypot(x::Float64,y::Float64) at math.jl:328",
          "hypot(x::Float32,y::Float32) at math.jl:329",
          "hypot(a::Float16,b::Float16) at float16.jl:138",
          "hypot(x::BigFloat,y::BigFloat) at mpfr.jl:479",
          "hypot{T<:FloatingPoint}(x::T<:FloatingPoint,y::T<:FloatingPoint) at math.jl:305",
          "hypot(x::Real,y::Real) at math.jl:303",
          "hypot{T1<:Number,T2<:Number}(::T1<:Number,::AbstractArray{T2<:Number,N}) at operators.jl:365",
          "hypot{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::T2<:Number) at operators.jl:367",
          "hypot{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::AbstractArray{T2<:Number,N}) at operators.jl:371"
        ]
      },
      {
        "name": "iceil",
        "summary": "Function",
        "help": "Base.iceil(x) -> Integer\n\n   Returns the nearest integer not less than \"x\".\n",
        "methods": 
        [
          "iceil(x::Integer) at int.jl:377",
          "iceil(x::FloatingPoint) at float.jl:62",
          "iceil{T<:Integer}(::Type{T<:Integer},x::FloatingPoint) at float.jl:67",
          "iceil(x::Rational{T<:Integer}) at rational.jl:158",
          "iceil(B::BitArray{N}) at bitarray.jl:787",
          "iceil{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "iceil{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "iceil{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "iceil{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "idct",
        "summary": "Function",
        "help": "Base.idct(A[, dims])\n\n   Computes the multidimensional inverse discrete cosine transform\n   (DCT) of the array \"A\" (technically, a type-III DCT with the\n   unitary normalization). The optional \"dims\" argument specifies an\n   iterable subset of dimensions (e.g. an integer, range, tuple, or\n   array) to transform along.  Most efficient if the size of \"A\"\n   along the transformed dimensions is a product of small primes; see\n   \"nextprod()\".  See also \"plan_idct()\" for even greater\n   efficiency.\n",
        "methods": 
        [
          "idct{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region) at dsp.jl:210",
          "idct{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N})) at dsp.jl:243",
          "idct(x::Number,dims) at dsp.jl:257",
          "idct(x::Number) at dsp.jl:259"
        ]
      },
      {
        "name": "idct!",
        "summary": "Function",
        "help": "Base.idct!(A[, dims])\n\n   Same as \"idct!()\", but operates in-place on \"A\".\n",
        "methods": 
        [
          "idct!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(X::Union(SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N}),region) at dsp.jl:210",
          "idct!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(X::Union(SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N})) at dsp.jl:243"
        ]
      },
      {
        "name": "identity",
        "summary": "Function",
        "help": "Base.identity(x)\n\n   The identity function. Returns its argument.\n",
        "methods": 
        [
          "identity(x) at base.jl:128"
        ]
      },
      {
        "name": "ifelse",
        "summary": "Function",
        "help": "Base.ifelse(condition::Bool, x, y)\n\n   Return \"x\" if \"condition\" is true, otherwise return \"y\". This\n   differs from \"?\" or \"if\" in that it is an ordinary function, so\n   all the arguments are evaluated first.\n",
        "methods": 
        [
          "ifelse(c::Bool,x,y) at operators.jl:47",
          "ifelse(c::AbstractArray{Bool,N},x::AbstractArray{T,N},y::AbstractArray{T,N}) at operators.jl:384",
          "ifelse(c::AbstractArray{Bool,N},x::AbstractArray{T,N},y) at operators.jl:389",
          "ifelse(c::AbstractArray{Bool,N},x,y::AbstractArray{T,N}) at operators.jl:394",
          "ifelse(c::AbstractArray{Bool,N},x,y) at operators.jl:380"
        ]
      },
      {
        "name": "ifft",
        "summary": "Function",
        "help": "Base.ifft(A[, dims])\n\n   Multidimensional inverse FFT.\n\n   A one-dimensional inverse FFT computes\n\n      \\operatorname{IDFT}(A)[k] =\n      \\frac{1}{\\operatorname{length}(A)}\n      \\sum_{n=1}^{\\operatorname{length}(A)}\n      \\exp\\left(+i\\frac{2\\pi (n-1)(k-1)}\n      {\\operatorname{length}(A)} \\right) A[n].\n\n   A multidimensional inverse FFT simply performs this operation along\n   each transformed dimension of \"A\".\n",
        "methods": 
        [
          "ifft(x::Number) at fftw.jl:682",
          "ifft(x::Number,dims) at fftw.jl:688",
          "ifft(X,region) at fftw.jl:506",
          "ifft(X) at fftw.jl:507"
        ]
      },
      {
        "name": "ifft!",
        "summary": "Function",
        "help": "Base.ifft!(A[, dims])\n\n   Same as \"ifft()\", but operates in-place on \"A\".\n",
        "methods": 
        [
          "ifft!(X,region) at fftw.jl:506",
          "ifft!(X) at fftw.jl:507"
        ]
      },
      {
        "name": "ifftshift",
        "summary": "Function",
        "help": "Base.ifftshift(x[, dim])\n\n   Undoes the effect of \"fftshift\".\n",
        "methods": 
        [
          "ifftshift(x) at dsp.jl:153",
          "ifftshift(x,dim) at dsp.jl:156"
        ]
      },
      {
        "name": "ifloor",
        "summary": "Function",
        "help": "Base.ifloor(x) -> Integer\n\n   Returns the nearest integer not greater than \"x\".\n",
        "methods": 
        [
          "ifloor(x::Integer) at int.jl:376",
          "ifloor(x::FloatingPoint) at float.jl:63",
          "ifloor{T<:Integer}(::Type{T<:Integer},x::FloatingPoint) at float.jl:68",
          "ifloor(x::Rational{T<:Integer}) at rational.jl:157",
          "ifloor(B::BitArray{N}) at bitarray.jl:787",
          "ifloor{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "ifloor{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "ifloor{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "ifloor{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "ignorestatus",
        "summary": "Function",
        "help": "Base.ignorestatus(command)\n\n   Mark a command object so that running it will not throw an error if\n   the result code is non-zero.\n",
        "methods": 
        [
          "ignorestatus(cmd::Cmd) at process.jl:139",
          "ignorestatus(cmd::Union(AndCmds,OrCmds)) at process.jl:140"
        ]
      },
      {
        "name": "ilogb",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "ilogb(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "im",
        "summary": "Complex{Bool}",
        "help": "Base.im\n\n   The imaginary unit\n",
        "methods": 
        [

        ]
      },
      {
        "name": "imag",
        "summary": "Function",
        "help": "Base.imag(z)\n\n   Return the imaginary part of the complex number \"z\"\n",
        "methods": 
        [
          "imag(z::Complex{T<:Real}) at complex.jl:32",
          "imag(x::Real) at complex.jl:34",
          "imag{T<:Real}(x::Union(DenseArray{T<:Real,N},SubArray{T<:Real,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at array.jl:681",
          "imag(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:679",
          "imag{T<:Real}(x::AbstractArray{T<:Real,N}) at abstractarray.jl:344"
        ]
      },
      {
        "name": "in",
        "summary": "Function",
        "help": "Base.in(item, collection) -> Bool\n\n   Determine whether an item is in the given collection, in the sense\n   that it is \"==\" to one of the values generated by iterating over\n   the collection. Some collections need a slightly different\n   definition; for example Sets check whether the item is \"isequal\"\n   to one of the elements. Dicts look for \"(key,value)\" pairs, and\n   the key is compared using \"isequal\". To test for the presence of\n   a key in a dictionary, use \"haskey\" or \"k in keys(dict)\".\n",
        "methods": 
        [
          "in{T<:Integer}(x,r::Range{T<:Integer}) at range.jl:522",
          "in(x,r::Range{T}) at range.jl:518",
          "in(x::Number,y::Number) at number.jl:40",
          "in(n::Integer,s::IntSet) at intset.jl:121",
          "in(p::(Any,Any),a::Associative{K,V}) at dict.jl:10",
          "in{T<:Dict{K,V}}(key,v::KeyIterator{T<:Dict{K,V}}) at dict.jl:528",
          "in(k::String,::KeyIterator{EnvHash}) at env.jl:77",
          "in{T<:OrderedDict{K,V}}(key,v::KeyIterator{T<:OrderedDict{K,V}}) at /home/samuel/.julia/v0.3/DataStructures/src/ordereddict.jl:44",
          "in{T<:DefaultDictBase{K,V,F,D<:Associative{K,V}}}(key,v::KeyIterator{T<:DefaultDictBase{K,V,F,D<:Associative{K,V}}}) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:53",
          "in{T<:DefaultDict{K,V,F}}(key,v::KeyIterator{T<:DefaultDict{K,V,F}}) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:122",
          "in{T<:DefaultOrderedDict{K,V,F}}(key,v::KeyIterator{T<:DefaultOrderedDict{K,V,F}}) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:122",
          "in(k,v::KeyIterator{T<:Associative{K,V}}) at dict.jl:61",
          "in(x,s::Set{T}) at set.jl:16",
          "in(c::Char,s::String) at string.jl:196",
          "in(::String,::String) at string.jl:466",
          "in(v::VersionNumber,i::VersionInterval) at pkg/types.jl:15",
          "in(v::VersionNumber,s::VersionSet) at pkg/types.jl:38",
          "in(x,s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:24",
          "in(x,itr) at reduce.jl:138"
        ]
      },
      {
        "name": "include",
        "summary": "Function",
        "help": "Base.include(path::String)\n\n   Evaluate the contents of a source file in the current context.\n   During including, a task-local include path is set to the directory\n   containing the file. Nested calls to \"include\" will search\n   relative to that path. All paths refer to files on node 1 when\n   running in parallel, and files will be fetched from node 1. This\n   function is typically used to load source interactively, or to\n   combine files in packages that are broken into multiple source\n   files.\n",
        "methods": 
        [
          "include_from_node1(path::String) at loading.jl:119"
        ]
      },
      {
        "name": "include_string",
        "summary": "Function",
        "help": "Base.include_string(code::String)\n\n   Like \"include\", except reads code from the given string rather\n   than from a file. Since there is no file path involved, no path\n   processing or fetching from node 1 is done.\n",
        "methods": 
        [
          "include_string(txt::String,fname::String) at loading.jl:97",
          "include_string(txt::String) at loading.jl:100"
        ]
      },
      {
        "name": "ind2chr",
        "summary": "Function",
        "help": "Base.ind2chr(string, i)\n\n   Convert a byte index to a character index\n",
        "methods": 
        [
          "ind2chr(s::DirectIndexString,i::Integer) at string.jl:142",
          "ind2chr(s::String,i::Integer) at string.jl:146"
        ]
      },
      {
        "name": "ind2sub",
        "summary": "Function",
        "help": "Base.ind2sub(dims, index) -> subscripts\n\n   Returns a tuple of subscripts into an array with dimensions\n   \"dims\", corresponding to the linear index \"index\"\n\n   **Example** \"i, j, ... = ind2sub(size(A), indmax(A))\" provides\n   the indices of the maximum element\n",
        "methods": 
        [
          "ind2sub(dims::(Integer,),ind::Int64) at abstractarray.jl:1037",
          "ind2sub(dims::(Integer,Integer),ind::Int64) at abstractarray.jl:1038",
          "ind2sub(dims::(Integer,Integer,Integer),ind::Int64) at abstractarray.jl:1040",
          "ind2sub(dims::(Integer,Integer...),ind::Int64) at abstractarray.jl:1019",
          "ind2sub(dims::(),ind::Integer) at abstractarray.jl:1036",
          "ind2sub(dims::(Integer...,),ind::Integer) at abstractarray.jl:1035",
          "ind2sub{T<:Integer}(dims::(Integer,Integer...),ind::AbstractArray{T<:Integer,1}) at abstractarray.jl:1045"
        ]
      },
      {
        "name": "indexin",
        "summary": "Function",
        "help": "Base.indexin(a, b)\n\n   Returns a vector containing the highest index in \"b\" for each\n   value in \"a\" that is a member of \"b\" . The output vector\n   contains 0 wherever \"a\" is not a member of \"b\".\n",
        "methods": 
        [
          "indexin{T}(a::AbstractArray{T,N},b::AbstractArray{T,N}) at array.jl:1149"
        ]
      },
      {
        "name": "indexpids",
        "summary": "Function",
        "help": "Base.indexpids(S::SharedArray)\n\n   Returns the index of the current worker into the \"pids\" vector,\n   i.e., the list of workers mapping the SharedArray\n",
        "methods": 
        [
          "indexpids(S::SharedArray{T,N}) at sharedarray.jl:131"
        ]
      },
      {
        "name": "indmax",
        "summary": "Function",
        "help": "Base.indmax(itr) -> Integer\n\n   Returns the index of the maximum element in a collection.\n",
        "methods": 
        [
          "indmax(f::Array{FieldValue,1}) at pkg/resolve/fieldvalue.jl:71",
          "indmax(a) at array.jl:1143"
        ]
      },
      {
        "name": "indmin",
        "summary": "Function",
        "help": "Base.indmin(itr) -> Integer\n\n   Returns the index of the minimum element in a collection.\n",
        "methods": 
        [
          "indmin(a) at array.jl:1144"
        ]
      },
      {
        "name": "inf",
        "summary": "Function",
        "help": "Base.inf(f)\n\n   Returns infinity in the same floating point type as \"f\" (or \"f\"\n   can by the type itself)\n",
        "methods": 
        [
          "inf(::Type{Float16}) at float.jl:259",
          "inf(::Type{Float32}) at float.jl:261",
          "inf(::Type{Float64}) at float.jl:263",
          "inf{T<:FloatingPoint}(x::T<:FloatingPoint) at float.jl:265",
          "inf(::Type{BigFloat}) at mpfr.jl:664"
        ]
      },
      {
        "name": "info",
        "summary": "Function",
        "help": "Base.info(msg)\n\n   Display an informational message.\n",
        "methods": 
        [
          "info(msg::String...) at util.jl:179"
        ]
      },
      {
        "name": "infs",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "infs{T}(::Type{T},dims...) at deprecated.jl:26",
          "infs{T}(x::AbstractArray{T,N}) at deprecated.jl:26",
          "infs(dims...) at deprecated.jl:26"
        ]
      },
      {
        "name": "insert!",
        "summary": "Function",
        "help": "Base.insert!(collection, index, item)\n\n   Insert an item at the given index.\n",
        "methods": 
        [
          "insert!{T}(a::Array{T,1},i::Integer,item) at array.jl:540",
          "insert!(B::BitArray{1},i::Integer,item) at bitarray.jl:595"
        ]
      },
      {
        "name": "int",
        "summary": "Function",
        "help": "Base.int(x)\n\n   Convert a number or array to the default integer type on your\n   platform. Alternatively, \"x\" can be a string, which is parsed as\n   an integer.\n",
        "methods": 
        [
          "int(x::Int64) at base.jl:102",
          "int(x::FloatingPoint) at int.jl:507",
          "int(z::Complex{T<:Real}) at complex.jl:60",
          "int(x::Rational{T<:Integer}) at rational.jl:171",
          "int(r::StepRange{T,S}) at abstractarray.jl:327",
          "int(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "int(x::AbstractArray{Int64,N}) at abstractarray.jl:267",
          "int{S<:String}(a::AbstractArray{S<:String,N}) at string.jl:1603",
          "int(x::AbstractArray{T,N}) at abstractarray.jl:270",
          "int(s::String) at string.jl:1547",
          "int(x) at base.jl:101"
        ]
      },
      {
        "name": "int128",
        "summary": "Function",
        "help": "Base.int128(x)\n\n   Convert a number or array to \"Int128\" data type\n",
        "methods": 
        [
          "int128(x::FloatingPoint) at int.jl:514",
          "int128(z::Complex{T<:Real}) at complex.jl:60",
          "int128(x::Rational{T<:Integer}) at rational.jl:171",
          "int128(r::StepRange{T,S}) at abstractarray.jl:327",
          "int128(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "int128(x::AbstractArray{Int128,N}) at abstractarray.jl:267",
          "int128(x::AbstractArray{T,N}) at abstractarray.jl:270",
          "int128(s::String) at string.jl:1557",
          "int128(x) at int.jl:356"
        ]
      },
      {
        "name": "int16",
        "summary": "Function",
        "help": "Base.int16(x)\n\n   Convert a number or array to \"Int16\" data type\n",
        "methods": 
        [
          "int16(x::FloatingPoint) at int.jl:507",
          "int16(z::Complex{T<:Real}) at complex.jl:60",
          "int16(x::Rational{T<:Integer}) at rational.jl:171",
          "int16(r::StepRange{T,S}) at abstractarray.jl:327",
          "int16(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "int16(x::AbstractArray{Int16,N}) at abstractarray.jl:267",
          "int16{S<:String}(a::AbstractArray{S<:String,N}) at string.jl:1603",
          "int16(x::AbstractArray{T,N}) at abstractarray.jl:270",
          "int16(s::String) at string.jl:1551",
          "int16(x) at int.jl:353"
        ]
      },
      {
        "name": "int32",
        "summary": "Function",
        "help": "Base.int32(x)\n\n   Convert a number or array to \"Int32\" data type\n",
        "methods": 
        [
          "int32(x::FloatingPoint) at int.jl:507",
          "int32(z::Complex{T<:Real}) at complex.jl:60",
          "int32(x::Rational{T<:Integer}) at rational.jl:171",
          "int32(r::StepRange{T,S}) at abstractarray.jl:327",
          "int32(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "int32(x::AbstractArray{Int32,N}) at abstractarray.jl:267",
          "int32{S<:String}(a::AbstractArray{S<:String,N}) at string.jl:1603",
          "int32(x::AbstractArray{T,N}) at abstractarray.jl:270",
          "int32(s::String) at string.jl:1553",
          "int32(x) at int.jl:354"
        ]
      },
      {
        "name": "int64",
        "summary": "Function",
        "help": "Base.int64(x)\n\n   Convert a number or array to \"Int64\" data type\n",
        "methods": 
        [
          "int64(x::FloatingPoint) at int.jl:514",
          "int64(z::Complex{T<:Real}) at complex.jl:60",
          "int64(x::Rational{T<:Integer}) at rational.jl:171",
          "int64(r::StepRange{T,S}) at abstractarray.jl:327",
          "int64(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "int64(x::AbstractArray{Int64,N}) at abstractarray.jl:267",
          "int64{S<:String}(a::AbstractArray{S<:String,N}) at string.jl:1603",
          "int64(x::AbstractArray{T,N}) at abstractarray.jl:270",
          "int64(s::String) at string.jl:1555",
          "int64(x) at int.jl:355"
        ]
      },
      {
        "name": "int8",
        "summary": "Function",
        "help": "Base.int8(x)\n\n   Convert a number or array to \"Int8\" data type\n",
        "methods": 
        [
          "int8(x::FloatingPoint) at int.jl:507",
          "int8(z::Complex{T<:Real}) at complex.jl:60",
          "int8(x::Rational{T<:Integer}) at rational.jl:171",
          "int8(r::StepRange{T,S}) at abstractarray.jl:327",
          "int8(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "int8(x::AbstractArray{Int8,N}) at abstractarray.jl:267",
          "int8{S<:String}(a::AbstractArray{S<:String,N}) at string.jl:1603",
          "int8(x::AbstractArray{T,N}) at abstractarray.jl:270",
          "int8(s::String) at string.jl:1549",
          "int8(x) at int.jl:352"
        ]
      },
      {
        "name": "integer",
        "summary": "Function",
        "help": "Base.integer(x)\n\n   Convert a number or array to integer type. If \"x\" is already of\n   integer type it is unchanged, otherwise it converts it to the\n   default integer type on your platform.\n",
        "methods": 
        [
          "integer(x::FloatingPoint) at int.jl:507",
          "integer(x::Ptr{T}) at pointer.jl:57",
          "integer(z::Complex{T<:Real}) at complex.jl:60",
          "integer(x::Rational{T<:Integer}) at rational.jl:171",
          "integer(r::StepRange{T,S}) at abstractarray.jl:327",
          "integer(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "integer{T<:Integer}(x::AbstractArray{T<:Integer,N}) at abstractarray.jl:285",
          "integer(x::AbstractArray{T,N}) at abstractarray.jl:288",
          "integer(x::Char) at char.jl:4",
          "integer(s::String) at string.jl:1545",
          "integer(x) at int.jl:366"
        ]
      },
      {
        "name": "integer_partitions",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "integer_partitions(n,m) at deprecated.jl:369"
        ]
      },
      {
        "name": "integer_valued",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "integer_valued(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "interrupt",
        "summary": "Function",
        "help": "Base.interrupt([pids...])\n\n   Interrupt the current executing task on the specified workers. This\n   is equivalent to pressing Ctrl-C on the local machine. If no\n   arguments are given, all workers are interrupted.\n",
        "methods": 
        [
          "interrupt(pid::Integer) at multi.jl:1549",
          "interrupt() at multi.jl:1558",
          "interrupt(pids::Integer...) at multi.jl:1555",
          "interrupt(pids::AbstractArray{T,1}) at multi.jl:1558"
        ]
      },
      {
        "name": "intersect",
        "summary": "Function",
        "help": "Base.intersect(s1, s2...)\n\n   Construct the intersection of two or more sets. Maintains order and\n   multiplicity of the first argument for arrays and ranges.\n",
        "methods": 
        [
          "intersect{T1<:Integer,T2<:Integer}(r::UnitRange{T1<:Integer},s::UnitRange{T2<:Integer}) at range.jl:294",
          "intersect{T<:Integer}(i::Integer,r::UnitRange{T<:Integer}) at range.jl:296",
          "intersect{T<:Integer}(r::UnitRange{T<:Integer},i::Integer) at range.jl:300",
          "intersect{T1<:Integer,T2<:Integer}(r::UnitRange{T1<:Integer},s::StepRange{T2<:Integer,S}) at range.jl:303",
          "intersect{T1<:Integer,T2<:Integer}(r::StepRange{T1<:Integer,S},s::UnitRange{T2<:Integer}) at range.jl:322",
          "intersect{T1<:Integer,T2<:Integer}(r::StepRange{T1<:Integer,S},s::StepRange{T2<:Integer,S}) at range.jl:330",
          "intersect(r::Range{T},s::Range{T}...) at range.jl:375",
          "intersect(s1::IntSet) at intset.jl:229",
          "intersect(s1::IntSet,s2::IntSet) at intset.jl:230",
          "intersect(s1::IntSet,ss::IntSet...) at intset.jl:232",
          "intersect(s::Set{T}) at set.jl:55",
          "intersect(s::Set{T},sets::Set{T}...) at set.jl:57",
          "intersect(a::VersionInterval,b::VersionInterval) at pkg/types.jl:16",
          "intersect(A::VersionSet,B::VersionSet) at pkg/types.jl:40",
          "intersect(s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:58",
          "intersect(s::OrderedSet{T},sets...) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:60",
          "intersect(v1,vs...) at array.jl:1322"
        ]
      },
      {
        "name": "intersect!",
        "summary": "Function",
        "help": "Base.intersect!(s1, s2)\n\n   Intersects IntSets s1 and s2 and overwrites the set s1 with the\n   result. If needed, s1 will be expanded to the size of s2.\n",
        "methods": 
        [
          "intersect!(s::IntSet,s2::IntSet) at intset.jl:213"
        ]
      },
      {
        "name": "inv",
        "summary": "Function",
        "help": "Base.inv(M)\n\n   Matrix inverse\n",
        "methods": 
        [
          "inv(x::Integer) at int.jl:51",
          "inv{T<:Integer}(z::Complex{T<:Integer}) at complex.jl:106",
          "inv{T<:Union(Float16,Float32)}(z::Complex{T<:Union(Float16,Float32)}) at complex.jl:150",
          "inv(w::Complex{Float64}) at complex.jl:196",
          "inv(z::Complex{T<:Real}) at complex.jl:105",
          "inv(x::Number) at number.jl:31",
          "inv(A::Array{T,2}) at linalg/dense.jl:327",
          "inv(A::SymTridiagonal{T}) at linalg/tridiag.jl:134",
          "inv(A::Tridiagonal{T}) at linalg/tridiag.jl:215",
          "inv{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Triangular{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/triangular.jl:54",
          "inv{T}(D::Diagonal{T}) at linalg/diagonal.jl:109",
          "inv(A::SparseMatrixCSC{Tv,Ti<:Integer}) at linalg/sparse.jl:586",
          "inv(a::AbstractArray{T,1}) at linalg/generic.jl:226",
          "inv{T}(A::AbstractArray{T,2}) at linalg/generic.jl:228",
          "inv(C::Cholesky{T}) at linalg/factorization.jl:121",
          "inv(C::CholeskyPivoted{T}) at linalg/factorization.jl:124",
          "inv(A::Eigen{T,V}) at linalg/factorization.jl:587",
          "inv{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})}(A::LU{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})}) at linalg/lu.jl:145",
          "inv{T<:Union(Float64,Float32)}(B::BunchKaufman{T<:Union(Float64,Float32)}) at linalg/bunchkaufman.jl:32",
          "inv{T<:Union(Complex{Float64},Complex{Float32})}(B::BunchKaufman{T<:Union(Complex{Float64},Complex{Float32})}) at linalg/bunchkaufman.jl:35",
          "inv(A::CholeskyDenseRFP{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/rectfullpacked.jl:38",
          "inv{T}(F::Factorization{T}) at linalg/factorization.jl:793"
        ]
      },
      {
        "name": "invdigamma",
        "summary": "Function",
        "help": "Base.invdigamma(x)\n\n   Compute the inverse digamma function of \"x\".\n",
        "methods": 
        [
          "invdigamma(y::Float64) at math.jl:1090",
          "invdigamma(x::Float32) at math.jl:1110",
          "invdigamma(x::Real) at math.jl:1111",
          "invdigamma{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "invdigamma{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "invdigamma{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "invmod",
        "summary": "Function",
        "help": "Base.invmod(x, m)\n\n   Take the inverse of \"x\" modulo \"m\": \"y\" such that xy = 1\n   \\pmod m\n",
        "methods": 
        [
          "invmod(x::BigInt,y::BigInt) at gmp.jl:201",
          "invmod(n,m) at intfuncs.jl:41"
        ]
      },
      {
        "name": "invperm",
        "summary": "Function",
        "help": "Base.invperm(v)\n\n   Return the inverse permutation of v.\n",
        "methods": 
        [
          "invperm(a::AbstractArray{T,1}) at combinatorics.jl:163"
        ]
      },
      {
        "name": "ipermute!",
        "summary": "Function",
        "help": "Base.ipermute!(v, p)\n\n   Like permute!, but the inverse of the given permutation is applied.\n",
        "methods": 
        [
          "ipermute!(a,p::AbstractArray{T,1}) at combinatorics.jl:229"
        ]
      },
      {
        "name": "ipermutedims",
        "summary": "Function",
        "help": "Base.ipermutedims(A, perm)\n\n   Like \"permutedims()\", except the inverse of the given permutation\n   is applied.\n",
        "methods": 
        [
          "ipermutedims(A::AbstractArray{T,N},perm) at abstractarray.jl:936"
        ]
      },
      {
        "name": "irfft",
        "summary": "Function",
        "help": "Base.irfft(A, d[, dims])\n\n   Inverse of \"rfft()\": for a complex array \"A\", gives the\n   corresponding real array whose FFT yields \"A\" in the first half.\n   As for \"rfft()\", \"dims\" is an optional subset of dimensions to\n   transform, defaulting to \"1:ndims(A)\".\n\n   \"d\" is the length of the transformed real array along the\n   \"dims[1]\" dimension, which must satisfy \"d ==\n   floor(size(A,dims[1])/2)+1\". (This parameter cannot be inferred\n   from \"size(A)\" due to the possibility of rounding by the\n   \"floor\" function here.)\n",
        "methods": 
        [
          "irfft(x::Number,d::Integer) at fftw.jl:685",
          "irfft(x::Number,d::Integer,dims) at fftw.jl:692",
          "irfft(X,d,region) at fftw.jl:658",
          "irfft(X,d) at fftw.jl:663"
        ]
      },
      {
        "name": "iround",
        "summary": "Function",
        "help": "Base.iround(x) -> Integer\n\n   Returns the nearest integer to \"x\".\n",
        "methods": 
        [
          "iround(x::Integer) at int.jl:373",
          "iround{T<:Integer}(::Type{T<:Integer},x::Integer) at int.jl:374",
          "iround(x::Float32) at float.jl:74",
          "iround(x::Float64) at float.jl:76",
          "iround(x::BigFloat) at mpfr.jl:652",
          "iround(x::FloatingPoint) at float.jl:64",
          "iround(::Type{Int8},x::Float32) at float.jl:87",
          "iround(::Type{Int8},x::Float64) at float.jl:88",
          "iround(::Type{Uint8},x::Float32) at float.jl:87",
          "iround(::Type{Uint8},x::Float64) at float.jl:88",
          "iround(::Type{Int16},x::Float32) at float.jl:87",
          "iround(::Type{Int16},x::Float64) at float.jl:88",
          "iround(::Type{Uint16},x::Float32) at float.jl:87",
          "iround(::Type{Uint16},x::Float64) at float.jl:88",
          "iround(::Type{Int32},x::Float32) at float.jl:92",
          "iround(::Type{Int32},x::Float64) at float.jl:93",
          "iround(::Type{Uint32},x::Float32) at float.jl:94",
          "iround(::Type{Uint32},x::Float64) at float.jl:95",
          "iround(::Type{Int64},x::Float32) at float.jl:96",
          "iround(::Type{Int64},x::Float64) at float.jl:97",
          "iround(::Type{Uint64},x::Float32) at float.jl:98",
          "iround(::Type{Uint64},x::Float64) at float.jl:99",
          "iround(::Type{Int128},x::Float32) at float.jl:101",
          "iround(::Type{Int128},x::Float64) at float.jl:102",
          "iround(::Type{Uint128},x::Float32) at float.jl:103",
          "iround(::Type{Uint128},x::Float64) at float.jl:104",
          "iround{T<:Integer}(::Type{T<:Integer},x::FloatingPoint) at float.jl:69",
          "iround(x::Rational{T<:Integer}) at rational.jl:159",
          "iround(B::BitArray{N}) at bitarray.jl:787",
          "iround{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "iround(M::SymTridiagonal{T}) at linalg/tridiag.jl:32",
          "iround(M::Tridiagonal{T}) at linalg/tridiag.jl:188",
          "iround(M::Bidiagonal{T}) at linalg/bidiag.jl:67",
          "iround{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "iround{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "iround{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "iround{T<:Integer,R<:Real}(::Type{T<:Integer},x::AbstractArray{R<:Real,1}) at floatfuncs.jl:51",
          "iround{T<:Integer,R<:Real}(::Type{T<:Integer},x::AbstractArray{R<:Real,2}) at floatfuncs.jl:52",
          "iround{T<:Integer,R<:Real}(::Type{T<:Integer},x::AbstractArray{R<:Real,N}) at floatfuncs.jl:53"
        ]
      },
      {
        "name": "is_assigned_char",
        "summary": "Function",
        "help": "Base.is_assigned_char(c) -> Bool\n\n   Returns true if the given char or integer is an assigned Unicode\n   code point.\n",
        "methods": 
        [
          "is_assigned_char(c) at utf8proc.jl:85"
        ]
      },
      {
        "name": "is_valid_ascii",
        "summary": "Function",
        "help": "Base.is_valid_ascii(s) -> Bool\n\n   Returns true if the string or byte vector is valid ASCII, false\n   otherwise.\n",
        "methods": 
        [
          "is_valid_ascii(s::Union(ASCIIString,Array{Uint8,1},UTF8String)) at string.jl:966"
        ]
      },
      {
        "name": "is_valid_char",
        "summary": "Function",
        "help": "Base.is_valid_char(c) -> Bool\n\n   Returns true if the given char or integer is a valid Unicode code\n   point.\n",
        "methods": 
        [
          "is_valid_char(c) at utf8proc.jl:10"
        ]
      },
      {
        "name": "is_valid_utf16",
        "summary": "Function",
        "help": "Base.is_valid_utf16(s) -> Bool\n\n   Returns true if the string or \"Uint16\" array is valid UTF-16.\n",
        "methods": 
        [
          "is_valid_utf16(data::Array{Uint16,N}) at utf16.jl:53",
          "is_valid_utf16(s::UTF16String) at utf16.jl:67"
        ]
      },
      {
        "name": "is_valid_utf8",
        "summary": "Function",
        "help": "Base.is_valid_utf8(s) -> Bool\n\n   Returns true if the string or byte vector is valid UTF-8, false\n   otherwise.\n",
        "methods": 
        [
          "is_valid_utf8(s::Union(ASCIIString,Array{Uint8,1},UTF8String)) at string.jl:967"
        ]
      },
      {
        "name": "isabspath",
        "summary": "Function",
        "help": "Base.isabspath(path::String) -> Bool\n\n   Determines whether a path is absolute (begins at the root\n   directory).\n",
        "methods": 
        [
          "isabspath(path::String) at path.jl:27"
        ]
      },
      {
        "name": "isalnum",
        "summary": "Function",
        "help": "Base.isalnum(c::Union(Char, String)) -> Bool\n\n   Tests whether a character is alphanumeric, or whether this is true\n   for all elements of a string.\n",
        "methods": 
        [
          "isalnum(c::Char) at string.jl:548",
          "isalnum(s::String) at string.jl:549"
        ]
      },
      {
        "name": "isalpha",
        "summary": "Function",
        "help": "Base.isalpha(c::Union(Char, String)) -> Bool\n\n   Tests whether a character is alphabetic, or whether this is true\n   for all elements of a string.\n",
        "methods": 
        [
          "isalpha(c::Char) at string.jl:548",
          "isalpha(s::String) at string.jl:549"
        ]
      },
      {
        "name": "isapprox",
        "summary": "Function",
        "help": "Base.isapprox(x::Number, y::Number; rtol::Real=cbrt(maxeps), atol::Real=sqrt(maxeps))\n\n   Inexact equality comparison - behaves slightly different depending\n   on types of input args:\n\n   * For \"FloatingPoint\" numbers, \"isapprox\" returns \"true\" if\n     \"abs(x-y) <= atol + rtol*max(abs(x), abs(y))\".\n\n   * For \"Integer\" and \"Rational\" numbers, \"isapprox\" returns\n     \"true\" if \"abs(x-y) <= atol\". The *rtol* argument is ignored.\n     If one of \"x\" and \"y\" is \"FloatingPoint\", the other is\n     promoted, and the method above is called instead.\n\n   * For \"Complex\" numbers, the distance in the complex plane is\n     compared, using the same criterion as above.\n\n   For default tolerance arguments, \"maxeps = max(eps(abs(x)),\n   eps(abs(y)))\".\n",
        "methods": 
        [
          "isapprox(x::FloatingPoint,y::FloatingPoint) at floatfuncs.jl:94",
          "isapprox(x::Real,y::FloatingPoint) at floatfuncs.jl:98",
          "isapprox(x::FloatingPoint,y::Real) at floatfuncs.jl:99",
          "isapprox(x::Real,y::Real) at floatfuncs.jl:102",
          "isapprox(z::Complex{T<:Real},w::Complex{T<:Real}) at floatfuncs.jl:105",
          "isapprox(x::Real,z::Complex{T<:Real}) at floatfuncs.jl:108",
          "isapprox(z::Complex{T<:Real},x::Real) at floatfuncs.jl:109"
        ]
      },
      {
        "name": "isascii",
        "summary": "Function",
        "help": "Base.isascii(c::Union(Char, String)) -> Bool\n\n   Tests whether a character belongs to the ASCII character set, or\n   whether this is true for all elements of a string.\n",
        "methods": 
        [
          "isascii(c::Char) at string.jl:541",
          "isascii(s::ASCIIString) at string.jl:543",
          "isascii(s::SubString{ASCIIString}) at string.jl:673",
          "isascii(s::RevString{ASCIIString}) at string.jl:744",
          "isascii(s::String) at string.jl:542"
        ]
      },
      {
        "name": "isbits",
        "summary": "Function",
        "help": "Base.isbits(T)\n\n   True if \"T\" is a \"plain data\" type, meaning it is immutable and\n   contains no references to other values. Typical examples are\n   numeric types such as \"Uint8\", \"Float64\", and\n   \"Complex{Float64}\".\n",
        "methods": 
        [
          "isbits(t::DataType) at reflection.jl:36",
          "isbits(t::Type{T<:Top}) at reflection.jl:37",
          "isbits(x) at reflection.jl:38"
        ]
      },
      {
        "name": "isblank",
        "summary": "Function",
        "help": "Base.isblank(c::Union(Char, String)) -> Bool\n\n   Tests whether a character is a tab or space, or whether this is\n   true for all elements of a string.\n",
        "methods": 
        [
          "isblank(c::Char) at string.jl:552",
          "isblank(s::String) at string.jl:553"
        ]
      },
      {
        "name": "isblockdev",
        "summary": "Function",
        "help": "Base.isblockdev(path) -> Bool\n\n   Returns \"true\" if \"path\" is a block device, \"false\"\n   otherwise.\n",
        "methods": 
        [
          "isblockdev(st::StatStruct) at stat.jl:65",
          "isblockdev(path...) at stat.jl:105"
        ]
      },
      {
        "name": "isbool",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "isbool(x) at deprecated.jl:26"
        ]
      },
      {
        "name": "ischardev",
        "summary": "Function",
        "help": "Base.ischardev(path) -> Bool\n\n   Returns \"true\" if \"path\" is a character device, \"false\"\n   otherwise.\n",
        "methods": 
        [
          "ischardev(st::StatStruct) at stat.jl:63",
          "ischardev(path...) at stat.jl:105"
        ]
      },
      {
        "name": "iscntrl",
        "summary": "Function",
        "help": "Base.iscntrl(c::Union(Char, String)) -> Bool\n\n   Tests whether a character is a control character, or whether this\n   is true for all elements of a string.\n",
        "methods": 
        [
          "iscntrl(c::Char) at string.jl:548",
          "iscntrl(s::String) at string.jl:549"
        ]
      },
      {
        "name": "iscomplex",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "iscomplex(x) at deprecated.jl:26"
        ]
      },
      {
        "name": "isconst",
        "summary": "Function",
        "help": "Base.isconst([m::Module], s::Symbol) -> Bool\n\n   Determine whether a global is declared \"const\" in a given module.\n   The default module argument is \"current_module()\".\n",
        "methods": 
        [
          "isconst(s::Symbol) at reflection.jl:23",
          "isconst(m::Module,s::Symbol) at reflection.jl:26"
        ]
      },
      {
        "name": "isdenormal",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "isdenormal(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "isdigit",
        "summary": "Function",
        "help": "Base.isdigit(c::Union(Char, String)) -> Bool\n\n   Tests whether a character is a numeric digit (0-9), or whether this\n   is true for all elements of a string.\n",
        "methods": 
        [
          "isdigit(c::Char) at string.jl:548",
          "isdigit(s::String) at string.jl:549"
        ]
      },
      {
        "name": "isdir",
        "summary": "Function",
        "help": "Base.isdir(path) -> Bool\n\n   Returns \"true\" if \"path\" is a directory, \"false\" otherwise.\n",
        "methods": 
        [
          "isdir(st::StatStruct) at stat.jl:64",
          "isdir(path...) at stat.jl:105"
        ]
      },
      {
        "name": "isdirpath",
        "summary": "Function",
        "help": "Base.isdirpath(path::String) -> Bool\n\n   Determines whether a path refers to a directory (for example, ends\n   with a path separator).\n",
        "methods": 
        [
          "isdirpath(path::String) at path.jl:28"
        ]
      },
      {
        "name": "iseltype",
        "summary": "Function",
        "help": "Base.iseltype(A, T)\n\n   Tests whether A or its elements are of type T\n",
        "methods": 
        [
          "iseltype(x,T) at abstractarray.jl:14"
        ]
      },
      {
        "name": "isempty",
        "summary": "Function",
        "help": "Base.isempty(collection) -> Bool\n\n   Determine whether a collection is empty (has no elements).\n\n   **Examples**:\n\n      julia> a = []\n      julia> isempty(a)\n      true\n\n      julia> b = [1 2 3]\n      julia> isempty(b)\n      false\n",
        "methods": 
        [
          "isempty(x::()) at tuple.jl:106",
          "isempty(x::(Any...,)) at tuple.jl:107",
          "isempty(r::StepRange{T,S}) at range.jl:164",
          "isempty(r::UnitRange{T<:Real}) at range.jl:166",
          "isempty(r::FloatRange{T<:FloatingPoint}) at range.jl:167",
          "isempty(x::Number) at number.jl:39",
          "isempty(a::AbstractArray{T,N}) at abstractarray.jl:248",
          "isempty(s::IntSet) at intset.jl:141",
          "isempty(v::Union(ValueIterator{T<:Associative{K,V}},KeyIterator{T<:Associative{K,V}})) at dict.jl:44",
          "isempty(t::ObjectIdDict) at dict.jl:194",
          "isempty(t::Dict{K,V}) at dict.jl:578",
          "isempty(wkh::WeakKeyDict{K,V}) at dict.jl:647",
          "isempty(s::Set{T}) at set.jl:12",
          "isempty(::Task) at task.jl:172",
          "isempty(pq::PriorityQueue{K,V}) at collections.jl:167",
          "isempty(s::MIState,args...) at LineEdit.jl:89",
          "isempty(s::PromptState) at LineEdit.jl:1047",
          "isempty(i::VersionInterval) at pkg/types.jl:14",
          "isempty(s::VersionSet) at pkg/types.jl:37",
          "isempty(blk::DequeBlock{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:34",
          "isempty(q::Deque{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:76",
          "isempty(s::Stack{S}) at /home/samuel/.julia/v0.3/DataStructures/src/stack.jl:10",
          "isempty(s::Queue{S}) at /home/samuel/.julia/v0.3/DataStructures/src/queue.jl:10",
          "isempty(h::BinaryHeap{T,Comp}) at /home/samuel/.julia/v0.3/DataStructures/src/heaps/binary_heap.jl:135",
          "isempty(h::MutableBinaryHeap{VT,Comp}) at /home/samuel/.julia/v0.3/DataStructures/src/heaps/mutable_binary_heap.jl:198",
          "isempty(t::HashDict{K,V,O<:Union(Nothing,Int64)}) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:493",
          "isempty(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "isempty(::OrderedSet{T},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "isempty(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "isempty(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "isempty(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "isempty(itr) at iterator.jl:1"
        ]
      },
      {
        "name": "isequal",
        "summary": "Function",
        "help": "Base.isequal(x, y)\n\n   Similar to \"==\", except treats all floating-point \"NaN\" values\n   as equal to each other, and treats \"-0.0\" as unequal to \"0.0\".\n   For values that are not floating-point, \"isequal\" is the same as\n   \"==\".\n\n   \"isequal\" is the comparison function used by hash tables\n   (\"Dict\"). \"isequal(x,y)\" must imply that \"hash(x) ==\n   hash(y)\".\n\n   Collections typically implement \"isequal\" by calling \"isequal\"\n   recursively on all contents.\n\n   Scalar types generally do not need to implement \"isequal\", unless\n   they represent floating-point numbers amenable to a more efficient\n   implementation than that provided as a generic fallback (based on\n   \"isnan\", \"signbit\", and \"==\").\n",
        "methods": 
        [
          "isequal(t1::(Any...,),t2::(Any...,)) at tuple.jl:65",
          "isequal(x::Float32,y::Float32) at float.jl:153",
          "isequal(x::Float64,y::Float64) at float.jl:154",
          "isequal(x::FloatingPoint,y::FloatingPoint) at operators.jl:12",
          "isequal(x::Real,y::FloatingPoint) at operators.jl:13",
          "isequal(x::FloatingPoint,y::Real) at operators.jl:14",
          "isequal(z::Complex{T<:Real},w::Complex{T<:Real}) at complex.jl:100",
          "isequal(A::AbstractArray{T,N},B::AbstractArray{T,N}) at abstractarray.jl:836",
          "isequal(l::Associative{K,V},r::Associative{K,V}) at dict.jl:98",
          "isequal(l::OrderedSet{T},r::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:82",
          "isequal(a::CalendarTime,b::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:72",
          "isequal(a::URI,b::URI) at /home/samuel/.julia/v0.3/URIParser/src/parser.jl:25",
          "isequal(x,y) at operators.jl:11"
        ]
      },
      {
        "name": "iseven",
        "summary": "Function",
        "help": "Base.iseven(x::Integer) -> Bool\n\n   Returns \"true\" is \"x\" is even (that is, divisible by 2), and\n   \"false\" otherwise.\n\n   **Examples**:\n\n      julia> iseven(10)\n      false\n\n      julia> iseven(9)\n      true\n",
        "methods": 
        [
          "iseven(n::Integer) at int.jl:54"
        ]
      },
      {
        "name": "isexecutable",
        "summary": "Function",
        "help": "Base.isexecutable(path) -> Bool\n\n   Returns \"true\" if the current user has permission to execute\n   \"path\", \"false\" otherwise.\n",
        "methods": 
        [
          "isexecutable(st::StatStruct) at stat.jl:78",
          "isexecutable(path...) at stat.jl:105"
        ]
      },
      {
        "name": "isfifo",
        "summary": "Function",
        "help": "Base.isfifo(path) -> Bool\n\n   Returns \"true\" if \"path\" is a FIFO, \"false\" otherwise.\n",
        "methods": 
        [
          "isfifo(st::StatStruct) at stat.jl:62",
          "isfifo(path...) at stat.jl:105"
        ]
      },
      {
        "name": "isfile",
        "summary": "Function",
        "help": "Base.isfile(path) -> Bool\n\n   Returns \"true\" if \"path\" is a regular file, \"false\"\n   otherwise.\n",
        "methods": 
        [
          "isfile(st::StatStruct) at stat.jl:66",
          "isfile(path...) at stat.jl:105"
        ]
      },
      {
        "name": "isfinite",
        "summary": "Function",
        "help": "Base.isfinite(f) -> Bool\n\n   Test whether a number is finite\n",
        "methods": 
        [
          "isfinite(x::Float16) at float16.jl:108",
          "isfinite(x::BigFloat) at mpfr.jl:662",
          "isfinite(x::FloatingPoint) at float.jl:218",
          "isfinite(x::Integer) at float.jl:220",
          "isfinite(x::Real) at float.jl:219",
          "isfinite(z::Complex{T<:Real}) at complex.jl:41",
          "isfinite{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "isfinite{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "isfinite{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "isgeneric",
        "summary": "Function",
        "help": "Base.isgeneric(f::Function) -> Bool\n\n   Determine whether a function is generic.\n",
        "methods": 
        [
          "isgeneric(f::ANY) at reflection.jl:71"
        ]
      },
      {
        "name": "isgraph",
        "summary": "Function",
        "help": "Base.isgraph(c::Union(Char, String)) -> Bool\n\n   Tests whether a character is printable, and not a space, or whether\n   this is true for all elements of a string.\n",
        "methods": 
        [
          "isgraph(c::Char) at string.jl:548",
          "isgraph(s::String) at string.jl:549"
        ]
      },
      {
        "name": "ishermitian",
        "summary": "Function",
        "help": "Base.ishermitian(A) -> Bool\n\n   Test whether a matrix is Hermitian.\n",
        "methods": 
        [
          "ishermitian(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:1578",
          "ishermitian(A::Hermitian{T}) at linalg/symmetric.jl:26",
          "ishermitian{T<:Real}(A::Symmetric{T<:Real}) at linalg/symmetric.jl:27",
          "ishermitian{T<:Complex{T<:Real}}(A::Symmetric{T<:Complex{T<:Real}}) at linalg/symmetric.jl:28",
          "ishermitian(D::Diagonal{T}) at linalg/diagonal.jl:32",
          "ishermitian(A::BitArray{2}) at linalg/bitarray.jl:136",
          "ishermitian(A::AbstractArray{T,2}) at linalg/generic.jl:264",
          "ishermitian(x::Number) at linalg/generic.jl:274",
          "ishermitian(B::BunchKaufman{T}) at linalg/bunchkaufman.jl:30"
        ]
      },
      {
        "name": "isimmutable",
        "summary": "Function",
        "help": "Base.isimmutable(v)\n\n   True if value \"v\" is immutable.  See *Immutable Composite Types*\n   for a discussion of immutability.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "isinf",
        "summary": "Function",
        "help": "Base.isinf(f) -> Bool\n\n   Test whether a number is infinite\n",
        "methods": 
        [
          "isinf(x::Float16) at float16.jl:107",
          "isinf(x::BigFloat) at mpfr.jl:655",
          "isinf(x::Real) at float.jl:222",
          "isinf(z::Complex{T<:Real}) at complex.jl:43",
          "isinf{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "isinf{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "isinf{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "isinteger",
        "summary": "Function",
        "help": "Base.isinteger(x) -> Bool\n\n   Test whether \"x\" or all its elements are numerically equal to\n   some integer\n",
        "methods": 
        [
          "isinteger(x::Integer) at number.jl:4",
          "isinteger(z::Complex{T<:Real}) at complex.jl:40",
          "isinteger(x::Rational{T<:Integer}) at rational.jl:107",
          "isinteger{T<:Integer,n}(x::AbstractArray{T<:Integer,n}) at abstractarray.jl:17",
          "isinteger(x::AbstractArray{T,N}) at abstractarray.jl:16",
          "isinteger(x::BigFloat) at mpfr.jl:633",
          "isinteger(x::FloatingPoint) at floatfuncs.jl:25"
        ]
      },
      {
        "name": "isinteractive",
        "summary": "Function",
        "help": "Base.isinteractive() -> Bool\n\n   Determine whether Julia is running an interactive session.\n",
        "methods": 
        [
          "isinteractive() at client.jl:298"
        ]
      },
      {
        "name": "isleaftype",
        "summary": "Function",
        "help": "Base.isleaftype(T)\n\n   Determine whether \"T\" is a concrete type that can have instances,\n   meaning its only subtypes are itself and \"None\" (but \"T\" itself\n   is not \"None\").\n",
        "methods": 
        [
          "isleaftype(t::ANY) at reflection.jl:39"
        ]
      },
      {
        "name": "isless",
        "summary": "Function",
        "help": "Base.isless(x, y)\n\n   Test whether \"x\" is less than \"y\", according to a canonical\n   total order. Values that are normally unordered, such as \"NaN\",\n   are ordered in an arbitrary but consistent fashion. This is the\n   default comparison used by \"sort\". Non-numeric types with a\n   canonical total order should implement this function. Numeric types\n   only need to implement it if they have special values such as\n   \"NaN\".\n",
        "methods": 
        [
          "isless(t1::(Any...,),t2::(Any...,)) at tuple.jl:94",
          "isless(x::Float32,y::Float32) at float.jl:155",
          "isless(x::Float64,y::Float64) at float.jl:156",
          "isless(a::Float16,b::Float16) at float16.jl:128",
          "isless(x::FloatingPoint,y::FloatingPoint) at operators.jl:16",
          "isless(x::Real,y::FloatingPoint) at operators.jl:17",
          "isless(x::FloatingPoint,y::Real) at operators.jl:18",
          "isless(x::Real,y::Real) at operators.jl:44",
          "isless(a::String,b::String) at string.jl:486",
          "isless(a::Symbol,b::Symbol) at string.jl:524",
          "isless(a::VersionNumber,b::VersionNumber) at version.jl:130",
          "isless(i::Segment,j::Segment) at quadgk.jl:43",
          "isless{T}(a::HierarchicalValue{T},b::HierarchicalValue{T}) at pkg/resolve/versionweight.jl:63",
          "isless(a::VWPreBuildItem,b::VWPreBuildItem) at pkg/resolve/versionweight.jl:91",
          "isless(a::VWPreBuild,b::VWPreBuild) at pkg/resolve/versionweight.jl:128",
          "isless(a::VersionWeight,b::VersionWeight) at pkg/resolve/versionweight.jl:182",
          "isless(a::FieldValue,b::FieldValue) at pkg/resolve/fieldvalue.jl:44",
          "isless(t1::CalendarTime,t2::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:184"
        ]
      },
      {
        "name": "islink",
        "summary": "Function",
        "help": "Base.islink(path) -> Bool\n\n   Returns \"true\" if \"path\" is a symbolic link, \"false\"\n   otherwise.\n",
        "methods": 
        [
          "islink(st::StatStruct) at stat.jl:67",
          "islink(path...) at stat.jl:108"
        ]
      },
      {
        "name": "islower",
        "summary": "Function",
        "help": "Base.islower(c::Union(Char, String)) -> Bool\n\n   Tests whether a character is a lowercase letter, or whether this is\n   true for all elements of a string.\n",
        "methods": 
        [
          "islower(c::Char) at string.jl:548",
          "islower(s::String) at string.jl:549"
        ]
      },
      {
        "name": "ismatch",
        "summary": "Function",
        "help": "Base.ismatch(r::Regex, s::String) -> Bool\n\n   Test whether a string contains a match of the given regular\n   expression.\n",
        "methods": 
        [
          "ismatch(r::Regex,s::SubString{T<:String}) at regex.jl:104",
          "ismatch(r::Regex,s::SubString{T<:String},offset::Integer) at regex.jl:104",
          "ismatch(r::Regex,s::String) at regex.jl:100",
          "ismatch(r::Regex,s::String,offset::Integer) at regex.jl:100"
        ]
      },
      {
        "name": "isnan",
        "summary": "Function",
        "help": "Base.isnan(f) -> Bool\n\n   Test whether a floating point number is not a number (NaN)\n",
        "methods": 
        [
          "isnan(x::Float16) at float16.jl:106",
          "isnan(x::BigFloat) at mpfr.jl:659",
          "isnan(x::FloatingPoint) at float.jl:215",
          "isnan(x::Real) at float.jl:216",
          "isnan(z::Complex{T<:Real}) at complex.jl:42",
          "isnan{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "isnan{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "isnan{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "isodd",
        "summary": "Function",
        "help": "Base.isodd(x::Integer) -> Bool\n\n   Returns \"true\" if \"x\" is odd (that is, not divisible by 2), and\n   \"false\" otherwise.\n\n   **Examples**:\n\n      julia> isodd(9)\n      false\n\n      julia> isodd(10)\n      true\n",
        "methods": 
        [
          "isodd(n::Integer) at int.jl:53"
        ]
      },
      {
        "name": "isopen",
        "summary": "Function",
        "help": "Base.isopen(stream) -> Bool\n\n   Determine whether a stream is open (i.e. has not been closed yet).\n   If the connection has been closed remotely (in case of e.g. a\n   socket), \"isopen\" will return \"false\" even though buffered data\n   may still be available. Use \"eof\" to check if necessary.\n",
        "methods": 
        [
          "isopen(io::IOBuffer) at iobuffer.jl:168",
          "isopen(s::IOStream) at io.jl:266",
          "isopen(f::Union(AsyncFile,File)) at fs.jl:61",
          "isopen(s::Session) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:91",
          "isopen(x) at stream.jl:276"
        ]
      },
      {
        "name": "ispath",
        "summary": "Function",
        "help": "Base.ispath(path) -> Bool\n\n   Returns \"true\" if \"path\" is a valid filesystem path, \"false\"\n   otherwise.\n",
        "methods": 
        [
          "ispath(st::StatStruct) at stat.jl:61",
          "ispath(path...) at stat.jl:105"
        ]
      },
      {
        "name": "isperm",
        "summary": "Function",
        "help": "Base.isperm(v) -> Bool\n\n   Returns true if v is a valid permutation.\n",
        "methods": 
        [
          "isperm(A) at combinatorics.jl:175"
        ]
      },
      {
        "name": "isposdef",
        "summary": "Function",
        "help": "Base.isposdef(A) -> Bool\n\n   Test whether a matrix is positive definite.\n",
        "methods": 
        [
          "isposdef(D::Diagonal{T}) at linalg/diagonal.jl:34",
          "isposdef{T}(A::AbstractArray{T,2},UL::Symbol) at linalg/dense.jl:26",
          "isposdef{T}(A::AbstractArray{T,2}) at linalg/dense.jl:27",
          "isposdef(x::Number) at linalg/dense.jl:28",
          "isposdef(A::Union(Eigen{T,V},GeneralizedEigen{T,V})) at linalg/factorization.jl:522"
        ]
      },
      {
        "name": "isposdef!",
        "summary": "Function",
        "help": "Base.isposdef!(A) -> Bool\n\n   Test whether a matrix is positive definite, overwriting \"A\" in\n   the processes.\n",
        "methods": 
        [
          "isposdef!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),UL::Symbol) at linalg/dense.jl:23",
          "isposdef!(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/dense.jl:24",
          "isposdef!{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti}(A::SparseMatrixCSC{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti}) at linalg/cholmod.jl:1036"
        ]
      },
      {
        "name": "ispow2",
        "summary": "Function",
        "help": "Base.ispow2(n) -> Bool\n\n   Test whether \"n\" is a power of two\n",
        "methods": 
        [
          "ispow2(x::Integer) at intfuncs.jl:117"
        ]
      },
      {
        "name": "isprime",
        "summary": "Function",
        "help": "Base.isprime(x::Integer) -> Bool\n\n   Returns \"true\" if \"x\" is prime, and \"false\" otherwise.\n\n   **Example**:\n\n      julia> isprime(3)\n      true\n",
        "methods": 
        [
          "isprime(n::Uint128) at primes.jl:69",
          "isprime(n::Int128) at primes.jl:71",
          "isprime(x::BigInt) at gmp.jl:437",
          "isprime(x::BigInt,reps) at gmp.jl:437",
          "isprime(n::Integer) at primes.jl:37"
        ]
      },
      {
        "name": "isprint",
        "summary": "Function",
        "help": "Base.isprint(c::Union(Char, String)) -> Bool\n\n   Tests whether a character is printable, including space, or whether\n   this is true for all elements of a string.\n",
        "methods": 
        [
          "isprint(c::Char) at string.jl:548",
          "isprint(s::String) at string.jl:549"
        ]
      },
      {
        "name": "ispunct",
        "summary": "Function",
        "help": "Base.ispunct(c::Union(Char, String)) -> Bool\n\n   Tests whether a character is printable, and not a space or\n   alphanumeric, or whether this is true for all elements of a string.\n",
        "methods": 
        [
          "ispunct(c::Char) at string.jl:548",
          "ispunct(s::String) at string.jl:549"
        ]
      },
      {
        "name": "isqrt",
        "summary": "Function",
        "help": "Base.isqrt(n)\n\n   Integer square root: the largest integer \"m\" such that \"m*m <=\n   n\".\n",
        "methods": 
        [
          "isqrt(x::Union(Uint128,Uint64,Int128,Int64)) at intfuncs.jl:288",
          "isqrt(x::BigInt) at gmp.jl:329",
          "isqrt(x::Integer) at intfuncs.jl:285"
        ]
      },
      {
        "name": "isreadable",
        "summary": "Function",
        "help": "Base.isreadable(path) -> Bool\n\n   Returns \"true\" if the current user has permission to read\n   \"path\", \"false\" otherwise.\n",
        "methods": 
        [
          "isreadable(io::IOBuffer) at iobuffer.jl:89",
          "isreadable(s::IOStream) at io.jl:274",
          "isreadable(io::Union(TTY,Pipe)) at stream.jl:203",
          "isreadable(io::TcpSocket) at socket.jl:321",
          "isreadable(st::StatStruct) at stat.jl:76",
          "isreadable(f::FDEvent) at poll.jl:51",
          "isreadable(path...) at stat.jl:105"
        ]
      },
      {
        "name": "isreadonly",
        "summary": "Function",
        "help": "Base.isreadonly(stream) -> Bool\n\n   Determine whether a stream is read-only.\n",
        "methods": 
        [
          "isreadonly(s) at io.jl:25"
        ]
      },
      {
        "name": "isready",
        "summary": "Function",
        "help": "Base.isready(RemoteRef)\n\n   Determine whether a \"RemoteRef\" has a value stored to it. Note\n   that this function can easily cause race conditions, since by the\n   time you receive its result it may no longer be true. It is\n   recommended that this function only be used on a \"RemoteRef\" that\n   is assigned once.\n",
        "methods": 
        [
          "isready(rr::RemoteRef) at multi.jl:477"
        ]
      },
      {
        "name": "isreal",
        "summary": "Function",
        "help": "Base.isreal(x) -> Bool\n\n   Test whether \"x\" or all its elements are numerically equal to\n   some real number\n",
        "methods": 
        [
          "isreal(x::Real) at complex.jl:37",
          "isreal(z::Complex{T<:Real}) at complex.jl:38",
          "isreal{T<:Real,n}(x::AbstractArray{T<:Real,n}) at abstractarray.jl:19",
          "isreal(x::AbstractArray{T,N}) at abstractarray.jl:18"
        ]
      },
      {
        "name": "issetgid",
        "summary": "Function",
        "help": "Base.issetgid(path) -> Bool\n\n   Returns \"true\" if \"path\" has the setgid flag set, \"false\"\n   otherwise.\n",
        "methods": 
        [
          "issetgid(st::StatStruct) at stat.jl:73",
          "issetgid(path...) at stat.jl:105"
        ]
      },
      {
        "name": "issetuid",
        "summary": "Function",
        "help": "Base.issetuid(path) -> Bool\n\n   Returns \"true\" if \"path\" has the setuid flag set, \"false\"\n   otherwise.\n",
        "methods": 
        [
          "issetuid(st::StatStruct) at stat.jl:72",
          "issetuid(path...) at stat.jl:105"
        ]
      },
      {
        "name": "issocket",
        "summary": "Function",
        "help": "Base.issocket(path) -> Bool\n\n   Returns \"true\" if \"path\" is a socket, \"false\" otherwise.\n",
        "methods": 
        [
          "issocket(st::StatStruct) at stat.jl:68",
          "issocket(path...) at stat.jl:105"
        ]
      },
      {
        "name": "issorted",
        "summary": "Function",
        "help": "Base.issorted(v, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Test whether a vector is in sorted order. The \"by\", \"lt\" and\n   \"rev\" keywords modify what order is considered to be sorted just\n   as they do for \"sort\".\n",
        "methods": 
        [
          "issorted(r::UnitRange{T<:Real}) at range.jl:493",
          "issorted(r::Range{T}) at range.jl:494",
          "issorted(itr,order::Ordering) at sort.jl:41",
          "issorted(itr) at sort.jl:51"
        ]
      },
      {
        "name": "isspace",
        "summary": "Function",
        "help": "Base.isspace(c::Union(Char, String)) -> Bool\n\n   Tests whether a character is any whitespace character, or whether\n   this is true for all elements of a string.\n",
        "methods": 
        [
          "isspace(c::Char) at string.jl:548",
          "isspace(s::String) at string.jl:549"
        ]
      },
      {
        "name": "issparse",
        "summary": "Function",
        "help": "Base.issparse(S)\n\n   Returns \"true\" if \"S\" is sparse, and \"false\" otherwise.\n",
        "methods": 
        [
          "issparse(S::AbstractSparseArray{Tv,Ti,N}) at sparse/abstractsparse.jl:7",
          "issparse(A::AbstractArray{T,N}) at sparse/abstractsparse.jl:6"
        ]
      },
      {
        "name": "issticky",
        "summary": "Function",
        "help": "Base.issticky(path) -> Bool\n\n   Returns \"true\" if \"path\" has the sticky bit set, \"false\"\n   otherwise.\n",
        "methods": 
        [
          "issticky(st::StatStruct) at stat.jl:74",
          "issticky(path...) at stat.jl:105"
        ]
      },
      {
        "name": "issubnormal",
        "summary": "Function",
        "help": "Base.issubnormal(f) -> Bool\n\n   Test whether a floating point number is subnormal\n",
        "methods": 
        [
          "issubnormal(x::Float32) at float.jl:268",
          "issubnormal(x::Float64) at float.jl:269"
        ]
      },
      {
        "name": "issubset",
        "summary": "Function",
        "help": "Base.issubset(a, b)\n\n   Determine whether every element of \"a\" is also in \"b\", using\n   the \"in\" function.\n\nBase.issubset(A, S) -> Bool\n\n   True if \"A ⊆ S\" (A is a subset of or equal to S)\n",
        "methods": 
        [
          "issubset(a::IntSet,b::IntSet) at intset.jl:289",
          "issubset(l,r) at set.jl:87"
        ]
      },
      {
        "name": "issym",
        "summary": "Function",
        "help": "Base.issym(A) -> Bool\n\n   Test whether a matrix is symmetric.\n",
        "methods": 
        [
          "issym(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:1572",
          "issym{T<:Real}(A::Hermitian{T<:Real}) at linalg/symmetric.jl:29",
          "issym{T<:Complex{T<:Real}}(A::Hermitian{T<:Complex{T<:Real}}) at linalg/symmetric.jl:30",
          "issym(A::Symmetric{T}) at linalg/symmetric.jl:31",
          "issym(D::Diagonal{T}) at linalg/diagonal.jl:33",
          "issym(A::BitArray{2}) at linalg/bitarray.jl:135",
          "issym(A::AbstractArray{T,2}) at linalg/generic.jl:251",
          "issym(x::Number) at linalg/generic.jl:261",
          "issym(B::BunchKaufman{T}) at linalg/bunchkaufman.jl:29"
        ]
      },
      {
        "name": "istaskdone",
        "summary": "Function",
        "help": "Base.istaskdone(task) -> Bool\n\n   Tell whether a task has exited.\n",
        "methods": 
        [
          "istaskdone(t::Task) at task.jl:10"
        ]
      },
      {
        "name": "istext",
        "summary": "Function",
        "help": "Base.istext(m::MIME)\n\n   Determine whether a MIME type is text data.\n",
        "methods": 
        [
          "istext(::MIME{:text/vnd.graphviz}) at multimedia.jl:66",
          "istext(::MIME{:text/latex}) at multimedia.jl:66",
          "istext(::MIME{:text/calendar}) at multimedia.jl:66",
          "istext(::MIME{:text/n3}) at multimedia.jl:66",
          "istext(::MIME{:text/richtext}) at multimedia.jl:66",
          "istext(::MIME{:text/x-setext}) at multimedia.jl:66",
          "istext(::MIME{:text/sgml}) at multimedia.jl:66",
          "istext(::MIME{:text/tab-separated-values}) at multimedia.jl:66",
          "istext(::MIME{:text/x-vcalendar}) at multimedia.jl:66",
          "istext(::MIME{:text/x-vcard}) at multimedia.jl:66",
          "istext(::MIME{:text/cmd}) at multimedia.jl:66",
          "istext(::MIME{:text/css}) at multimedia.jl:66",
          "istext(::MIME{:text/csv}) at multimedia.jl:66",
          "istext(::MIME{:text/html}) at multimedia.jl:66",
          "istext(::MIME{:text/javascript}) at multimedia.jl:66",
          "istext(::MIME{:text/markdown}) at multimedia.jl:66",
          "istext(::MIME{:text/plain}) at multimedia.jl:66",
          "istext(::MIME{:text/vcard}) at multimedia.jl:66",
          "istext(::MIME{:text/xml}) at multimedia.jl:66",
          "istext(::MIME{:application/atom+xml}) at multimedia.jl:66",
          "istext(::MIME{:application/ecmascript}) at multimedia.jl:66",
          "istext(::MIME{:application/json}) at multimedia.jl:66",
          "istext(::MIME{:application/rdf+xml}) at multimedia.jl:66",
          "istext(::MIME{:application/rss+xml}) at multimedia.jl:66",
          "istext(::MIME{:application/xml-dtd}) at multimedia.jl:66",
          "istext(::MIME{:application/postscript}) at multimedia.jl:66",
          "istext(::MIME{:image/svg+xml}) at multimedia.jl:66",
          "istext(::MIME{:application/x-latex}) at multimedia.jl:66",
          "istext(::MIME{:application/xhtml+xml}) at multimedia.jl:66",
          "istext(::MIME{:application/javascript}) at multimedia.jl:66",
          "istext(::MIME{:application/xml}) at multimedia.jl:66",
          "istext(::MIME{:model/x3d+xml}) at multimedia.jl:66",
          "istext(::MIME{:model/x3d+vrml}) at multimedia.jl:66",
          "istext(::MIME{:model/vrml}) at multimedia.jl:66",
          "istext(::MIME{mime}) at multimedia.jl:75",
          "istext(m::String) at multimedia.jl:86"
        ]
      },
      {
        "name": "istril",
        "summary": "Function",
        "help": "Base.istril(A) -> Bool\n\n   Test whether a matrix is lower triangular.\n",
        "methods": 
        [
          "istril{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:1599",
          "istril(A::Triangular{T<:Number}) at linalg/triangular.jl:95",
          "istril(M::Bidiagonal{T}) at linalg/bidiag.jl:74",
          "istril(A::BitArray{2}) at linalg/bitarray.jl:174",
          "istril(A::AbstractArray{T,2}) at linalg/generic.jl:287",
          "istril(x::Number) at linalg/generic.jl:297"
        ]
      },
      {
        "name": "istriu",
        "summary": "Function",
        "help": "Base.istriu(A) -> Bool\n\n   Test whether a matrix is upper triangular.\n",
        "methods": 
        [
          "istriu{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:1584",
          "istriu(A::Triangular{T<:Number}) at linalg/triangular.jl:96",
          "istriu(M::Bidiagonal{T}) at linalg/bidiag.jl:73",
          "istriu(A::BitArray{2}) at linalg/bitarray.jl:165",
          "istriu(A::AbstractArray{T,2}) at linalg/generic.jl:277",
          "istriu(x::Number) at linalg/generic.jl:296"
        ]
      },
      {
        "name": "isupper",
        "summary": "Function",
        "help": "Base.isupper(c::Union(Char, String)) -> Bool\n\n   Tests whether a character is an uppercase letter, or whether this\n   is true for all elements of a string.\n",
        "methods": 
        [
          "isupper(c::Char) at string.jl:548",
          "isupper(s::String) at string.jl:549"
        ]
      },
      {
        "name": "isvalid",
        "summary": "Function",
        "help": "Base.isvalid(str, i)\n\n   Tells whether index \"i\" is valid for the given string\n",
        "methods": 
        [
          "isvalid(s::UTF8String,i::Integer) at utf8.jl:95",
          "isvalid(s::DirectIndexString,i::Integer) at string.jl:96",
          "isvalid(s::String,i::Integer) at string.jl:98",
          "isvalid{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(cd::CholmodDense{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/cholmod.jl:345",
          "isvalid{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:609",
          "isvalid{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:615",
          "isvalid{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(T::CholmodTriplet{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:621",
          "isvalid{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:609",
          "isvalid{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:615",
          "isvalid{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(T::CholmodTriplet{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:621",
          "isvalid(uri::URI) at /home/samuel/.julia/v0.3/URIParser/src/utils.jl:61"
        ]
      },
      {
        "name": "iswritable",
        "summary": "Function",
        "help": "Base.iswritable(path) -> Bool\n\n   Returns \"true\" if the current user has permission to write to\n   \"path\", \"false\" otherwise.\n",
        "methods": 
        [
          "iswritable(io::IOBuffer) at iobuffer.jl:90",
          "iswritable(s::IOStream) at io.jl:273",
          "iswritable(io::Union(TTY,Pipe)) at stream.jl:205",
          "iswritable(io::TcpSocket) at socket.jl:322",
          "iswritable(st::StatStruct) at stat.jl:77",
          "iswritable(f::FDEvent) at poll.jl:52",
          "iswritable(path...) at stat.jl:105"
        ]
      },
      {
        "name": "iswriteable",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "iswriteable(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "isxdigit",
        "summary": "Function",
        "help": "Base.isxdigit(c::Union(Char, String)) -> Bool\n\n   Tests whether a character is a valid hexadecimal digit, or whether\n   this is true for all elements of a string.\n",
        "methods": 
        [
          "isxdigit(c::Char) at string.jl:853",
          "isxdigit(s::String) at string.jl:854"
        ]
      },
      {
        "name": "itrunc",
        "summary": "Function",
        "help": "Base.itrunc(x) -> Integer\n\n   Returns the nearest integer not greater in magnitude than \"x\".\n",
        "methods": 
        [
          "itrunc(x::Integer) at int.jl:375",
          "itrunc(x::Float32) at float.jl:75",
          "itrunc(x::Float64) at float.jl:77",
          "itrunc(x::BigFloat) at mpfr.jl:647",
          "itrunc(x::FloatingPoint) at float.jl:61",
          "itrunc{T<:Integer}(::Type{T<:Integer},x::FloatingPoint) at float.jl:66",
          "itrunc(x::Rational{T<:Integer}) at rational.jl:156",
          "itrunc(B::BitArray{N}) at bitarray.jl:787",
          "itrunc{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "itrunc{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "itrunc{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "itrunc{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "join",
        "summary": "Function",
        "help": "Base.join(strings, delim)\n\n   Join an array of strings into a single string, inserting the given\n   delimiter between adjacent strings.\n",
        "methods": 
        [
          "join(args...) at string.jl:1395"
        ]
      },
      {
        "name": "joinpath",
        "summary": "Function",
        "help": "Base.joinpath(parts...) -> String\n\n   Join path components into a full path. If some argument is an\n   absolute path, then prior components are dropped.\n",
        "methods": 
        [
          "joinpath(a::String) at path.jl:57",
          "joinpath(a::String,b::String) at path.jl:61",
          "joinpath(a::String,b::String,c::String...) at path.jl:58"
        ]
      },
      {
        "name": "keys",
        "summary": "Function",
        "help": "Base.keys(collection)\n\n   Return an iterator over all keys in a collection.\n   \"collect(keys(d))\" returns an array of keys.\n",
        "methods": 
        [
          "keys(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "keys(a::Associative{K,V}) at dict.jl:64",
          "keys(ct::Accumulator{T,V<:Number}) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:33",
          "keys(cc::ClassifiedCollections{K,Collection}) at /home/samuel/.julia/v0.3/DataStructures/src/classifiedcollections.jl:33",
          "keys(t::Trie{T}) at /home/samuel/.julia/v0.3/DataStructures/src/trie.jl:62",
          "keys(t::Trie{T},prefix::String) at /home/samuel/.julia/v0.3/DataStructures/src/trie.jl:62",
          "keys(t::Trie{T},prefix::String,found) at /home/samuel/.julia/v0.3/DataStructures/src/trie.jl:62"
        ]
      },
      {
        "name": "kill",
        "summary": "Function",
        "help": "Base.kill(p::Process, signum=SIGTERM)\n\n   Send a signal to a process. The default is to terminate the\n   process.\n",
        "methods": 
        [
          "kill(p::Process,signum::Integer) at process.jl:517",
          "kill(ps::Array{Process,1}) at process.jl:524",
          "kill(ps::ProcessChain) at process.jl:525",
          "kill(p::Process) at process.jl:526"
        ]
      },
      {
        "name": "kron",
        "summary": "Function",
        "help": "Base.kron(A, B)\n\n   Kronecker tensor product of two vectors or two matrices.\n",
        "methods": 
        [
          "kron{T,S}(a::Array{T,2},b::Array{S,2}) at linalg/dense.jl:136",
          "kron(a::Number,b::Union(Array{T,1},Array{T,2},Number)) at linalg/dense.jl:148",
          "kron(a::Union(Array{T,1},Array{T,2}),b::Number) at linalg/dense.jl:149",
          "kron(a::Array{T,1},b::Array{T,1}) at linalg/dense.jl:150",
          "kron(a::Array{T,2},b::Array{T,1}) at linalg/dense.jl:151",
          "kron(a::Array{T,1},b::Array{T,2}) at linalg/dense.jl:152",
          "kron(a::BitArray{1},b::BitArray{1}) at linalg/bitarray.jl:105",
          "kron(a::BitArray{2},b::BitArray{2}) at linalg/bitarray.jl:117",
          "kron{Tv,Ti}(a::SparseMatrixCSC{Tv,Ti},b::SparseMatrixCSC{Tv,Ti}) at linalg/sparse.jl:519",
          "kron{Tv1,Ti1,Tv2,Ti2}(A::SparseMatrixCSC{Tv1,Ti1},B::SparseMatrixCSC{Tv2,Ti2}) at linalg/sparse.jl:574",
          "kron(A::SparseMatrixCSC{Tv,Ti<:Integer},B::Union(Array{T,1},Array{T,2})) at linalg/sparse.jl:581",
          "kron(A::Union(Array{T,1},Array{T,2}),B::SparseMatrixCSC{Tv,Ti<:Integer}) at linalg/sparse.jl:582",
          "kron(a,b,c) at operators.jl:82",
          "kron(a,b,c,xs...) at operators.jl:83"
        ]
      },
      {
        "name": "last",
        "summary": "Function",
        "help": "Base.last(coll)\n\n   Get the last element of an ordered collection, if it can be\n   computed in O(1) time. This is accomplished by calling \"endof\" to\n   get the last index.\n",
        "methods": 
        [
          "last{T}(r::StepRange{T,S}) at range.jl:197",
          "last(r::UnitRange{T<:Real}) at range.jl:198",
          "last{T}(r::FloatRange{T}) at range.jl:199",
          "last(x::Number) at number.jl:19",
          "last(s::IntSet) at intset.jl:155",
          "last(a) at abstractarray.jl:27"
        ]
      },
      {
        "name": "lbeta",
        "summary": "Function",
        "help": "Base.lbeta(x, y)\n\n   Natural logarithm of the absolute value of the beta function\n   \\log(|\\operatorname{B}(x,y)|).\n",
        "methods": 
        [
          "lbeta(x::Number,w::Number) at math.jl:1120",
          "lbeta{T1<:Number,T2<:Number}(::T1<:Number,::AbstractArray{T2<:Number,N}) at operators.jl:365",
          "lbeta{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::T2<:Number) at operators.jl:367",
          "lbeta{T1<:Number,T2<:Number}(::AbstractArray{T1<:Number,N},::AbstractArray{T2<:Number,N}) at operators.jl:371"
        ]
      },
      {
        "name": "lcfirst",
        "summary": "Function",
        "help": "Base.lcfirst(string)\n\n   Returns \"string\" with the first character converted to lowercase.\n",
        "methods": 
        [
          "lcfirst(s::ASCIIString) at ascii.jl:50",
          "lcfirst(s::String) at string.jl:805"
        ]
      },
      {
        "name": "lcm",
        "summary": "Function",
        "help": "Base.lcm(x, y)\n\n   Least common (non-negative) multiple.\n",
        "methods": 
        [
          "lcm(x::BigInt,y::BigInt) at gmp.jl:193",
          "lcm{T<:Integer}(a::T<:Integer,b::T<:Integer) at intfuncs.jl:13",
          "lcm(a::Integer) at intfuncs.jl:16",
          "lcm(a::Integer,b::Integer) at intfuncs.jl:18",
          "lcm(a::Integer,b::Integer...) at intfuncs.jl:20",
          "lcm{T<:Integer}(abc::AbstractArray{T<:Integer,N}) at intfuncs.jl:23"
        ]
      },
      {
        "name": "ldexp",
        "summary": "Function",
        "help": "Base.ldexp(x, n)\n\n   Compute x \\times 2^n\n",
        "methods": 
        [
          "ldexp(x::Float64,e::Int64) at math.jl:378",
          "ldexp(x::Float32,e::Int64) at math.jl:379",
          "ldexp(a::Float16,b::Integer) at float16.jl:139",
          "ldexp(x::BigFloat,n::Int64) at mpfr.jl:410",
          "ldexp(x::BigFloat,n::Uint64) at mpfr.jl:415",
          "ldexp(x::BigFloat,n::Union(Int8,Int64,Int16,Int32)) at mpfr.jl:419",
          "ldexp(x::BigFloat,n::Union(Uint16,Uint8,Uint32,Uint64)) at mpfr.jl:420",
          "ldexp(x::BigFloat,n::Integer) at mpfr.jl:421"
        ]
      },
      {
        "name": "ldltfact",
        "summary": "Function",
        "help": "Base.ldltfact(A) -> LDLtFactorization\n\n   Compute a factorization of a positive definite matrix \"A\" such\n   that \"A=L*Diagonal(d)*L'\" where \"L\" is a unit lower triangular\n   matrix and \"d\" is a vector with non-negative elements.\n",
        "methods": 
        [
          "ldltfact{T}(M::SymTridiagonal{T}) at linalg/ldlt.jl:28"
        ]
      },
      {
        "name": "ldltfact!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "ldltfact!{T<:Real}(S::SymTridiagonal{T<:Real}) at linalg/ldlt.jl:17"
        ]
      },
      {
        "name": "leading_ones",
        "summary": "Function",
        "help": "Base.leading_ones(x::Integer) -> Integer\n\n   Number of ones leading the binary representation of \"x\".\n\n   **Example**: \"leading_ones(int32(2 ^ 32 - 2)) -> 31\"\n",
        "methods": 
        [
          "leading_ones(x::Integer) at int.jl:239"
        ]
      },
      {
        "name": "leading_zeros",
        "summary": "Function",
        "help": "Base.leading_zeros(x::Integer) -> Integer\n\n   Number of zeros leading the binary representation of \"x\".\n\n   **Example**: \"leading_zeros(int32(1)) -> 31\"\n",
        "methods": 
        [
          "leading_zeros(x::Int8) at int.jl:216",
          "leading_zeros(x::Uint8) at int.jl:217",
          "leading_zeros(x::Int16) at int.jl:218",
          "leading_zeros(x::Uint16) at int.jl:219",
          "leading_zeros(x::Int32) at int.jl:220",
          "leading_zeros(x::Uint32) at int.jl:221",
          "leading_zeros(x::Int64) at int.jl:222",
          "leading_zeros(x::Uint64) at int.jl:223",
          "leading_zeros(x::Int128) at int.jl:224",
          "leading_zeros(x::Uint128) at int.jl:225"
        ]
      },
      {
        "name": "length",
        "summary": "Function",
        "help": "Base.length(collection) -> Integer\n\n   For ordered, indexable collections, the maximum index \"i\" for\n   which \"getindex(collection, i)\" is valid. For unordered\n   collections, the number of elements.\n\nBase.length(s)\n\n   The number of characters in string \"s\".\n\nBase.length(A) -> Integer\n\n   Returns the number of elements in A\n",
        "methods": 
        [
          "length(mt::MethodTable) at reflection.jl:114",
          "length(t::(Any...,)) at tuple.jl:3",
          "length{T<:Union(Uint64,Int64)}(r::StepRange{T<:Union(Uint64,Int64),S}) at range.jl:181",
          "length(r::StepRange{T,S}) at range.jl:174",
          "length{T<:Union(Uint64,Int64)}(r::UnitRange{T<:Union(Uint64,Int64)}) at range.jl:191",
          "length(r::UnitRange{T<:Real}) at range.jl:177",
          "length(r::FloatRange{T<:FloatingPoint}) at range.jl:178",
          "length(x::Number) at number.jl:12",
          "length(a::Array{T,N}) at array.jl:21",
          "length(B::BitArray{N}) at bitarray.jl:42",
          "length(S::SharedArray{T,N}) at sharedarray.jl:114",
          "length(r::CalendarTimeRange{T<:AbstractCalendarDuration}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:402",
          "length(t::AbstractArray{T,N}) at abstractarray.jl:23",
          "length(s::IntSet) at intset.jl:166",
          "length(v::Union(ValueIterator{T<:Associative{K,V}},KeyIterator{T<:Associative{K,V}})) at dict.jl:43",
          "length(d::ObjectIdDict) at dict.jl:197",
          "length(t::Dict{K,V}) at dict.jl:579",
          "length(t::WeakKeyDict{K,V}) at dict.jl:655",
          "length(s::Set{T}) at set.jl:13",
          "length(e::Enumerate{I}) at iterator.jl:10",
          "length(z::Zip{I<:(Any...,)}) at iterator.jl:30",
          "length(z::Zip2{I1,I2}) at iterator.jl:54",
          "length(s::UTF8String) at utf8.jl:40",
          "length(s::UTF32String) at string.jl:576",
          "length(s::DirectIndexString) at string.jl:79",
          "length(s::RepString) at string.jl:693",
          "length(s::RevString{T<:String}) at string.jl:733",
          "length(s::RopeString) at string.jl:788",
          "length(s::String) at string.jl:81",
          "length(::EnvHash) at env.jl:133",
          "length(pq::PriorityQueue{K,V}) at collections.jl:166",
          "length(c::Combinations{T}) at combinatorics.jl:240",
          "length(c::Permutations{T}) at combinatorics.jl:280",
          "length(p::IntegerPartitions) at combinatorics.jl:313",
          "length(f::FixedPartitions) at combinatorics.jl:379",
          "length(p::SetPartitions{T<:AbstractArray{T,1}}) at combinatorics.jl:437",
          "length(p::FixedSetPartitions{T<:AbstractArray{T,1}}) at combinatorics.jl:504",
          "length(d::SpDiagIterator{Tv,Ti}) at sparse/sparsematrix.jl:1681",
          "length(blk::DequeBlock{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:33",
          "length(q::Deque{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:77",
          "length(s::Stack{S}) at /home/samuel/.julia/v0.3/DataStructures/src/stack.jl:11",
          "length(s::Queue{S}) at /home/samuel/.julia/v0.3/DataStructures/src/queue.jl:11",
          "length(a::Accumulator{T,V<:Number}) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:25",
          "length(cc::ClassifiedCollections{K,Collection}) at /home/samuel/.julia/v0.3/DataStructures/src/classifiedcollections.jl:25",
          "length(s::IntDisjointSets) at /home/samuel/.julia/v0.3/DataStructures/src/disjoint_set.jl:25",
          "length(s::DisjointSets{T}) at /home/samuel/.julia/v0.3/DataStructures/src/disjoint_set.jl:107",
          "length(h::BinaryHeap{T,Comp}) at /home/samuel/.julia/v0.3/DataStructures/src/heaps/binary_heap.jl:133",
          "length(h::MutableBinaryHeap{VT,Comp}) at /home/samuel/.julia/v0.3/DataStructures/src/heaps/mutable_binary_heap.jl:196",
          "length(t::HashDict{K,V,O<:Union(Nothing,Int64)}) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:494",
          "length(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "length(::OrderedSet{T},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "length(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "length(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "length(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "length(l::Nil{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:55",
          "length(l::Cons{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:58",
          "length(::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:68",
          "length(it::Take{I}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:48",
          "length(it::Repeat{O}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:127",
          "length(p::Product) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:212",
          "length(it::Subsets) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:465"
        ]
      },
      {
        "name": "less",
        "summary": "Function",
        "help": "Base.less(file::String[, line])\n\n   Show a file using the default pager, optionally providing a\n   starting line number. Returns to the julia prompt when you quit the\n   pager.\n\nBase.less(function[, types])\n\n   Show the definition of a function using the default pager,\n   optionally specifying a tuple of types to indicate which method to\n   see.\n",
        "methods": 
        [
          "less(file::String,line::Integer) at interactiveutil.jl:50",
          "less(file::String) at interactiveutil.jl:53",
          "less(f::Union(DataType,Function)) at interactiveutil.jl:56",
          "less(f::Union(DataType,Function),t::(Type{T<:Top}...,)) at interactiveutil.jl:57"
        ]
      },
      {
        "name": "lexcmp",
        "summary": "Function",
        "help": "Base.lexcmp(x, y)\n\n   Compare \"x\" and \"y\" lexicographically and return -1, 0, or 1\n   depending on whether \"x\" is less than, equal to, or greater than\n   \"y\", respectively. This function should be defined for\n   lexicographically comparable types, and \"lexless\" will call\n   \"lexcmp\" by default.\n",
        "methods": 
        [
          "lexcmp(x::Real,y::Real) at operators.jl:45",
          "lexcmp(a::Complex{T<:Real},b::Complex{T<:Real}) at complex.jl:684",
          "lexcmp(a::Array{Uint8,1},b::Array{Uint8,1}) at array.jl:830",
          "lexcmp(A::AbstractArray{T,N},B::AbstractArray{T,N}) at abstractarray.jl:852",
          "lexcmp(x,y) at operators.jl:50"
        ]
      },
      {
        "name": "lexless",
        "summary": "Function",
        "help": "Base.lexless(x, y)\n\n   Determine whether \"x\" is lexicographically less than \"y\".\n",
        "methods": 
        [
          "lexless(x,y) at operators.jl:51"
        ]
      },
      {
        "name": "lfact",
        "summary": "Function",
        "help": "Base.lfact(x)\n\n   Compute the logarithmic factorial of \"x\"\n",
        "methods": 
        [
          "lfact(x::Real) at math.jl:351",
          "lfact{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "lfact{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "lfact{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "lgamma",
        "summary": "Function",
        "help": "Base.lgamma(x)\n\n   Compute the logarithm of absolute value of \"gamma(x)\"\n",
        "methods": 
        [
          "lgamma(x::Float64) at math.jl:277",
          "lgamma(x::Float32) at math.jl:278",
          "lgamma(x::BigFloat) at mpfr.jl:563",
          "lgamma(x::Real) at math.jl:279",
          "lgamma{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "lgamma{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "lgamma{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357",
          "lgamma(z::Complex{T<:Real}) at math.jl:746"
        ]
      },
      {
        "name": "linreg",
        "summary": "Function",
        "help": "Base.linreg(x, y) -> [a; b]\n\n   Linear Regression. Returns \"a\" and \"b\" such that \"a+b*x\" is\n   the closest line to the given points \"(x,y)\". In other words,\n   this function determines parameters \"[a, b]\" that minimize the\n   squared error between \"y\" and \"a+b*x\".\n\n   **Example**:\n\n      using PyPlot;\n      x = float([1:12])\n      y = [5.5; 6.3; 7.6; 8.8; 10.9; 11.79; 13.48; 15.02; 17.77; 20.81; 22.0; 22.99]\n      a, b = linreg(x,y) # Linear regression\n      plot(x, y, \"o\") # Plot (x,y) points\n      plot(x, [a+b*i for i in x]) # Plot the line determined by the linear regression\n\nBase.linreg(x, y, w)\n\n   Weighted least-squares linear regression.\n",
        "methods": 
        [
          "linreg{T<:Number}(X::Union(SubArray{T<:Number,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,2},DenseArray{T<:Number,1},SubArray{T<:Number,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),y::Array{T<:Number,1}) at linalg/generic.jl:299",
          "linreg(x::AbstractArray{T,1},y::AbstractArray{T,1},w::AbstractArray{T,1}) at linalg/generic.jl:303"
        ]
      },
      {
        "name": "linspace",
        "summary": "Function",
        "help": "Base.linspace(start, stop, n)\n\n   Construct a vector of \"n\" linearly-spaced elements from \"start\"\n   to \"stop\".\n",
        "methods": 
        [
          "linspace(start::Integer,stop::Integer,n::Integer) at array.jl:193",
          "linspace(start::Real,stop::Real,n::Integer) at array.jl:196",
          "linspace(start::Real,stop::Real) at array.jl:210"
        ]
      },
      {
        "name": "listen",
        "summary": "Function",
        "help": "Base.listen([addr], port) -> TcpServer\n\n   Listen on port on the address specified by \"addr\". By default\n   this listens on localhost only. To listen on all interfaces pass,\n   \"IPv4(0)\" or \"IPv6(0)\" as appropriate.\n\nBase.listen(path) -> PipeServer\n\n   Listens on/Creates a Named Pipe/Domain Socket\n",
        "methods": 
        [
          "listen(path::Union(UTF8String,ASCIIString)) at stream.jl:878",
          "listen(sock::UVServer) at socket.jl:620",
          "listen(cb::Union(Function,Bool),sock::Socket) at socket.jl:632",
          "listen(cb::Union(Function,Bool),args...) at socket.jl:631",
          "listen(port::Integer) at socket.jl:628",
          "listen(host::IpAddr,port::Integer) at socket.jl:629",
          "listen(addr) at socket.jl:623"
        ]
      },
      {
        "name": "listenany",
        "summary": "Function",
        "help": "Base.listenany(port_hint) -> (Uint16, TcpServer)\n\n   Create a TcpServer on any port, using hint as a starting point.\n   Returns a tuple of the actual port that the server was created on\n   and the server itself.\n",
        "methods": 
        [
          "listenany(default_port) at socket.jl:653"
        ]
      },
      {
        "name": "localindexes",
        "summary": "Function",
        "help": "Base.localindexes(d)\n\n   A tuple describing the indexes owned by the local process. Returns\n   a tuple with empty ranges if no local part exists on the calling\n   process.\n",
        "methods": 
        [
          "localindexes(d::DArray{T,N,A}) at darray.jl:135",
          "localindexes(S::SharedArray{T,N}) at sharedarray.jl:136"
        ]
      },
      {
        "name": "localize",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "localize(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "localpart",
        "summary": "Function",
        "help": "Base.localpart(d)\n\n   Get the local piece of a distributed array. Returns an empty array\n   if no local part exists on the calling process.\n",
        "methods": 
        [
          "localpart{T,N,A}(d::DArray{T,N,A}) at darray.jl:127"
        ]
      },
      {
        "name": "log",
        "summary": "Function",
        "help": "Base.log(x)\n\n   Compute the natural logarithm of \"x\". Throws \"DomainError\" for\n   negative \"Real\" arguments. Use complex negative arguments\n   instead.\n\nBase.log(b, x)\n\n   Compute the base \"b\" logarithm of \"x\". Throws \"DomainError\"\n   for negative \"Real\" arguments.\n",
        "methods": 
        [
          "log(a::Complex{Float16}) at float16.jl:134",
          "log{T<:FloatingPoint}(z::Complex{T<:FloatingPoint}) at complex.jl:285",
          "log(z::Complex{T<:Real}) at complex.jl:305",
          "log(x::Float64) at math.jl:277",
          "log(x::Float32) at math.jl:278",
          "log(a::Float16) at float16.jl:133",
          "log(x::BigFloat) at mpfr.jl:486",
          "log(::MathConst{:e}) at constants.jl:81",
          "log(::MathConst{:e},x) at constants.jl:82",
          "log(x::Real) at math.jl:279",
          "log{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "log{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "log{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "log{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357",
          "log(b,x) at math.jl:243"
        ]
      },
      {
        "name": "log10",
        "summary": "Function",
        "help": "Base.log10(x)\n\n   Compute the logarithm of \"x\" to base 10. Throws \"DomainError\"\n   for negative \"Real\" arguments.\n",
        "methods": 
        [
          "log10(z::Complex{T<:Real}) at complex.jl:326",
          "log10(x::Float64) at math.jl:277",
          "log10(x::Float32) at math.jl:278",
          "log10(x::BigFloat) at mpfr.jl:486",
          "log10(x::Real) at math.jl:279",
          "log10{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "log10{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "log10{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "log10{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "log1p",
        "summary": "Function",
        "help": "Base.log1p(x)\n\n   Accurate natural logarithm of \"1+x\".  Throws \"DomainError\" for\n   \"Real\" arguments less than -1.\n",
        "methods": 
        [
          "log1p{T}(z::Complex{T}) at complex.jl:376",
          "log1p(x::Float64) at math.jl:277",
          "log1p(x::Float32) at math.jl:278",
          "log1p(x::BigFloat) at mpfr.jl:496",
          "log1p(x::Real) at math.jl:279",
          "log1p(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:464",
          "log1p{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "log1p{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "log1p{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "log2",
        "summary": "Function",
        "help": "Base.log2(x)\n\n   Compute the logarithm of \"x\" to base 2. Throws \"DomainError\"\n   for negative \"Real\" arguments.\n",
        "methods": 
        [
          "log2(z::Complex{T<:Real}) at complex.jl:327",
          "log2(x::Float64) at math.jl:277",
          "log2(x::Float32) at math.jl:278",
          "log2(x::BigFloat) at mpfr.jl:486",
          "log2(x::Real) at math.jl:279",
          "log2{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "log2{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "log2{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "log2{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "logb",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "logb(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "logdet",
        "summary": "Function",
        "help": "Base.logdet(M)\n\n   Log of matrix determinant. Equivalent to \"log(det(M))\", but may\n   provide increased accuracy and/or speed.\n",
        "methods": 
        [
          "logdet(A::Array{T,2}) at linalg/dense.jl:324",
          "logdet{T}(C::Cholesky{T}) at linalg/factorization.jl:116",
          "logdet{T<:Real,S}(A::LU{T<:Real,S}) at linalg/lu.jl:132",
          "logdet{T<:Complex{T<:Real},S}(A::LU{T<:Complex{T<:Real},S}) at linalg/lu.jl:138",
          "logdet{T<:Real}(D::Diagonal{T<:Real}) at linalg/diagonal.jl:80",
          "logdet{T<:Complex{T<:Real}}(D::Diagonal{T<:Complex{T<:Real}}) at linalg/diagonal.jl:82",
          "logdet(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:1020",
          "logdet{Tv,Ti}(L::CholmodFactor{Tv,Ti},sub) at linalg/cholmod.jl:1016"
        ]
      },
      {
        "name": "logspace",
        "summary": "Function",
        "help": "Base.logspace(start, stop, n)\n\n   Construct a vector of \"n\" logarithmically-spaced numbers from\n   \"10^start\" to \"10^stop\".\n",
        "methods": 
        [
          "logspace(start::Real,stop::Real,n::Integer) at array.jl:212",
          "logspace(start::Real,stop::Real) at array.jl:213"
        ]
      },
      {
        "name": "lowercase",
        "summary": "Function",
        "help": "Base.lowercase(string)\n\n   Returns \"string\" with all characters converted to lowercase.\n",
        "methods": 
        [
          "lowercase(s::ASCIIString) at ascii.jl:74",
          "lowercase(c::Char) at string.jl:796",
          "lowercase(s::String) at string.jl:799"
        ]
      },
      {
        "name": "lpad",
        "summary": "Function",
        "help": "Base.lpad(string, n, p)\n\n   Make a string at least \"n\" characters long by padding on the left\n   with copies of \"p\".\n",
        "methods": 
        [
          "lpad(s::String,n::Integer) at string.jl:1248",
          "lpad(s::String,n::Integer,p::String) at string.jl:1248",
          "lpad(s,n::Integer) at string.jl:1271",
          "lpad(s,n::Integer,p) at string.jl:1271"
        ]
      },
      {
        "name": "ls",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "ls(args...) at deprecated.jl:205"
        ]
      },
      {
        "name": "lstat",
        "summary": "Function",
        "help": "Base.lstat(file)\n\n   Like stat, but for symbolic links gets the info for the link itself\n   rather than the file it refers to. This function must be called on\n   a file path rather than a file object or a file descriptor.\n",
        "methods": 
        [
          "lstat(path::Union(UTF8String,ASCIIString)) at stat.jl:53",
          "lstat(path::String) at stat.jl:54",
          "lstat(path...) at stat.jl:57"
        ]
      },
      {
        "name": "lstrip",
        "summary": "Function",
        "help": "Base.lstrip(string[, chars])\n\n   Return \"string\" with any leading whitespace removed. If \"chars\"\n   (a character, or vector or set of characters) is provided, instead\n   remove characters contained in it.\n",
        "methods": 
        [
          "lstrip(s::String) at string.jl:1421",
          "lstrip(s::String,chars::Union(Char,Set{Char},AbstractArray{Char,1})) at string.jl:1421",
          "lstrip(a::String,b::String) at deprecated.jl:26"
        ]
      },
      {
        "name": "ltoh",
        "summary": "Function",
        "help": "Base.ltoh(x)\n\n   Converts the endianness of a value from Little-endian to that used\n   by the Host.\n",
        "methods": 
        [
          "ltoh(x) at io.jl:19"
        ]
      },
      {
        "name": "lu",
        "summary": "Function",
        "help": "Base.lu(A) -> L, U, p\n\n   Compute the LU factorization of \"A\", such that \"A[p,:] = L*U\".\n",
        "methods": 
        [
          "lu(x::Number) at linalg/lu.jl:69",
          "lu(A::AbstractArray{T,2}) at linalg/lu.jl:71"
        ]
      },
      {
        "name": "lufact",
        "summary": "Function",
        "help": "Base.lufact(A[, pivot=true]) -> F\n\n   Compute the LU factorization of \"A\". The return type of \"F\"\n   depends on the type of \"A\". In most cases, if \"A\" is a subtype\n   \"S\" of AbstractMatrix with an element type \"T`\" supporting\n   \"+\", \"-\", \"*\" and \"/\" the return type is \"LU{T,S{T}}\". If\n   pivoting is chosen (default) the element type should also support\n   \"abs\" and \"<\". When \"A\" is sparse and have element of type\n   \"Float32\", \"Float64\", \"Complex{Float32}\", or\n   \"Complex{Float64}\" the return type is \"UmfpackLU\". Some\n   examples are shown in the table below.\n\n      +-------------------------+---------------------------+------------------------------------------+\n      | Type of input \\\"A\\\"     | Type of output \\\"F\\\"      | Relationship between \\\"F\\\" and \\\"A\\\"     |\n      +-------------------------+---------------------------+------------------------------------------+\n      | \\\"Matrix()\\\"            | \\\"LU\\\"                    | \\\"F[:L]*F[:U] == A[F[:p], :]\\\"           |\n      +-------------------------+---------------------------+------------------------------------------+\n      | \\\"Tridiagonal()\\\"       | \\\"LU{T,Tridiagonal{T}}\\\"  | N/A                                      |\n      +-------------------------+---------------------------+------------------------------------------+\n      | \\\"SparseMatrixCSC()\\\"   | \\\"UmfpackLU\\\"             | \\\"F[:L]*F[:U] == Rs .* A[F[:p], F[:q]]\\\" |\n      +-------------------------+---------------------------+------------------------------------------+\n\n   The individual components of the factorization \"F\" can be\n   accessed by indexing:\n\n      +-------------+-----------------------------------------+--------+--------------------------+---------------+\n      | Component   | Description                             | \\\"LU\\\" | \\\"LU{T,Tridiagonal{T}}\\\" | \\\"UmfpackLU\\\" |\n      +-------------+-----------------------------------------+--------+--------------------------+---------------+\n      +-------------+-----------------------------------------+--------+--------------------------+---------------+\n      +-------------+-----------------------------------------+--------+--------------------------+---------------+\n      +-------------+-----------------------------------------+--------+--------------------------+---------------+\n      +-------------+-----------------------------------------+--------+--------------------------+---------------+\n      +-------------+-----------------------------------------+--------+--------------------------+---------------+\n      +-------------+-----------------------------------------+--------+--------------------------+---------------+\n      +-------------+-----------------------------------------+--------+--------------------------+---------------+\n\n      +--------------------+--------+--------------------------+---------------+\n      | Supported function | \\\"LU\\\" | \\\"LU{T,Tridiagonal{T}}\\\" | \\\"UmfpackLU\\\" |\n      +--------------------+--------+--------------------------+---------------+\n      +--------------------+--------+--------------------------+---------------+\n      | \\\"\\\\\\\"             | ✓      | ✓                        | ✓             |\n      +--------------------+--------+--------------------------+---------------+\n      +--------------------+--------+--------------------------+---------------+\n      | \\\"det\\\"            | ✓      | ✓                        | ✓             |\n      +--------------------+--------+--------------------------+---------------+\n      +--------------------+--------+--------------------------+---------------+\n",
        "methods": 
        [
          "lufact{Tv<:Union(Float64,Complex{Float64}),Ti<:Union(Int64,Int32)}(S::SparseMatrixCSC{Tv<:Union(Float64,Complex{Float64}),Ti<:Union(Int64,Int32)}) at linalg/umfpack.jl:110",
          "lufact{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::AbstractArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2}) at linalg/lu.jl:64",
          "lufact{T}(A::AbstractArray{T,2}) at linalg/lu.jl:65",
          "lufact(x::Number) at linalg/lu.jl:66",
          "lufact(F::LU{T,S<:AbstractArray{T,2}}) at linalg/lu.jl:67"
        ]
      },
      {
        "name": "lufact!",
        "summary": "Function",
        "help": "Base.lufact!(A) -> LU\n\n   \"lufact!\" is the same as \"lufact()\", but saves space by\n   overwriting the input A, instead of creating a copy.  For sparse\n   \"A\" the \"nzval\" field is not overwritten but the index fields,\n   \"colptr\" and \"rowval\" are decremented in place, converting from\n   1-based indices to 0-based indices.\n",
        "methods": 
        [
          "lufact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/lu.jl:12",
          "lufact!(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/lu.jl:16",
          "lufact!{T}(A::Tridiagonal{T}) at linalg/lu.jl:154",
          "lufact!{Tv<:Union(Float64,Complex{Float64}),Ti<:Union(Int64,Int32)}(S::SparseMatrixCSC{Tv<:Union(Float64,Complex{Float64}),Ti<:Union(Int64,Int32)}) at linalg/umfpack.jl:122"
        ]
      },
      {
        "name": "macroexpand",
        "summary": "Function",
        "help": "Base.macroexpand(x)\n\n   Takes the expression x and returns an equivalent expression with\n   all macros removed (expanded).\n",
        "methods": 
        [
          "macroexpand(x) at expr.jl:58"
        ]
      },
      {
        "name": "map",
        "summary": "Function",
        "help": "Base.map(f, c...) -> collection\n\n   Transform collection \"c\" by applying \"f\" to each element. For\n   multiple collection arguments, apply \"f\" elementwise.\n\n   **Examples**:\n\n      julia> map((x) -> x * 2, [1, 2, 3])\n      [2, 4, 6]\n      julia> map(+, [1, 2, 3], [10, 20, 30])\n      [11, 22, 33]\n",
        "methods": 
        [
          "map(f::Union(DataType,Function),a::Array{Any,1}) at base.jl:182",
          "map(f::Function,s::String) at string.jl:811",
          "map(f::Union(DataType,Function)) at tuple.jl:43",
          "map(f::Union(DataType,Function),t::()) at tuple.jl:45",
          "map(f::Union(DataType,Function),t::(Any,)) at tuple.jl:46",
          "map(f::Union(DataType,Function),t::(Any,Any)) at tuple.jl:47",
          "map(f::Union(DataType,Function),t::(Any,Any,Any)) at tuple.jl:48",
          "map(f::Union(DataType,Function),t::(),s::()) at tuple.jl:51",
          "map(f::Union(DataType,Function),t::(Any,),s::(Any,)) at tuple.jl:52",
          "map(f::Union(DataType,Function),t::(Any,Any),s::(Any,Any)) at tuple.jl:53",
          "map(f::Union(DataType,Function),t::(Any...,)) at tuple.jl:49",
          "map(f::Union(DataType,Function),ts::(Any...,)...) at tuple.jl:59",
          "map(f::Union(DataType,Function),x::Number) at number.jl:44",
          "map(f::Union(DataType,Function),d::DArray{T,N,A}) at darray.jl:301",
          "map(f::Union(DataType,Function),S::SharedArray{T,N}) at sharedarray.jl:273",
          "map(f::Union(DataType,Function),A::AbstractArray{T,N}) at abstractarray.jl:1312",
          "map(f::Union(DataType,Function),A::AbstractArray{T,N},B::AbstractArray{T,N}) at abstractarray.jl:1337",
          "map(f::Union(DataType,Function),As::AbstractArray{T,N}...) at abstractarray.jl:1367",
          "map(f::Union(DataType,Function),l::Nil{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:65",
          "map(f::Union(DataType,Function),l::Cons{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:68",
          "map(f::Union(DataType,Function),iters...) at abstractarray.jl:1180"
        ]
      },
      {
        "name": "map!",
        "summary": "Function",
        "help": "Base.map!(function, collection)\n\n   In-place version of \"map()\".\n\nBase.map!(function, destination, collection...)\n\n   Like \"map()\", but stores the result in \"destination\" rather\n   than a new collection. \"destination\" must be at least as large as\n   the first collection.\n",
        "methods": 
        [
          "map!(f::Union(DataType,Function),S::SharedArray{T,N}) at sharedarray.jl:281",
          "map!(f::Union(DataType,Function),A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at bitarray.jl:1421",
          "map!(f::Union(DataType,Function),d::DArray{T,N,A}) at darray.jl:309",
          "map!(f::Union(DataType,Function),dest,r::Range{T}) at range.jl:512",
          "map!(f::Union(DataType,Function),dest::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at bitarray.jl:1428",
          "map!(f::Union(DataType,Function),dest::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at bitarray.jl:1435",
          "map!(f::Union(DataType,Function),dest::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Number) at bitarray.jl:1442",
          "map!(f::Union(DataType,Function),dest::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),A::Number,B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at bitarray.jl:1449",
          "map!(f::Union(DataType,Function),dest::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),As::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})...) at bitarray.jl:1456"
        ]
      },
      {
        "name": "mapreduce",
        "summary": "Function",
        "help": "Base.mapreduce(f, op, itr)\n\n   Applies function \"f\" to each element in \"itr\" and then reduces\n   the result using the binary function \"op\".\n\n   **Example**: \"mapreduce(x->x^2, +, [1:3]) == 1 + 4 + 9 == 14\"\n\n   The associativity of the reduction is implementation-dependent; if\n   you need a particular associativity, e.g. left-to-right, you should\n   write your own loop. See documentation for \"reduce\".\n",
        "methods": 
        [
          "mapreduce(f::Union(DataType,Function),op::Union(DataType,Function),A::AbstractArray{T,N}) at reduce.jl:690",
          "mapreduce(f::Union(DataType,Function),op::Union(DataType,Function),itr) at reduce.jl:649",
          "mapreduce(f::Union(DataType,Function),op::Union(DataType,Function),v0,A::AbstractArray{T,N}) at reduce.jl:694",
          "mapreduce(f::Union(DataType,Function),op::Union(DataType,Function),v0,itr) at reduce.jl:669"
        ]
      },
      {
        "name": "mapslices",
        "summary": "Function",
        "help": "Base.mapslices(f, A, dims)\n\n   Transform the given dimensions of array \"A\" using function \"f\".\n   \"f\" is called on each slice of \"A\" of the form\n   \"A[...,:,...,:,...]\". \"dims\" is an integer vector specifying\n   where the colons go in this expression. The results are\n   concatenated along the remaining dimensions. For example, if\n   \"dims\" is \"[1,2]\" and A is 4-dimensional, \"f\" is called on\n   \"A[:,:,i,j]\" for all \"i\" and \"j\".\n",
        "methods": 
        [
          "mapslices(f::Function,A::AbstractArray{T,N},dims::AbstractArray{T,1}) at abstractarray.jl:1207",
          "mapslices(f::Function,A::AbstractArray{T,N},dims) at abstractarray.jl:1205"
        ]
      },
      {
        "name": "match",
        "summary": "Function",
        "help": "Base.match(r::Regex, s::String[, idx::Integer[, addopts]])\n\n   Search for the first match of the regular expression \"r\" in \"s\"\n   and return a RegexMatch object containing the match, or nothing if\n   the match failed. The matching substring can be retrieved by\n   accessing \"m.match\" and the captured sequences can be retrieved\n   by accessing \"m.captures\"\n",
        "methods": 
        [
          "match(re::Regex,str::UTF8String,idx::Integer) at regex.jl:109",
          "match(re::Regex,str::UTF8String,idx::Integer,add_opts::Uint32) at regex.jl:109",
          "match(re::Regex,str::Union(ASCIIString,SubString{T<:String},UTF8String),idx::Integer) at regex.jl:120",
          "match(re::Regex,str::Union(ASCIIString,SubString{T<:String},UTF8String),idx::Integer,add_opts::Uint32) at regex.jl:120",
          "match(r::Regex,s::String) at regex.jl:123",
          "match(r::Regex,s::String,i::Integer) at regex.jl:124"
        ]
      },
      {
        "name": "matchall",
        "summary": "Function",
        "help": "Base.matchall(r::Regex, s::String[, overlap::Bool=false]) -> Vector{String}\n\n   Return a vector of the matching substrings from eachmatch.\n",
        "methods": 
        [
          "matchall(re::Regex,str::UTF8String) at regex.jl:128",
          "matchall(re::Regex,str::UTF8String,overlap::Bool) at regex.jl:128",
          "matchall(re::Regex,str::Union(ASCIIString,SubString{T<:String},UTF8String)) at regex.jl:167",
          "matchall(re::Regex,str::Union(ASCIIString,SubString{T<:String},UTF8String),overlap::Bool) at regex.jl:167"
        ]
      },
      {
        "name": "max",
        "summary": "Function",
        "help": "Base.max(x, y, ...)\n\n   Return the maximum of the arguments. Operates elementwise over\n   arrays.\n",
        "methods": 
        [
          "max(x::BigFloat,y::BigFloat) at mpfr.jl:505",
          "max{T<:FloatingPoint}(x::T<:FloatingPoint,y::T<:FloatingPoint) at math.jl:354",
          "max{T<:Real}(x::T<:Real,y::T<:Real) at promotion.jl:201",
          "max(x::Real,y::Real) at promotion.jl:181",
          "max{T1<:Real,T2<:Real}(::T1<:Real,::AbstractArray{T2<:Real,N}) at operators.jl:365",
          "max{T1<:Real,T2<:Real}(::AbstractArray{T1<:Real,N},::T2<:Real) at operators.jl:367",
          "max{T1<:Real,T2<:Real}(::AbstractArray{T1<:Real,N},::AbstractArray{T2<:Real,N}) at operators.jl:371",
          "max(f::Function,x) at deprecated.jl:26",
          "max(x,_::(),d) at deprecated.jl:26",
          "max(x,y) at operators.jl:56",
          "max(a,b,c) at operators.jl:82",
          "max(a,b,c,xs...) at operators.jl:83",
          "max(x) at deprecated.jl:26"
        ]
      },
      {
        "name": "maximum",
        "summary": "Function",
        "help": "Base.maximum(itr)\n\n   Returns the largest element in a collection.\n\nBase.maximum(A, dims)\n\n   Compute the maximum value of an array over the given dimensions.\n",
        "methods": 
        [
          "maximum(r::UnitRange{T<:Real}) at range.jl:202",
          "maximum(r::Range{T}) at range.jl:204",
          "maximum(f::Union(Func{1},Function),A::AbstractArray{T,N}) at reduce.jl:521",
          "maximum(f::Union(Func{1},Function),itr) at reduce.jl:452",
          "maximum(B::BitArray{N}) at bitarray.jl:1416",
          "maximum{T}(A::SparseMatrixCSC{T,Ti<:Integer}) at sparse/sparsematrix.jl:686",
          "maximum{T}(A::SparseMatrixCSC{T,Ti<:Integer},region) at sparse/sparsematrix.jl:691",
          "maximum(A::AbstractArray{T,N}) at reduce.jl:534",
          "maximum(x::Real) at reduce.jl:548",
          "maximum{T}(A::AbstractArray{T,N},region) at reducedim.jl:206",
          "maximum(itr) at reduce.jl:479"
        ]
      },
      {
        "name": "maximum!",
        "summary": "Function",
        "help": "Base.maximum!(r, A)\n\n   Compute the maximum value of \"A\" over the singleton dimensions of\n   \"r\", and write results to \"r\".\n",
        "methods": 
        [
          "maximum!{R}(r::AbstractArray{R,N},A::AbstractArray{T,N}) at reducedim.jl:205"
        ]
      },
      {
        "name": "maxintfloat",
        "summary": "Function",
        "help": "Base.maxintfloat(type)\n\n   The largest integer losslessly representable by the given floating-\n   point type\n",
        "methods": 
        [
          "maxintfloat(::Type{Float64}) at floatfuncs.jl:19",
          "maxintfloat(::Type{Float32}) at floatfuncs.jl:20",
          "maxintfloat(::Type{Float16}) at floatfuncs.jl:21",
          "maxintfloat(x::BigFloat) at mpfr.jl:597",
          "maxintfloat{T<:FloatingPoint}(x::T<:FloatingPoint) at floatfuncs.jl:22",
          "maxintfloat() at floatfuncs.jl:23",
          "maxintfloat(::Type{BigFloat}) at mpfr.jl:598"
        ]
      },
      {
        "name": "mean",
        "summary": "Function",
        "help": "Base.mean(v[, region])\n\n   Compute the mean of whole array \"v\", or optionally along the\n   dimensions in \"region\". Note: Julia does not ignore \"NaN\"\n   values in the computation. For applications requiring the handling\n   of missing data, the \"DataArray\" package is recommended.\n",
        "methods": 
        [
          "mean(v::AbstractArray{T,N}) at statistics.jl:15",
          "mean{T}(v::AbstractArray{T,N},region) at statistics.jl:29",
          "mean(iterable) at statistics.jl:2"
        ]
      },
      {
        "name": "mean!",
        "summary": "Function",
        "help": "Base.mean!(r, v)\n\n   Compute the mean of \"v\" over the singleton dimensions of \"r\",\n   and write results to \"r\".\n",
        "methods": 
        [
          "mean!{T}(r::AbstractArray{T,N},v::AbstractArray{T,N}) at statistics.jl:18"
        ]
      },
      {
        "name": "median",
        "summary": "Function",
        "help": "Base.median(v; checknan::Bool=true)\n\n   Compute the median of a vector \"v\". If keyword argument\n   \"checknan\" is true (the default), an error is raised for data\n   containing NaN values. Note: Julia does not ignore \"NaN\" values\n   in the computation. For applications requiring the handling of\n   missing data, the \"DataArray\" package is recommended.\n",
        "methods": 
        [
          "median{T<:Real}(v::AbstractArray{T<:Real,N}) at statistics.jl:47",
          "median{T}(v::AbstractArray{T,N},region) at statistics.jl:49"
        ]
      },
      {
        "name": "median!",
        "summary": "Function",
        "help": "Base.median!(v; checknan::Bool=true)\n\n   Like \"median\", but may overwrite the input vector.\n",
        "methods": 
        [
          "median!{T<:Real}(v::AbstractArray{T<:Real,1}) at statistics.jl:33"
        ]
      },
      {
        "name": "memio",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "memio(args...) at deprecated.jl:26"
        ]
      },
      {
        "name": "merge",
        "summary": "Function",
        "help": "Base.merge(collection, others...)\n\n   Construct a merged collection from the given collections.\n",
        "methods": 
        [
          "merge(d::Associative{K,V},others::Associative{K,V}...) at dict.jl:83",
          "merge{T,V<:Number}(ct1::Accumulator{T,V<:Number},ct2::Accumulator{T,V<:Number}) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:59"
        ]
      },
      {
        "name": "merge!",
        "summary": "Function",
        "help": "Base.merge!(collection, others...)\n\n   Update collection with pairs from the other collections\n",
        "methods": 
        [
          "merge!(d::Associative{K,V},others::Associative{K,V}...) at dict.jl:76"
        ]
      },
      {
        "name": "methods",
        "summary": "Function",
        "help": "Base.methods(f[, types])\n\n   Show all methods of \"f\" with their argument types.\n\n   If \"types\" is specified, an array of methods whose types match is\n   returned.\n",
        "methods": 
        [
          "methods(f::Function) at reflection.jl:104",
          "methods(t::DataType) at reflection.jl:110",
          "methods(f::ANY,t::ANY) at reflection.jl:76"
        ]
      },
      {
        "name": "methodswith",
        "summary": "Function",
        "help": "Base.methodswith(typ[, showparents])\n\n   Return an array of methods with an argument of type \"typ\". If\n   optional \"showparents\" is \"true\", also return arguments with a\n   parent type of \"typ\", excluding type \"Any\".\n",
        "methods": 
        [
          "methodswith(t::Type{T<:Top},m::Module) at interactiveutil.jl:254",
          "methodswith(t::Type{T<:Top},m::Module,showparents::Bool) at interactiveutil.jl:254",
          "methodswith(t::Type{T<:Top}) at interactiveutil.jl:275",
          "methodswith(t::Type{T<:Top},showparents::Bool) at interactiveutil.jl:275"
        ]
      },
      {
        "name": "midpoints",
        "summary": "Function",
        "help": "Base.midpoints(e)\n\n   Compute the midpoints of the bins with edges \"e\". The result is a\n   vector/range of length \"length(e) - 1\". Note: Julia does not\n   ignore \"NaN\" values in the computation.\n",
        "methods": 
        [
          "midpoints(r::Range{T}) at statistics.jl:470",
          "midpoints(v::AbstractArray{T,1}) at statistics.jl:471"
        ]
      },
      {
        "name": "mimewritable",
        "summary": "Function",
        "help": "Base.mimewritable(mime, x)\n\n   Returns a boolean value indicating whether or not the object \"x\"\n   can be written as the given \"mime\" type.  (By default, this is\n   determined automatically by the existence of the corresponding\n   \"writemime\" function for \"typeof(x)\".)\n",
        "methods": 
        [
          "mimewritable{mime}(::MIME{mime},x) at multimedia.jl:37",
          "mimewritable(m::String,x) at multimedia.jl:42"
        ]
      },
      {
        "name": "min",
        "summary": "Function",
        "help": "Base.min(x, y, ...)\n\n   Return the minimum of the arguments. Operates elementwise over\n   arrays.\n",
        "methods": 
        [
          "min(x::BigFloat,y::BigFloat) at mpfr.jl:511",
          "min{T<:FloatingPoint}(x::T<:FloatingPoint,y::T<:FloatingPoint) at math.jl:357",
          "min{T<:Real}(x::T<:Real,y::T<:Real) at promotion.jl:202",
          "min(x::Real,y::Real) at promotion.jl:182",
          "min{T1<:Real,T2<:Real}(::T1<:Real,::AbstractArray{T2<:Real,N}) at operators.jl:365",
          "min{T1<:Real,T2<:Real}(::AbstractArray{T1<:Real,N},::T2<:Real) at operators.jl:367",
          "min{T1<:Real,T2<:Real}(::AbstractArray{T1<:Real,N},::AbstractArray{T2<:Real,N}) at operators.jl:371",
          "min(f::Function,x) at deprecated.jl:26",
          "min(x,_::(),d) at deprecated.jl:26",
          "min(x,y) at operators.jl:57",
          "min(a,b,c) at operators.jl:82",
          "min(a,b,c,xs...) at operators.jl:83",
          "min(x) at deprecated.jl:26"
        ]
      },
      {
        "name": "minimum",
        "summary": "Function",
        "help": "Base.minimum(itr)\n\n   Returns the smallest element in a collection.\n\nBase.minimum(A, dims)\n\n   Compute the minimum value of an array over the given dimensions.\n",
        "methods": 
        [
          "minimum(r::UnitRange{T<:Real}) at range.jl:201",
          "minimum(r::Range{T}) at range.jl:203",
          "minimum(f::Union(Func{1},Function),A::AbstractArray{T,N}) at reduce.jl:528",
          "minimum(f::Union(Func{1},Function),itr) at reduce.jl:466",
          "minimum(B::BitArray{N}) at bitarray.jl:1415",
          "minimum{T}(A::SparseMatrixCSC{T,Ti<:Integer}) at sparse/sparsematrix.jl:695",
          "minimum{T}(A::SparseMatrixCSC{T,Ti<:Integer},region) at sparse/sparsematrix.jl:700",
          "minimum(A::AbstractArray{T,N}) at reduce.jl:535",
          "minimum(x::Real) at reduce.jl:549",
          "minimum{T}(A::AbstractArray{T,N},region) at reducedim.jl:211",
          "minimum(itr) at reduce.jl:480"
        ]
      },
      {
        "name": "minimum!",
        "summary": "Function",
        "help": "Base.minimum!(r, A)\n\n   Compute the minimum value of \"A\" over the singleton dimensions of\n   \"r\", and write results to \"r\".\n",
        "methods": 
        [
          "minimum!{R}(r::AbstractArray{R,N},A::AbstractArray{T,N}) at reducedim.jl:210"
        ]
      },
      {
        "name": "minmax",
        "summary": "Function",
        "help": "Base.minmax(x, y)\n\n   Return \"(min(x,y), max(x,y))\". See also: \"extrema()\" that\n   returns \"(minimum(x), maximum(x))\"\n",
        "methods": 
        [
          "minmax{T<:FloatingPoint}(x::T<:FloatingPoint,y::T<:FloatingPoint) at math.jl:360",
          "minmax{T<:Real}(x::T<:Real,y::T<:Real) at promotion.jl:203",
          "minmax(x::Real,y::Real) at promotion.jl:183"
        ]
      },
      {
        "name": "mkdir",
        "summary": "Function",
        "help": "Base.mkdir(path[, mode])\n\n   Make a new directory with name \"path\" and permissions \"mode\".\n   \"mode\" defaults to 0o777, modified by the current file creation\n   mask.\n",
        "methods": 
        [
          "mkdir(path::String) at file.jl:38",
          "mkdir(path::String,mode::Unsigned) at file.jl:38",
          "mkdir(path::String,mode::Signed) at file.jl:51"
        ]
      },
      {
        "name": "mkpath",
        "summary": "Function",
        "help": "Base.mkpath(path[, mode])\n\n   Create all directories in the given \"path\", with permissions\n   \"mode\". \"mode\" defaults to 0o777, modified by the current file\n   creation mask.\n",
        "methods": 
        [
          "mkpath(path::String) at file.jl:44",
          "mkpath(path::String,mode::Unsigned) at file.jl:44",
          "mkpath(path::String,mode::Signed) at file.jl:52"
        ]
      },
      {
        "name": "mktemp",
        "summary": "Function",
        "help": "Base.mktemp()\n\n   Returns \"(path, io)\", where \"path\" is the path of a new\n   temporary file and \"io\" is an open file object for this path.\n",
        "methods": 
        [
          "mktemp() at file.jl:83"
        ]
      },
      {
        "name": "mktempdir",
        "summary": "Function",
        "help": "Base.mktempdir()\n\n   Create a temporary directory and return its path.\n",
        "methods": 
        [
          "mktempdir() at file.jl:117"
        ]
      },
      {
        "name": "mmap",
        "summary": "Function",
        "help": "Base.mmap(len, prot, flags, fd, offset)\n\n   Low-level interface to the mmap system call. See the man page.\n",
        "methods": 
        [
          "mmap(len::Integer,prot::Integer,flags::Integer,fd,offset::Integer) at mmap.jl:22"
        ]
      },
      {
        "name": "mmap_array",
        "summary": "Function",
        "help": "Base.mmap_array(type, dims, stream[, offset])\n\n   Create an \"Array\" whose values are linked to a file, using\n   memory-mapping. This provides a convenient way of working with data\n   too large to fit in the computer's memory.\n\n   The type determines how the bytes of the array are interpreted.\n   Note that the file must be stored in binary format, and no format\n   conversions are possible (this is a limitation of operating\n   systems, not Julia).\n\n   dims is a tuple specifying the size of the array.\n\n   The file is passed via the stream argument.  When you initialize\n   the stream, use \"\"r\"\" for a \"read-only\" array, and \"\"w+\"\"\n   to create a new array used to write values to disk.\n\n   Optionally, you can specify an offset (in bytes) if, for example,\n   you want to skip over a header in the file. The default value for\n   the offset is the current stream position.\n\n   **Example**:\n\n      # Create a file for mmapping\n      # (you could alternatively use mmap_array to do this step, too)\n      A = rand(1:20, 5, 30)\n      s = open(\"/tmp/mmap.bin\", \"w+\")\n      # We'll write the dimensions of the array as the first two Ints in the file\n      write(s, size(A,1))\n      write(s, size(A,2))\n      # Now write the data\n      write(s, A)\n      close(s)\n\n      # Test by reading it back in\n      s = open(\"/tmp/mmap.bin\")   # default is read-only\n      m = read(s, Int)\n      n = read(s, Int)\n      A2 = mmap_array(Int, (m,n), s)\n\n   This would create a m-by-n \"Matrix{Int}\", linked to the file\n   associated with stream \"s\".\n\n   A more portable file would need to encode the word size---32 bit or\n   64 bit---and endianness information in the header. In practice,\n   consider encoding binary data using standard formats like HDF5\n   (which can be used with memory-mapping).\n",
        "methods": 
        [
          "mmap_array{T,N}(::Type{T},dims::NTuple{N,Integer},s::IO) at mmap.jl:4",
          "mmap_array{T,N}(::Type{T},dims::NTuple{N,Integer},s::IO,offset::Int64) at mmap.jl:102"
        ]
      },
      {
        "name": "mmap_bitarray",
        "summary": "Function",
        "help": "Base.mmap_bitarray([type], dims, stream[, offset])\n\n   Create a \"BitArray\" whose values are linked to a file, using\n   memory-mapping; it has the same purpose, works in the same way, and\n   has the same arguments, as \"mmap_array()\", but the byte\n   representation is different. The \"type\" parameter is optional,\n   and must be \"Bool\" if given.\n\n   **Example**:  \"B = mmap_bitarray((25,30000), s)\"\n\n   This would create a 25-by-30000 \"BitArray\", linked to the file\n   associated with stream \"s\".\n",
        "methods": 
        [
          "mmap_bitarray{N}(::Type{Bool},dims::NTuple{N,Integer},s::IOStream,offset::Int64) at mmap.jl:9",
          "mmap_bitarray{N}(::Type{Bool},dims::NTuple{N,Integer},s::IOStream) at mmap.jl:11",
          "mmap_bitarray{N}(dims::NTuple{N,Integer},s::IOStream) at mmap.jl:12",
          "mmap_bitarray{N}(dims::NTuple{N,Integer},s::IOStream,offset::Int64) at mmap.jl:171"
        ]
      },
      {
        "name": "mmread",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "mmread(file) at deprecated.jl:374",
          "mmread(file,infoonly) at deprecated.jl:378"
        ]
      },
      {
        "name": "mod",
        "summary": "Function",
        "help": "Base.mod(x, m)\n\n   Modulus after division, returning in the range [0,m)\n",
        "methods": 
        [
          "mod(x::Bool,y::Bool) at bool.jl:60",
          "mod(x::Signed,y::Unsigned) at int.jl:88",
          "mod(x::Unsigned,y::Signed) at int.jl:89",
          "mod(A::BitArray{N},B::BitArray{N}) at bitarray.jl:913",
          "mod(A::BitArray{N},B::Array{Bool,N}) at bitarray.jl:917",
          "mod(A::Array{Bool,N},B::BitArray{N}) at bitarray.jl:918",
          "mod{S,T}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:724",
          "mod{T<:Union(Int8,Int64,Int16,Int32)}(x::T<:Union(Int8,Int64,Int16,Int32),y::T<:Union(Int8,Int64,Int16,Int32)) at int.jl:101",
          "mod{T<:Unsigned}(x::T<:Unsigned,y::T<:Unsigned) at int.jl:103",
          "mod(x::Int128,y::Int128) at int.jl:598",
          "mod{T<:FloatingPoint}(x::T<:FloatingPoint,y::T<:FloatingPoint) at float.jl:140",
          "mod(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:113",
          "mod(x::BigInt,y::BigInt) at gmp.jl:193",
          "mod(x::Real,y::Real) at promotion.jl:175",
          "mod{S,T<:Real}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Range{T<:Real}) at array.jl:732",
          "mod{S<:Real,T}(A::Range{S<:Real},B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:741",
          "mod(x::Bool,B::BitArray{N}) at bitarray.jl:923",
          "mod(x::Number,B::BitArray{N}) at bitarray.jl:927",
          "mod{T}(A::Number,B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:754",
          "mod(B::BitArray{N},x::Bool) at bitarray.jl:920",
          "mod(B::BitArray{N},x::Number) at bitarray.jl:936",
          "mod{T}(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Number) at array.jl:761"
        ]
      },
      {
        "name": "mod1",
        "summary": "Function",
        "help": "Base.mod1(x, m)\n\n   Modulus after division, returning in the range (0,m]\n",
        "methods": 
        [
          "mod1{T<:Real}(x::T<:Real,y::T<:Real) at operators.jl:129",
          "mod1(x::Real,y::Real) at promotion.jl:177"
        ]
      },
      {
        "name": "mod2pi",
        "summary": "Function",
        "help": "Base.mod2pi(x)\n\n   Modulus after division by 2pi, returning in the range [0,2pi).\n\n   This function computes a floating point representation of the\n   modulus after division by numerically exact 2pi, and is therefore\n   not exactly the same as mod(x,2pi), which would compute the modulus\n   of x relative to division by the floating-point number 2pi.\n",
        "methods": 
        [
          "mod2pi(x::Float64) at math.jl:1506",
          "mod2pi(x::Float32) at math.jl:1534",
          "mod2pi(x::Int32) at math.jl:1535",
          "mod2pi(x::Int64) at math.jl:1537"
        ]
      },
      {
        "name": "modf",
        "summary": "Function",
        "help": "Base.modf(x)\n\n   Return a tuple (fpart,ipart) of the fractional and integral parts\n   of a number. Both parts have the same sign as the argument.\n",
        "methods": 
        [
          "modf(x::BigFloat) at mpfr.jl:517",
          "modf(x) at math.jl:413"
        ]
      },
      {
        "name": "module_name",
        "summary": "Function",
        "help": "Base.module_name(m::Module) -> Symbol\n\n   Get the name of a module as a symbol.\n",
        "methods": 
        [
          "module_name(m::Module) at reflection.jl:2"
        ]
      },
      {
        "name": "module_parent",
        "summary": "Function",
        "help": "Base.module_parent(m::Module) -> Module\n\n   Get a module's enclosing module. \"Main\" is its own parent.\n",
        "methods": 
        [
          "module_parent(m::Module) at reflection.jl:3"
        ]
      },
      {
        "name": "msync",
        "summary": "Function",
        "help": "Base.msync(array)\n\n   Forces synchronization between the in-memory version of a memory-\n   mapped \"Array\" or \"BitArray\" and the on-disk version.\n\nBase.msync(ptr, len[, flags])\n\n   Forces synchronization of the mmap'd memory region from ptr to\n   ptr+len. Flags defaults to MS_SYNC, but can be a combination of\n   MS_ASYNC, MS_SYNC, or MS_INVALIDATE. See your platform man page for\n   specifics. The flags argument is not valid on Windows.\n\n   You may not need to call \"msync\", because synchronization is\n   performed at intervals automatically by the operating system.\n   However, you can call this directly if, for example, you are\n   concerned about losing the result of a long-running calculation.\n",
        "methods": 
        [
          "msync{T}(A::Array{T,N}) at mmap.jl:6",
          "msync(B::BitArray{N}) at mmap.jl:14",
          "msync(p::Ptr{T},len::Integer,flags::Integer) at mmap.jl:70",
          "msync(p::Ptr{T},len::Integer) at mmap.jl:72",
          "msync(A::Array{T,N},flags::Int64) at deprecated.jl:26",
          "msync(A::BitArray{N},flags::Int64) at deprecated.jl:26"
        ]
      },
      {
        "name": "mtime",
        "summary": "Function",
        "help": "Base.mtime(file)\n\n   Equivalent to stat(file).mtime\n",
        "methods": 
        [
          "mtime(path...) at stat.jl:114"
        ]
      },
      {
        "name": "mv",
        "summary": "Function",
        "help": "Base.mv(src::String, dst::String)\n\n   Move a file from *src* to *dst*.\n",
        "methods": 
        [
          "mv(src::String,dst::String) at file.jl:64"
        ]
      },
      {
        "name": "myid",
        "summary": "Function",
        "help": "Base.myid()\n\n   Get the id of the current process.\n",
        "methods": 
        [
          "myid() at multi.jl:263"
        ]
      },
      {
        "name": "myindexes",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "myindexes(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "names",
        "summary": "Function",
        "help": "Base.names(x::Module[, all=false[, imported=false]])\n\n   Get an array of the names exported by a module, with optionally\n   more module globals according to the additional parameters.\n\nBase.names(x::DataType)\n\n   Get an array of the fields of a data type.\n",
        "methods": 
        [
          "names(m::Module,all::Bool,imported::Bool) at reflection.jl:9",
          "names(m::Module,all::Bool) at reflection.jl:10",
          "names(m::Module) at reflection.jl:11",
          "names(t::DataType) at reflection.jl:12",
          "names(v) at reflection.jl:15"
        ]
      },
      {
        "name": "nan",
        "summary": "Function",
        "help": "Base.nan(f)\n\n   Returns NaN in the same floating point type as \"f\" (or \"f\" can\n   by the type itself)\n",
        "methods": 
        [
          "nan(::Type{Float16}) at float.jl:260",
          "nan(::Type{Float32}) at float.jl:262",
          "nan(::Type{Float64}) at float.jl:264",
          "nan{T<:FloatingPoint}(x::T<:FloatingPoint) at float.jl:266",
          "nan(::Type{BigFloat}) at mpfr.jl:665"
        ]
      },
      {
        "name": "nans",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "nans{T}(::Type{T},dims...) at deprecated.jl:26",
          "nans{T}(x::AbstractArray{T,N}) at deprecated.jl:26",
          "nans(dims...) at deprecated.jl:26"
        ]
      },
      {
        "name": "nb_available",
        "summary": "Function",
        "help": "Base.nb_available(stream)\n\n   Returns the number of bytes available for reading before a read\n   from this stream or buffer will block.\n",
        "methods": 
        [
          "nb_available(io::IOBuffer) at iobuffer.jl:95",
          "nb_available(s::IOStream) at io.jl:417",
          "nb_available(stream::AsyncStream) at stream.jl:208",
          "nb_available(s::Session) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:394"
        ]
      },
      {
        "name": "ndigits",
        "summary": "Function",
        "help": "Base.ndigits(n, b)\n\n   Compute the number of digits in number \"n\" written in base \"b\".\n",
        "methods": 
        [
          "ndigits(x::Unsigned,b::Integer) at intfuncs.jl:180",
          "ndigits(x::Unsigned) at intfuncs.jl:181",
          "ndigits(x::BigInt) at gmp.jl:435",
          "ndigits(x::BigInt,b::Integer) at gmp.jl:435",
          "ndigits(x::Integer,b::Integer) at intfuncs.jl:183",
          "ndigits(x::Integer) at intfuncs.jl:184"
        ]
      },
      {
        "name": "ndims",
        "summary": "Function",
        "help": "Base.ndims(A) -> Integer\n\n   Returns the number of dimensions of A\n",
        "methods": 
        [
          "ndims(x::Number) at number.jl:10",
          "ndims{T<:Number}(::Type{T<:Number}) at number.jl:11",
          "ndims{T,N}(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)}) at subarray.jl:180",
          "ndims{T,n}(::AbstractArray{T,n}) at abstractarray.jl:20",
          "ndims{T,n}(::Type{AbstractArray{T,n}}) at abstractarray.jl:21",
          "ndims{T<:AbstractArray{T,N}}(::Type{T<:AbstractArray{T,N}}) at abstractarray.jl:22",
          "ndims(J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:11"
        ]
      },
      {
        "name": "next",
        "summary": "Function",
        "help": "Base.next(iter, state) -> item, state\n\n   For a given iterable object and iteration state, return the current\n   item and the next iteration state\n",
        "methods": 
        [
          "next(mt::MethodTable,m::Method) at reflection.jl:124",
          "next(t::(Any...,),i::Int64) at tuple.jl:15",
          "next{T}(r::FloatRange{T},i) at range.jl:216",
          "next{T}(r::StepRange{T,S},i) at range.jl:222",
          "next{T}(r::UnitRange{T},i) at range.jl:226",
          "next(x::Number,state) at number.jl:37",
          "next(B::BitArray{N},i::Int64) at bitarray.jl:200",
          "next{T}(r::CalendarTimeRange{T},i) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:405",
          "next(a::AbstractArray{T,N},i) at abstractarray.jl:246",
          "next(s::IntSet,i) at intset.jl:133",
          "next{T<:Dict{K,V}}(v::KeyIterator{T<:Dict{K,V}},i) at dict.jl:581",
          "next{K,V}(v::KeyIterator{HashDict{K,V,Int64}},i) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:499",
          "next(v::KeyIterator{HashDict{K,V,O<:Union(Nothing,Int64)}},i) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:496",
          "next{T<:DefaultDictBase{K,V,F,D<:Associative{K,V}}}(v::KeyIterator{T<:DefaultDictBase{K,V,F,D<:Associative{K,V}}},i) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:54",
          "next(v::KeyIterator{T<:Associative{K,V}},state) at dict.jl:52",
          "next{T<:Dict{K,V}}(v::ValueIterator{T<:Dict{K,V}},i) at dict.jl:582",
          "next{K,V}(v::ValueIterator{HashDict{K,V,Int64}},i) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:500",
          "next(v::ValueIterator{HashDict{K,V,O<:Union(Nothing,Int64)}},i) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:497",
          "next{T<:DefaultDictBase{K,V,F,D<:Associative{K,V}}}(v::ValueIterator{T<:DefaultDictBase{K,V,F,D<:Associative{K,V}}},i) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:55",
          "next(v::ValueIterator{T<:Associative{K,V}},state) at dict.jl:57",
          "next(t::ObjectIdDict,i) at dict.jl:192",
          "next(t::Dict{K,V},i) at dict.jl:576",
          "next{K}(t::WeakKeyDict{K,V},i) at dict.jl:652",
          "next(s::Set{T},i) at set.jl:35",
          "next(e::Enumerate{I},state) at iterator.jl:13",
          "next(z::Zip{I<:(Any...,)},state) at iterator.jl:33",
          "next(z::Zip2{I1,I2},st) at iterator.jl:56",
          "next(f::Filter{I},s) at iterator.jl:83",
          "next(i::Rest{I,S},st) at iterator.jl:108",
          "next(s::UTF8String,i::Int64) at utf8.jl:82",
          "next(s::UTF16String,i::Int64) at utf16.jl:18",
          "next(s::UTF32String,i::Int64) at string.jl:574",
          "next(s::DirectIndexString,i::Int64) at string.jl:14",
          "next(s::GenericString,i::Int64) at string.jl:562",
          "next(s::SubString{T<:String},i::Int64) at string.jl:627",
          "next(s::RepString,i::Int64) at string.jl:697",
          "next(s::RevString{T<:String},i::Int64) at string.jl:737",
          "next(s::RopeString,i::Int64) at string.jl:778",
          "next(s::String,i::Int64) at string.jl:13",
          "next(s::String,i::Integer) at string.jl:15",
          "next(itr::RegexMatchIterator,prev_match) at regex.jl:199",
          "next(::EnvHash,i) at env.jl:97",
          "next(t::Task,val) at task.jl:170",
          "next(itr::EachLine,nada) at io.jl:233",
          "next(pq::PriorityQueue{K,V},i) at collections.jl:275",
          "next(c::Combinations{T},s) at combinatorics.jl:252",
          "next(p::Permutations{T},s) at combinatorics.jl:286",
          "next(p::IntegerPartitions,xs) at combinatorics.jl:319",
          "next(f::FixedPartitions,s::Array{Int64,1}) at combinatorics.jl:385",
          "next(p::SetPartitions{T<:AbstractArray{T,1}},s) at combinatorics.jl:443",
          "next(p::FixedSetPartitions{T<:AbstractArray{T,1}},s) at combinatorics.jl:513",
          "next{Tv}(d::SpDiagIterator{Tv,Ti},j) at sparse/sparsematrix.jl:1686",
          "next{T}(q::Deque{T},s::DequeIterator{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:108",
          "next(ct::Accumulator{T,V<:Number},state) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:39",
          "next(cc::ClassifiedCollections{K,Collection},state) at /home/samuel/.julia/v0.3/DataStructures/src/classifiedcollections.jl:38",
          "next{K,V}(t::HashDict{K,V,Int64},i) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:491",
          "next(t::HashDict{K,V,O<:Union(Nothing,Int64)},i) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:488",
          "next(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "next(s::OrderedSet{T},i) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:43",
          "next(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "next(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "next(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "next{T}(l::Cons{T},state::Cons{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:128",
          "next(it::Count{S<:Number},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:36",
          "next(it::Take{I},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:55",
          "next(it::Drop{I},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:89",
          "next(it::Cycle{I},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:109",
          "next(it::Repeat{O},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:134",
          "next(it::RepeatForever{O},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:149",
          "next(it::Chain,state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:187",
          "next(it::Product,state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:235",
          "next(it::Distinct{I},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:279",
          "next(it::Partition{I},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:338",
          "next(it::GroupBy{I},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:399",
          "next(it::IMap,state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:446",
          "next(it::Subsets,state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:477",
          "next(it::Iterate{T},state) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:511"
        ]
      },
      {
        "name": "nextfloat",
        "summary": "Function",
        "help": "Base.nextfloat(f)\n\n   Get the next floating point number in lexicographic order\n",
        "methods": 
        [
          "nextfloat(x::Float16,i::Integer) at float.jl:249",
          "nextfloat(x::Float32,i::Integer) at float.jl:251",
          "nextfloat(x::Float64,i::Integer) at float.jl:253",
          "nextfloat(x::BigFloat) at mpfr.jl:671",
          "nextfloat(x::FloatingPoint) at float.jl:255"
        ]
      },
      {
        "name": "nextind",
        "summary": "Function",
        "help": "Base.nextind(str, i)\n\n   Get the next valid string index after \"i\". Returns a value\n   greater than \"endof(str)\" at or after the end of the string.\n",
        "methods": 
        [
          "nextind(s::DirectIndexString,i::Integer) at string.jl:108",
          "nextind(s::SubString{T<:String},i::Integer) at string.jl:647",
          "nextind(s::String,i::Integer) at string.jl:127",
          "nextind(s,i::Integer) at string.jl:109"
        ]
      },
      {
        "name": "nextpow",
        "summary": "Function",
        "help": "Base.nextpow(a, x)\n\n   The smallest \"a^n\" not less than \"x\", where \"n\" is a non-\n   negative integer. \"a\" must be greater than 1, and \"x\" must be\n   greater than 0.\n",
        "methods": 
        [
          "nextpow(a::Real,x::Real) at intfuncs.jl:121"
        ]
      },
      {
        "name": "nextpow2",
        "summary": "Function",
        "help": "Base.nextpow2(n)\n\n   The smallest power of two not less than \"n\". Returns 0 for\n   \"n==0\", and returns \"-nextpow2(-n)\" for negative arguments.\n",
        "methods": 
        [
          "nextpow2(x::Unsigned) at intfuncs.jl:111",
          "nextpow2(x::BigInt) at gmp.jl:443",
          "nextpow2(x::Integer) at intfuncs.jl:112"
        ]
      },
      {
        "name": "nextprod",
        "summary": "Function",
        "help": "Base.nextprod([k_1, k_2, ...], n)\n\n   Next integer not less than \"n\" that can be written as \\prod\n   k_i^{p_i} for integers p_1, p_2, etc.\n",
        "methods": 
        [
          "nextprod(a::Array{Int64,1},x) at combinatorics.jl:572"
        ]
      },
      {
        "name": "nfilled",
        "summary": "Function",
        "help": "Base.nfilled(A)\n\n   Returns the number of stored (filled) elements in a sparse matrix.\n   For dense arrays, this returns the length of the array.\n",
        "methods": 
        [
          "nfilled(X) at deprecated.jl:385"
        ]
      },
      {
        "name": "nnz",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "nnz(S::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:18",
          "nnz{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:782",
          "nnz{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:782",
          "nnz(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at deprecated.jl:26"
        ]
      },
      {
        "name": "nonzeros",
        "summary": "Function",
        "help": "Base.nonzeros(A)\n\n   Return a vector of the structural nonzero values in sparse matrix\n   \"A\". This includes zeros that are explicitly stored in the sparse\n   matrix. The returned vector points directly to the internal nonzero\n   storage of \"A\", and any modifications to the returned vector will\n   mutate \"A\" as well.\n",
        "methods": 
        [
          "nonzeros(B::BitArray{N}) at deprecated.jl:26",
          "nonzeros(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at deprecated.jl:26"
        ]
      },
      {
        "name": "norm",
        "summary": "Function",
        "help": "Base.norm(A[, p])\n\n   Compute the \"p\"-norm of a vector or the operator norm of a matrix\n   \"A\", defaulting to the \"p=2\"-norm.\n\n   For vectors, \"p\" can assume any numeric value (even though not\n   all values produce a mathematically valid vector norm). In\n   particular, \"norm(A, Inf)\" returns the largest value in\n   \"abs(A)\", whereas \"norm(A, -Inf)\" returns the smallest.\n\n   For matrices, valid values of \"p\" are \"1\", \"2\", or \"Inf\".\n   (Note that for sparse matrices, \"p=2\" is currently not\n   implemented.) Use \"vecnorm()\" to compute the Frobenius norm.\n",
        "methods": 
        [
          "norm{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),TI<:Integer}(x::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),rx::Union(UnitRange{TI<:Integer},Range{TI<:Integer})) at linalg/dense.jl:47",
          "norm(A::SparseMatrixCSC{Tv,Ti<:Integer}) at linalg/sparse.jl:482",
          "norm(A::SparseMatrixCSC{Tv,Ti<:Integer},p::Real) at linalg/sparse.jl:482",
          "norm(x::AbstractArray{T,1}) at linalg/generic.jl:156",
          "norm(x::AbstractArray{T,1},p::Real) at linalg/generic.jl:156",
          "norm{T}(A::AbstractArray{T,2}) at linalg/generic.jl:197",
          "norm{T}(A::AbstractArray{T,2},p::Real) at linalg/generic.jl:197",
          "norm(x::Number) at linalg/generic.jl:203",
          "norm(x::Number,p::Real) at linalg/generic.jl:203",
          "norm{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(D::CholmodDense{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/cholmod.jl:390",
          "norm{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(D::CholmodDense{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},p::Real) at linalg/cholmod.jl:390",
          "norm{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32},p::Real) at linalg/cholmod.jl:786",
          "norm{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64},p::Real) at linalg/cholmod.jl:786",
          "norm(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:912",
          "norm(p::Vec2) at graphics.jl:75"
        ]
      },
      {
        "name": "normalize_string",
        "summary": "Function",
        "help": "Base.normalize_string(s, normalform::Symbol)\n\n   Normalize the string \"s\" according to one of the four \"normal\n   forms\" of the Unicode standard: \"normalform\" can be \":NFC\",\n   \":NFD\", \":NFKC\", or \":NFKD\".  Normal forms C (canonical\n   composition) and D (canonical decomposition) convert different\n   visually identical representations of the same abstract string into\n   a single canonical form, with form C being more compact.  Normal\n   forms KC and KD additionally canonicalize \"compatibility\n   equivalents\": they convert characters that are abstractly similar\n   but visually distinct into a single canonical choice (e.g. they\n   expand ligatures into the individual characters), with form KC\n   being more compact.\n\n   Alternatively, finer control and additional transformations may be\n   be obtained by calling *normalize_string(s; keywords...)*, where\n   any number of the following boolean keywords options (which all\n   default to \"false\" except for \"compose\") are specified:\n\n   * \"compose=false\": do not perform canonical composition\n\n   * \"decompose=true\": do canonical decomposition instead of\n     canonical composition (\"compose=true\" is ignored if present)\n\n   * \"compat=true\": compatibility equivalents are canonicalized\n\n   * \"casefold=true\": perform Unicode case folding, e.g. for case-\n     insensitive string comparison\n\n   * \"newline2lf=true\", \"newline2ls=true\", or \"newline2ps=true\":\n     convert various newline sequences (LF, CRLF, CR, NEL) into a\n     linefeed (LF), line-separation (LS), or paragraph-separation (PS)\n     character, respectively\n\n   * \"stripmark=true\": strip diacritical marks (e.g. accents)\n\n   * \"stripignore=true\": strip Unicode's \"default ignorable\"\n     characters (e.g. the soft hyphen or the left-to-right marker)\n\n   * \"stripcc=true\": strip control characters; horizontal tabs and\n     form feeds are converted to spaces; newlines are also converted\n     to spaces unless a newline-conversion flag was specified\n\n   * \"rejectna=true\": throw an error if unassigned code points are\n     found\n\n   * \"stable=true\": enforce Unicode Versioning Stability\n\n   For example, NFKC corresponds to the options \"compose=true,\n   compat=true, stable=true\".\n",
        "methods": 
        [
          "normalize_string(s::String) at utf8proc.jl:45",
          "normalize_string(s::String,nf::Symbol) at utf8proc.jl:69"
        ]
      },
      {
        "name": "normfro",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "normfro(A) at deprecated.jl:26"
        ]
      },
      {
        "name": "normpath",
        "summary": "Function",
        "help": "Base.normpath(path::String) -> String\n\n   Normalize a path, removing \".\" and \"..\" entries.\n",
        "methods": 
        [
          "normpath(path::String) at path.jl:72",
          "normpath(a::String,b::String...) at path.jl:104"
        ]
      },
      {
        "name": "notify",
        "summary": "Function",
        "help": "Base.notify(condition, val=nothing; all=true, error=false)\n\n   Wake up tasks waiting for a condition, passing them \"val\". If\n   \"all\" is true (the default), all waiting tasks are woken,\n   otherwise only one is. If \"error\" is true, the passed value is\n   raised as an exception in the woken tasks.\n",
        "methods": 
        [
          "notify(c::Condition) at task.jl:200",
          "notify(c::Condition,arg::ANY) at task.jl:200"
        ]
      },
      {
        "name": "nprocs",
        "summary": "Function",
        "help": "Base.nprocs()\n\n   Get the number of available processes.\n",
        "methods": 
        [
          "nprocs() at multi.jl:265"
        ]
      },
      {
        "name": "nthperm",
        "summary": "Function",
        "help": "Base.nthperm(v, k)\n\n   Compute the kth lexicographic permutation of a vector.\n\nBase.nthperm(p)\n\n   Return the \"k\" that generated permutation \"p\". Note that\n   \"nthperm(nthperm([1:n], k)) == k\" for \"1 <= k <= factorial(n)\".\n",
        "methods": 
        [
          "nthperm{T<:Integer}(p::AbstractArray{T<:Integer,1}) at combinatorics.jl:151",
          "nthperm(a::AbstractArray{T,1},k::Integer) at combinatorics.jl:148"
        ]
      },
      {
        "name": "nthperm!",
        "summary": "Function",
        "help": "Base.nthperm!(v, k)\n\n   In-place version of \"nthperm()\".\n",
        "methods": 
        [
          "nthperm!(a::AbstractArray{T,1},k::Integer) at combinatorics.jl:130"
        ]
      },
      {
        "name": "ntoh",
        "summary": "Function",
        "help": "Base.ntoh(x)\n\n   Converts the endianness of a value from Network byte order (big-\n   endian) to that used by the Host.\n",
        "methods": 
        [
          "ntoh(x) at io.jl:17"
        ]
      },
      {
        "name": "ntuple",
        "summary": "Function",
        "help": "Base.ntuple(n, f::Function)\n\n   Create a tuple of length \"n\", computing each element as \"f(i)\",\n   where \"i\" is the index of the element.\n",
        "methods": 
        [
          "ntuple(n::Integer,f::Function) at tuple.jl:29",
          "ntuple(f::Function,n::Integer) at tuple.jl:30"
        ]
      },
      {
        "name": "null",
        "summary": "Function",
        "help": "Base.null(M)\n\n   Basis for nullspace of \"M\".\n",
        "methods": 
        [
          "null{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/dense.jl:435",
          "null(a::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/dense.jl:441"
        ]
      },
      {
        "name": "num",
        "summary": "Function",
        "help": "Base.num(x)\n\n   Numerator of the rational representation of \"x\"\n",
        "methods": 
        [
          "num(x::Integer) at rational.jl:94",
          "num(x::Rational{T<:Integer}) at rational.jl:96"
        ]
      },
      {
        "name": "num2hex",
        "summary": "Function",
        "help": "Base.num2hex(f)\n\n   Get a hexadecimal string of the binary representation of a floating\n   point number\n",
        "methods": 
        [
          "num2hex(n::Integer) at intfuncs.jl:237",
          "num2hex(x::Float16) at floatfuncs.jl:27",
          "num2hex(x::Float32) at floatfuncs.jl:28",
          "num2hex(x::Float64) at floatfuncs.jl:29"
        ]
      },
      {
        "name": "nworkers",
        "summary": "Function",
        "help": "Base.nworkers()\n\n   Get the number of available worker processes. This is one less than\n   nprocs(). Equal to nprocs() if nprocs() == 1.\n",
        "methods": 
        [
          "nworkers() at multi.jl:267"
        ]
      },
      {
        "name": "object_id",
        "summary": "Function",
        "help": "Base.object_id(x)\n\n   Get a unique integer id for \"x\". \"object_id(x)==object_id(y)\"\n   if and only if \"is(x,y)\".\n",
        "methods": 
        [
          "object_id(x::ANY) at reflection.jl:30"
        ]
      },
      {
        "name": "oct",
        "summary": "Function",
        "help": "Base.oct(n[, pad])\n\n   Convert an integer to an octal string, optionally specifying a\n   number of digits to pad to.\n",
        "methods": 
        [
          "oct(x::Unsigned,pad::Int64,neg::Bool) at intfuncs.jl:201",
          "oct(x::Unsigned,p::Int64) at intfuncs.jl:259",
          "oct(x::Unsigned) at intfuncs.jl:260",
          "oct(x::Char,p::Int64) at intfuncs.jl:261",
          "oct(x::Char) at intfuncs.jl:262",
          "oct(n::BigInt) at gmp.jl:419",
          "oct(x::Integer,p::Int64) at intfuncs.jl:263",
          "oct(x::Integer) at intfuncs.jl:264"
        ]
      },
      {
        "name": "oftype",
        "summary": "Function",
        "help": "Base.oftype(x, y)\n\n   Convert \"y\" to the type of \"x\".\n",
        "methods": 
        [
          "oftype{T}(::Type{T},c) at operators.jl:157",
          "oftype{T}(x::T,c) at operators.jl:158"
        ]
      },
      {
        "name": "one",
        "summary": "Function",
        "help": "Base.one(x)\n\n   Get the multiplicative identity element for the type of x (x can\n   also specify the type itself). For matrices, returns an identity\n   matrix of the appropriate size and type.\n",
        "methods": 
        [
          "one(x::Number) at number.jl:48",
          "one{T<:Number}(::Type{T<:Number}) at number.jl:49",
          "one{T}(::Type{Ptr{T}}) at pointer.jl:74",
          "one{T}(x::Ptr{T}) at pointer.jl:75",
          "one(x::BitArray{2}) at bitarray.jl:231",
          "one{T}(S::SparseMatrixCSC{T,Ti<:Integer}) at sparse/sparsematrix.jl:408",
          "one{T}(x::AbstractArray{T,2}) at array.jl:188",
          "one{T}(::Type{UniformScaling{T}}) at linalg/uniformscaling.jl:20",
          "one{T}(J::UniformScaling{T}) at linalg/uniformscaling.jl:21"
        ]
      },
      {
        "name": "ones",
        "summary": "Function",
        "help": "Base.ones(type, dims)\n\n   Create an array of all ones of specified type\n",
        "methods": 
        [
          "ones{T}(::Type{T},dims...) at array.jl:169",
          "ones{T}(x::AbstractArray{T,N}) at array.jl:171",
          "ones(dims...) at array.jl:170"
        ]
      },
      {
        "name": "open",
        "summary": "Function",
        "help": "Base.open(file_name[, read, write, create, truncate, append]) -> IOStream\n\n   Open a file in a mode specified by five boolean arguments. The\n   default is to open files for reading only. Returns a stream for\n   accessing the file.\n\nBase.open(file_name[, mode]) -> IOStream\n\n   Alternate syntax for open, where a string-based mode specifier is\n   used instead of the five booleans. The values of \"mode\"\n   correspond to those from \"fopen(3)\" or Perl \"open\", and are\n   equivalent to setting the following boolean groups:\n\n   +------+-----------------------------------+\n   | r    | read                              |\n   +------+-----------------------------------+\n   | r+   | read, write                       |\n   +------+-----------------------------------+\n   | w    | write, create, truncate           |\n   +------+-----------------------------------+\n   | w+   | read, write, create, truncate     |\n   +------+-----------------------------------+\n   | a    | write, create, append             |\n   +------+-----------------------------------+\n   | a+   | read, write, create, append       |\n   +------+-----------------------------------+\n\nBase.open(f::function, args...)\n\n   Apply the function \"f\" to the result of \"open(args...)\" and\n   close the resulting file descriptor upon completion.\n\n   **Example**: \"open(readall, \"file.txt\")\"\n",
        "methods": 
        [
          "open(fname::String,rd::Bool,wr::Bool,cr::Bool,tr::Bool,ff::Bool) at io.jl:348",
          "open(fname::String) at io.jl:358",
          "open(fname::String,mode::String) at io.jl:361",
          "open(f::Function,args...) at io.jl:371"
        ]
      },
      {
        "name": "open_any_tcp_port",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "open_any_tcp_port(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "openblas_set_num_threads",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "openblas_set_num_threads(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "operm",
        "summary": "Function",
        "help": "Base.operm(file)\n\n   Like uperm but gets the permissions for people who neither own the\n   file nor are a member of the group owning the file\n",
        "methods": 
        [
          "operm(st::StatStruct) at stat.jl:82",
          "operm(path...) at stat.jl:105"
        ]
      },
      {
        "name": "parent",
        "summary": "Function",
        "help": "Base.parent(A)\n\n   Returns the \"parent array\" of an array view type (e.g.,\n   SubArray), or the array itself if it is not a view\n",
        "methods": 
        [
          "parent(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)}) at subarray.jl:182",
          "parent(a::AbstractArray{T,N}) at subarray.jl:185"
        ]
      },
      {
        "name": "parentindexes",
        "summary": "Function",
        "help": "Base.parentindexes(A)\n\n   From an array view \"A\", returns the corresponding indexes in the\n   parent\n",
        "methods": 
        [
          "parentindexes(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)}) at subarray.jl:183",
          "parentindexes(a::AbstractArray{T,N}) at subarray.jl:186"
        ]
      },
      {
        "name": "parse",
        "summary": "Function",
        "help": "Base.parse(str, start; greedy=true, raise=true)\n\n   Parse the expression string and return an expression (which could\n   later be passed to eval for execution). Start is the index of the\n   first character to start parsing. If \"greedy\" is true (default),\n   \"parse\" will try to consume as much input as it can; otherwise,\n   it will stop as soon as it has parsed a valid expression. If\n   \"raise\" is true (default), syntax errors will raise an error;\n   otherwise, \"parse\" will return an expression that will raise an\n   error upon evaluation.\n\nBase.parse(str; raise=true)\n\n   Parse the whole string greedily, returning a single expression.  An\n   error is thrown if there are additional characters after the first\n   expression. If \"raise\" is true (default), syntax errors will\n   raise an error; otherwise, \"parse\" will return an expression that\n   will raise an error upon evaluation.\n",
        "methods": 
        [
          "parse(str::String,pos::Int64) at string.jl:1217",
          "parse(str::String) at string.jl:1234",
          "parse(str::String,pos::Int64,greedy::Bool,raise::Bool) at deprecated.jl:26",
          "parse(str::String,pos::Int64,greedy::Bool) at deprecated.jl:26"
        ]
      },
      {
        "name": "parse_bin",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "parse_bin(T,s) at deprecated.jl:26",
          "parse_bin(s) at deprecated.jl:26"
        ]
      },
      {
        "name": "parse_float",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "parse_float(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "parse_hex",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "parse_hex(T,s) at deprecated.jl:26",
          "parse_hex(s) at deprecated.jl:26"
        ]
      },
      {
        "name": "parse_int",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "parse_int(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "parse_oct",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "parse_oct(T,s) at deprecated.jl:26",
          "parse_oct(s) at deprecated.jl:26"
        ]
      },
      {
        "name": "parsefloat",
        "summary": "Function",
        "help": "Base.parsefloat([type], str)\n\n   Parse a string as a decimal floating point number, yielding a\n   number of the specified type.\n",
        "methods": 
        [
          "parsefloat(x::String) at string.jl:1596",
          "parsefloat(::Type{Float64},x::String) at string.jl:1597",
          "parsefloat(::Type{Float32},x::String) at string.jl:1598"
        ]
      },
      {
        "name": "parseint",
        "summary": "Function",
        "help": "Base.parseint([type], str[, base])\n\n   Parse a string as an integer in the given base (default 10),\n   yielding a number of the specified type (default \"Int\").\n",
        "methods": 
        [
          "parseint(c::Char) at string.jl:1451",
          "parseint(c::Char,base::Integer) at string.jl:1451",
          "parseint(c::Char,base::Integer,a::Int64) at string.jl:1451",
          "parseint{T<:Integer}(::Type{T<:Integer},c::Char,base::Integer) at string.jl:1458",
          "parseint{T<:Integer}(::Type{T<:Integer},c::Char) at string.jl:1459",
          "parseint{T<:Integer}(::Type{T<:Integer},s::String,base::Integer) at string.jl:1539",
          "parseint{T<:Integer}(::Type{T<:Integer},s::String) at string.jl:1541",
          "parseint(s::String,base::Integer) at string.jl:1542",
          "parseint(s::String) at string.jl:1543"
        ]
      },
      {
        "name": "parseip",
        "summary": "Function",
        "help": "Base.parseip(addr)\n\n   Parse a string specifying an IPv4 or IPv6 ip address.\n",
        "methods": 
        [
          "parseip(str) at socket.jl:213"
        ]
      },
      {
        "name": "partitions",
        "summary": "Function",
        "help": "Base.partitions(n)\n\n   Generate all integer arrays that sum to \"n\". Because the number\n   of partitions can be very large, this function returns an iterator\n   object. Use \"collect(partitions(n))\" to get an array of all\n   partitions. The number of partitions to generete can be efficiently\n   computed using \"length(partitions(n))\".\n\nBase.partitions(n, m)\n\n   Generate all arrays of \"m\" integers that sum to \"n\". Because\n   the number of partitions can be very large, this function returns\n   an iterator object. Use \"collect(partitions(n,m))\" to get an\n   array of all partitions. The number of partitions to generete can\n   be efficiently computed using \"length(partitions(n,m))\".\n\nBase.partitions(array)\n\n   Generate all set partitions of the elements of an array,\n   represented as arrays of arrays. Because the number of partitions\n   can be very large, this function returns an iterator object. Use\n   \"collect(partitions(array))\" to get an array of all partitions.\n   The number of partitions to generete can be efficiently computed\n   using \"length(partitions(array))\".\n\nBase.partitions(array, m)\n\n   Generate all set partitions of the elements of an array into\n   exactly m subsets, represented as arrays of arrays. Because the\n   number of partitions can be very large, this function returns an\n   iterator object. Use \"collect(partitions(array,m))\" to get an\n   array of all partitions. The number of partitions into m subsets is\n   equal to the Stirling number of the second kind and can be\n   efficiently computed using \"length(partitions(array,m))\".\n",
        "methods": 
        [
          "partitions(n::Integer) at combinatorics.jl:315",
          "partitions(n::Integer,m::Integer) at combinatorics.jl:381",
          "partitions(s::AbstractArray{T,1}) at combinatorics.jl:439",
          "partitions(s::AbstractArray{T,1},m::Int64) at combinatorics.jl:506"
        ]
      },
      {
        "name": "peakflops",
        "summary": "Function",
        "help": "Base.peakflops(n; parallel=false)\n\n   \"peakflops\" computes the peak flop rate of the computer by using\n   BLAS double precision \"gemm!()\". By default, if no arguments are\n   specified, it multiplies a matrix of size \"n x n\", where \"n =\n   2000\". If the underlying BLAS is using multiple threads, higher\n   flop rates are realized. The number of BLAS threads can be set with\n   \"blas_set_num_threads(n)\".\n\n   If the keyword argument \"parallel\" is set to \"true\",\n   \"peakflops\" is run in parallel on all the worker processors. The\n   flop rate of the entire parallel computer is returned. When running\n   in parallel, only 1 BLAS thread is used. The argument \"n\" still\n   refers to the size of the problem that is solved on each processor.\n",
        "methods": 
        [
          "peakflops() at linalg/generic.jl:326",
          "peakflops(n::Integer) at linalg/generic.jl:326"
        ]
      },
      {
        "name": "permutations",
        "summary": "Function",
        "help": "Base.permutations(arr)\n\n   Generate all permutations of an indexable object.  Because the\n   number of permutations can be very large, this function returns an\n   iterator object. Use \"collect(permutations(a,n))\" to get an array\n   of all permutations.\n",
        "methods": 
        [
          "permutations(a) at combinatorics.jl:282"
        ]
      },
      {
        "name": "permute!",
        "summary": "Function",
        "help": "Base.permute!(v, p)\n\n   Permute vector \"v\" in-place, according to permutation \"p\".  No\n   checking is done to verify that \"p\" is a permutation.\n\n   To return a new permutation, use \"v[p]\".  Note that this is\n   generally faster than \"permute!(v,p)\" for large vectors.\n",
        "methods": 
        [
          "permute!(a,p::AbstractArray{T,1}) at combinatorics.jl:204"
        ]
      },
      {
        "name": "permutedims",
        "summary": "Function",
        "help": "Base.permutedims(A, perm)\n\n   Permute the dimensions of array \"A\". \"perm\" is a vector\n   specifying a permutation of length \"ndims(A)\". This is a\n   generalization of transpose for multi-dimensional arrays. Transpose\n   is equivalent to \"permutedims(A,[2,1])\".\n",
        "methods": 
        [
          "permutedims(B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),perm) at bitarray.jl:1568"
        ]
      },
      {
        "name": "permutedims!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "permutedims!(P::BitArray{1},B::BitArray{1},perm) at multidimensional.jl:446",
          "permutedims!(P::BitArray{2},B::BitArray{2},perm) at multidimensional.jl:446",
          "permutedims!(P::BitArray{3},B::BitArray{3},perm) at multidimensional.jl:446",
          "permutedims!(P::BitArray{4},B::BitArray{4},perm) at multidimensional.jl:446",
          "permutedims!{N}(P::BitArray{N},B::BitArray{N},perm) at cartesian.jl:100",
          "permutedims!{T}(P::Array{T,1},B::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1}),perm) at multidimensional.jl:446",
          "permutedims!{T}(P::Array{T,2},B::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2}),perm) at multidimensional.jl:446",
          "permutedims!{T}(P::Array{T,3},B::Union(DenseArray{T,3},SubArray{T,3,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),perm) at multidimensional.jl:446",
          "permutedims!{T}(P::Array{T,4},B::Union(DenseArray{T,4},SubArray{T,4,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),perm) at multidimensional.jl:446",
          "permutedims!{T,N}(P::Array{T,N},B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),perm) at cartesian.jl:100"
        ]
      },
      {
        "name": "pi",
        "summary": "MathConst{:π}",
        "help": "Base.pi\n\n   The constant pi\n",
        "methods": 
        [

        ]
      },
      {
        "name": "pinv",
        "summary": "Function",
        "help": "Base.pinv(M)\n\n   Moore-Penrose pseudoinverse\n",
        "methods": 
        [
          "pinv{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/dense.jl:421",
          "pinv(a::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/dense.jl:430",
          "pinv(x::Number) at linalg/dense.jl:431"
        ]
      },
      {
        "name": "plan_bfft",
        "summary": "Function",
        "help": "Base.plan_bfft(A[, dims[, flags[, timelimit]]])\n\n   Same as \"plan_fft()\", but produces a plan that performs an\n   unnormalized backwards transform \"bfft()\".\n",
        "methods": 
        [
          "plan_bfft{T<:Union(Complex{Float64},Complex{Float32})}(X::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),N},SubArray{T<:Union(Complex{Float64},Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),region,flags::Unsigned,tlim::Real) at fftw.jl:446",
          "plan_bfft{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region,flags::Unsigned,tlim::Real) at fftw.jl:458",
          "plan_bfft{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region,flags::Unsigned) at fftw.jl:485",
          "plan_bfft{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region) at fftw.jl:487",
          "plan_bfft{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N})) at fftw.jl:489",
          "plan_bfft(x::Number) at fftw.jl:697",
          "plan_bfft(x::Number,dims) at fftw.jl:704",
          "plan_bfft(x::Number,dims,flags) at fftw.jl:711",
          "plan_bfft(x::Number,dims,flags,tlim) at fftw.jl:718"
        ]
      },
      {
        "name": "plan_bfft!",
        "summary": "Function",
        "help": "Base.plan_bfft!(A[, dims[, flags[, timelimit]]])\n\n   Same as \"plan_bfft()\", but operates in-place on \"A\".\n",
        "methods": 
        [
          "plan_bfft!{T<:Union(Complex{Float64},Complex{Float32})}(X::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),N},SubArray{T<:Union(Complex{Float64},Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),region,flags::Unsigned,tlim::Real) at fftw.jl:472",
          "plan_bfft!{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region,flags::Unsigned) at fftw.jl:485",
          "plan_bfft!{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region) at fftw.jl:487",
          "plan_bfft!{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N})) at fftw.jl:489"
        ]
      },
      {
        "name": "plan_brfft",
        "summary": "Function",
        "help": "Base.plan_brfft(A, d[, dims[, flags[, timelimit]]])\n\n   Pre-plan an optimized real-input unnormalized transform, similar to\n   \"plan_rfft()\" except for \"brfft()\" instead of \"rfft()\". The\n   first two arguments and the size of the transformed result, are the\n   same as for \"brfft()\".\n",
        "methods": 
        [
          "plan_brfft(X::Union(SubArray{Complex{Float32},N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float32},N}),d::Integer,region::Integer,flags::Unsigned,tlim::Real) at fftw.jl:602",
          "plan_brfft(X::Union(SubArray{Complex{Float32},N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float32},N}),d::Integer,region,flags::Unsigned,tlim::Real) at fftw.jl:617",
          "plan_brfft(X::Union(SubArray{Complex{Float64},N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float64},N}),d::Integer,region::Integer,flags::Unsigned,tlim::Real) at fftw.jl:602",
          "plan_brfft(X::Union(SubArray{Complex{Float64},N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Complex{Float64},N}),d::Integer,region,flags::Unsigned,tlim::Real) at fftw.jl:617",
          "plan_brfft(X::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),d,region,flags) at fftw.jl:646",
          "plan_brfft(X::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),d,region) at fftw.jl:648",
          "plan_brfft(X::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),d) at fftw.jl:650",
          "plan_brfft(x::Number,d::Integer) at fftw.jl:700",
          "plan_brfft(x::Number,d::Integer,dims) at fftw.jl:707",
          "plan_brfft(x::Number,d::Integer,dims,flags) at fftw.jl:714",
          "plan_brfft(x::Number,d::Integer,dims,flags,tlim) at fftw.jl:721"
        ]
      },
      {
        "name": "plan_dct",
        "summary": "Function",
        "help": "Base.plan_dct(A[, dims[, flags[, timelimit]]])\n\n   Pre-plan an optimized discrete cosine transform (DCT), similar to\n   \"plan_fft()\" except producing a function that computes \"dct()\".\n   The first two arguments have the same meaning as for \"dct()\".\n",
        "methods": 
        [
          "plan_dct{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region,flags::Unsigned,timelimit::Real) at dsp.jl:193",
          "plan_dct{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N})) at dsp.jl:249",
          "plan_dct(x::Number) at dsp.jl:262",
          "plan_dct(X,region,flags::Unsigned) at dsp.jl:245",
          "plan_dct(x::Number,dims,flags,tlim) at dsp.jl:260",
          "plan_dct(X,region) at dsp.jl:247"
        ]
      },
      {
        "name": "plan_dct!",
        "summary": "Function",
        "help": "Base.plan_dct!(A[, dims[, flags[, timelimit]]])\n\n   Same as \"plan_dct()\", but operates in-place on \"A\".\n",
        "methods": 
        [
          "plan_dct!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(X::Union(SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N}),region,flags::Unsigned,timelimit::Real) at dsp.jl:193",
          "plan_dct!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(X::Union(SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N})) at dsp.jl:249",
          "plan_dct!(X,region,flags::Unsigned) at dsp.jl:245",
          "plan_dct!(X,region) at dsp.jl:247"
        ]
      },
      {
        "name": "plan_fft",
        "summary": "Function",
        "help": "Base.plan_fft(A[, dims[, flags[, timelimit]]])\n\n   Pre-plan an optimized FFT along given dimensions (\"dims\") of\n   arrays matching the shape and type of \"A\".  (The first two\n   arguments have the same meaning as for \"fft()\".)  Returns a\n   function \"plan(A)\" that computes \"fft(A, dims)\" quickly.\n\n   The \"flags\" argument is a bitwise-or of FFTW planner flags,\n   defaulting to \"FFTW.ESTIMATE\".  e.g. passing \"FFTW.MEASURE\" or\n   \"FFTW.PATIENT\" will instead spend several seconds (or more)\n   benchmarking different possible FFT algorithms and picking the\n   fastest one; see the FFTW manual for more information on planner\n   flags.  The optional \"timelimit\" argument specifies a rough upper\n   bound on the allowed planning time, in seconds. Passing\n   \"FFTW.MEASURE\" or \"FFTW.PATIENT\" may cause the input array\n   \"A\" to be overwritten with zeros during plan creation.\n\n   \"plan_fft!()\" is the same as \"plan_fft()\" but creates a plan\n   that operates in-place on its argument (which must be an array of\n   complex floating-point numbers).  \"plan_ifft()\" and so on are\n   similar but produce plans that perform the equivalent of the\n   inverse transforms \"ifft()\" and so on.\n",
        "methods": 
        [
          "plan_fft{T<:Union(Complex{Float64},Complex{Float32})}(X::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),N},SubArray{T<:Union(Complex{Float64},Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),region,flags::Unsigned,tlim::Real) at fftw.jl:446",
          "plan_fft{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region,flags::Unsigned,tlim::Real) at fftw.jl:458",
          "plan_fft{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region,flags::Unsigned) at fftw.jl:485",
          "plan_fft{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region) at fftw.jl:487",
          "plan_fft{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N})) at fftw.jl:489",
          "plan_fft(x::Number) at fftw.jl:695",
          "plan_fft(x::Number,dims) at fftw.jl:702",
          "plan_fft(x::Number,dims,flags) at fftw.jl:709",
          "plan_fft(x::Number,dims,flags,tlim) at fftw.jl:716"
        ]
      },
      {
        "name": "plan_fft!",
        "summary": "Function",
        "help": "Base.plan_fft!(A[, dims[, flags[, timelimit]]])\n\n   Same as \"plan_fft()\", but operates in-place on \"A\".\n",
        "methods": 
        [
          "plan_fft!{T<:Union(Complex{Float64},Complex{Float32})}(X::Union(DenseArray{T<:Union(Complex{Float64},Complex{Float32}),N},SubArray{T<:Union(Complex{Float64},Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),region,flags::Unsigned,tlim::Real) at fftw.jl:472",
          "plan_fft!{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region,flags::Unsigned) at fftw.jl:485",
          "plan_fft!{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region) at fftw.jl:487",
          "plan_fft!{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N})) at fftw.jl:489"
        ]
      },
      {
        "name": "plan_idct",
        "summary": "Function",
        "help": "Base.plan_idct(A[, dims[, flags[, timelimit]]])\n\n   Pre-plan an optimized inverse discrete cosine transform (DCT),\n   similar to \"plan_fft()\" except producing a function that computes\n   \"idct()\". The first two arguments have the same meaning as for\n   \"idct()\".\n",
        "methods": 
        [
          "plan_idct{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N}),region,flags::Unsigned,timelimit::Real) at dsp.jl:224",
          "plan_idct{T<:Number}(X::Union(SubArray{T<:Number,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Number,N})) at dsp.jl:249",
          "plan_idct(x::Number) at dsp.jl:263",
          "plan_idct(X,region,flags::Unsigned) at dsp.jl:245",
          "plan_idct(x::Number,dims,flags,tlim) at dsp.jl:261",
          "plan_idct(X,region) at dsp.jl:247"
        ]
      },
      {
        "name": "plan_idct!",
        "summary": "Function",
        "help": "Base.plan_idct!(A[, dims[, flags[, timelimit]]])\n\n   Same as \"plan_idct()\", but operates in-place on \"A\".\n",
        "methods": 
        [
          "plan_idct!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(X::Union(SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N}),region,flags::Unsigned,timelimit::Real) at dsp.jl:224",
          "plan_idct!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(X::Union(SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N})) at dsp.jl:249",
          "plan_idct!(X,region,flags::Unsigned) at dsp.jl:245",
          "plan_idct!(X,region) at dsp.jl:247"
        ]
      },
      {
        "name": "plan_ifft",
        "summary": "Function",
        "help": "Base.plan_ifft(A[, dims[, flags[, timelimit]]])\n\n   Same as \"plan_fft()\", but produces a plan that performs inverse\n   transforms \"ifft()\".\n",
        "methods": 
        [
          "plan_ifft(x::Number) at fftw.jl:696",
          "plan_ifft(x::Number,dims) at fftw.jl:703",
          "plan_ifft(x::Number,dims,flags) at fftw.jl:710",
          "plan_ifft(x::Number,dims,flags,tlim) at fftw.jl:717",
          "plan_ifft(X,region,flags,tlim) at fftw.jl:510",
          "plan_ifft(X,region,flags) at fftw.jl:514",
          "plan_ifft(X,region) at fftw.jl:515",
          "plan_ifft(X) at fftw.jl:517"
        ]
      },
      {
        "name": "plan_ifft!",
        "summary": "Function",
        "help": "Base.plan_ifft!(A[, dims[, flags[, timelimit]]])\n\n   Same as \"plan_ifft()\", but operates in-place on \"A\".\n",
        "methods": 
        [
          "plan_ifft!(X,region,flags,tlim) at fftw.jl:510",
          "plan_ifft!(X,region,flags) at fftw.jl:514",
          "plan_ifft!(X,region) at fftw.jl:515",
          "plan_ifft!(X) at fftw.jl:517"
        ]
      },
      {
        "name": "plan_irfft",
        "summary": "Function",
        "help": "Base.plan_irfft(A, d[, dims[, flags[, timelimit]]])\n\n   Pre-plan an optimized inverse real-input FFT, similar to\n   \"plan_rfft()\" except for \"irfft()\" and \"brfft()\",\n   respectively.  The first three arguments have the same meaning as\n   for \"irfft()\".\n",
        "methods": 
        [
          "plan_irfft(X::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),d::Integer,region,flags,tlim) at fftw.jl:668",
          "plan_irfft(x::Number,d::Integer) at fftw.jl:699",
          "plan_irfft(x::Number,d::Integer,dims) at fftw.jl:706",
          "plan_irfft(x::Number,d::Integer,dims,flags) at fftw.jl:713",
          "plan_irfft(x::Number,d::Integer,dims,flags,tlim) at fftw.jl:720",
          "plan_irfft(X,d,region,flags) at fftw.jl:676",
          "plan_irfft(X,d,region) at fftw.jl:677",
          "plan_irfft(X,d) at fftw.jl:678"
        ]
      },
      {
        "name": "plan_rfft",
        "summary": "Function",
        "help": "Base.plan_rfft(A[, dims[, flags[, timelimit]]])\n\n   Pre-plan an optimized real-input FFT, similar to \"plan_fft()\"\n   except for \"rfft()\" instead of \"fft()\".  The first two\n   arguments, and the size of the transformed result, are the same as\n   for \"rfft()\".\n",
        "methods": 
        [
          "plan_rfft(X::Union(SubArray{Float32,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Float32,N}),region,flags::Unsigned,tlim::Real) at fftw.jl:546",
          "plan_rfft(X::Union(SubArray{Float64,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Float64,N}),region,flags::Unsigned,tlim::Real) at fftw.jl:546",
          "plan_rfft(X::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),region,flags) at fftw.jl:639",
          "plan_rfft(X::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),region) at fftw.jl:641",
          "plan_rfft(X::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at fftw.jl:643",
          "plan_rfft(x::Real) at fftw.jl:698",
          "plan_rfft(x::Real,dims) at fftw.jl:705",
          "plan_rfft(x::Real,dims,flags) at fftw.jl:712",
          "plan_rfft(x::Real,dims,flags,tlim) at fftw.jl:719"
        ]
      },
      {
        "name": "pmap",
        "summary": "Function",
        "help": "Base.pmap(f, lsts...; err_retry=true, err_stop=false)\n\n   Transform collections \"lsts\" by applying \"f\" to each element in\n   parallel. If \"nprocs() > 1\", the calling process will be\n   dedicated to assigning tasks. All other available processes will be\n   used as parallel workers.\n\n   If \"err_retry\" is true, it retries a failed application of \"f\"\n   on a different worker. If \"err_stop\" is true, it takes precedence\n   over the value of \"err_retry\" and \"pmap\" stops execution on the\n   first error.\n",
        "methods": 
        [
          "pmap(f) at multi.jl:1303",
          "pmap(f,lsts...) at multi.jl:1312"
        ]
      },
      {
        "name": "pointer",
        "summary": "Function",
        "help": "Base.pointer(a[, index])\n\n   Get the native address of an array or string element. Be careful to\n   ensure that a julia reference to \"a\" exists as long as this\n   pointer will be used.\n\nBase.pointer(type, int)\n\n   Convert an integer to a pointer of the specified element type.\n",
        "methods": 
        [
          "pointer{T}(::Type{T},x::Uint64) at pointer.jl:25",
          "pointer{T}(::Type{T},x::Ptr{T}) at pointer.jl:26",
          "pointer(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Int64) at subarray.jl:404",
          "pointer(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},is::(Int64...,)) at subarray.jl:407",
          "pointer{T}(x::AbstractArray{T,N}) at pointer.jl:30",
          "pointer{T}(x::AbstractArray{T,N},i::Integer) at pointer.jl:31",
          "pointer(x::Union(UTF8String,ASCIIString),i::Integer) at string.jl:1685",
          "pointer(x::Union(UTF16String,UTF32String),i::Integer) at string.jl:1687",
          "pointer(x::Union(ASCIIString,UTF16String,UTF32String,UTF8String)) at string.jl:1683",
          "pointer{T<:Union(UTF8String,ASCIIString)}(x::SubString{T<:Union(UTF8String,ASCIIString)}) at string.jl:1684",
          "pointer{T<:Union(UTF8String,ASCIIString)}(x::SubString{T<:Union(UTF8String,ASCIIString)},i::Integer) at string.jl:1686",
          "pointer{T<:Union(UTF16String,UTF32String)}(x::SubString{T<:Union(UTF16String,UTF32String)}) at string.jl:1688",
          "pointer{T<:Union(UTF16String,UTF32String)}(x::SubString{T<:Union(UTF16String,UTF32String)},i::Integer) at string.jl:1689"
        ]
      },
      {
        "name": "pointer_from_objref",
        "summary": "Function",
        "help": "Base.pointer_from_objref(obj)\n\n   Get the memory address of a Julia object as a \"Ptr\". The\n   existence of the resulting \"Ptr\" will not protect the object from\n   garbage collection, so you must ensure that the object remains\n   referenced for the whole time that the \"Ptr\" will be used.\n",
        "methods": 
        [
          "pointer_from_objref(x) at pointer.jl:55"
        ]
      },
      {
        "name": "pointer_to_array",
        "summary": "Function",
        "help": "Base.pointer_to_array(p, dims[, own])\n\n   Wrap a native pointer as a Julia Array object. The pointer element\n   type determines the array element type. \"own\" optionally\n   specifies whether Julia should take ownership of the memory,\n   calling \"free\" on the pointer when the array is no longer\n   referenced.\n",
        "methods": 
        [
          "pointer_to_array(p,d::Integer) at pointer.jl:34",
          "pointer_to_array(p,d::Integer,own) at pointer.jl:34",
          "pointer_to_array{T,N}(p::Ptr{T},dims::NTuple{N,Int64}) at pointer.jl:36",
          "pointer_to_array{T,N}(p::Ptr{T},dims::NTuple{N,Int64},own::Bool) at pointer.jl:36",
          "pointer_to_array{T,N}(p::Ptr{T},dims::NTuple{N,Integer}) at pointer.jl:40",
          "pointer_to_array{T,N}(p::Ptr{T},dims::NTuple{N,Integer},own::Bool) at pointer.jl:40"
        ]
      },
      {
        "name": "poll_fd",
        "summary": "Function",
        "help": "Base.poll_fd(fd, seconds::Real; readable=false, writable=false)\n\n   Poll a file descriptor fd for changes in the read or write\n   availability and with a timeout given by the second argument. If\n   the timeout is not needed, use \"wait(fd)\" instead. The keyword\n   arguments determine which of read and/or write status should be\n   monitored and at least one of them needs to be set to true. The\n   returned value is an object with boolean fields \"readable\",\n   \"writable\", and \"timedout\", giving the result of the polling.\n",
        "methods": 
        [
          "poll_fd(s,seconds::Real) at poll.jl:298"
        ]
      },
      {
        "name": "poll_file",
        "summary": "Function",
        "help": "Base.poll_file(s, interval_seconds::Real, seconds::Real)\n\n   Monitor a file for changes by polling every *interval_seconds*\n   seconds for *seconds* seconds. A return value of true indicates the\n   file changed, a return value of false indicates a timeout.\n",
        "methods": 
        [
          "poll_file(s,interval_seconds::Real,seconds::Real) at poll.jl:309"
        ]
      },
      {
        "name": "polygamma",
        "summary": "Function",
        "help": "Base.polygamma(m, x)\n\n   Compute the polygamma function of order \"m\" of argument \"x\"\n   (the \"(m+1)th\" derivative of the logarithm of \"gamma(x)\")\n",
        "methods": 
        [
          "polygamma(k::Int64,x::Float64) at math.jl:1010",
          "polygamma(k::Int64,x::Float32) at math.jl:1011",
          "polygamma(k::Int64,x::Real) at math.jl:1012"
        ]
      },
      {
        "name": "pop!",
        "summary": "Function",
        "help": "Base.pop!(collection, key[, default])\n\n   Delete and return the mapping for \"key\" if it exists in\n   \"collection\", otherwise return \"default\", or throw an error if\n   default is not specified.\n\nBase.pop!(collection) -> item\n\n   Remove the last item in a collection and return it.\n",
        "methods": 
        [
          "pop!(a::Array{T,1}) at array.jl:512",
          "pop!(B::BitArray{1}) at bitarray.jl:538",
          "pop!(s::IntSet,n::Integer,deflt) at intset.jl:52",
          "pop!(s::IntSet,n::Integer) at intset.jl:69",
          "pop!(s::IntSet) at intset.jl:76",
          "pop!(t::ObjectIdDict,key::ANY,default::ANY) at dict.jl:175",
          "pop!(t::ObjectIdDict,key::ANY) at dict.jl:179",
          "pop!(h::Dict{K,V},key) at dict.jl:542",
          "pop!(h::Dict{K,V},key,default) at dict.jl:547",
          "pop!{K}(wkh::WeakKeyDict{K,V},key) at dict.jl:641",
          "pop!{K}(wkh::WeakKeyDict{K,V},key,def) at dict.jl:642",
          "pop!(s::Set{T},x) at set.jl:19",
          "pop!(s::Set{T},x,deflt) at set.jl:20",
          "pop!(s::Set{T}) at set.jl:38",
          "pop!(::EnvHash,k::String) at env.jl:78",
          "pop!(::EnvHash,k::String,def) at env.jl:79",
          "pop!{T}(q::Deque{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:238",
          "pop!(s::Stack{S}) at /home/samuel/.julia/v0.3/DataStructures/src/stack.jl:20",
          "pop!{T,V<:Number}(ct::Accumulator{T,V<:Number},x::T) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:57",
          "pop!{K}(cc::Accumulator{K,V<:Number},key::K) at /home/samuel/.julia/v0.3/DataStructures/src/classifiedcollections.jl:52",
          "pop!{T}(h::BinaryHeap{T,Comp}) at /home/samuel/.julia/v0.3/DataStructures/src/heaps/binary_heap.jl:145",
          "pop!{T}(h::MutableBinaryHeap{T,Comp}) at /home/samuel/.julia/v0.3/DataStructures/src/heaps/mutable_binary_heap.jl:213",
          "pop!(h::HashDict{K,V,O<:Union(Nothing,Int64)},key) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:435",
          "pop!(h::HashDict{K,V,O<:Union(Nothing,Int64)},key,default) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:440",
          "pop!(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "pop!(s::OrderedSet{T},x) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:27",
          "pop!(s::OrderedSet{T},x,deflt) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:28",
          "pop!(s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:46",
          "pop!(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "pop!(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "pop!(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11"
        ]
      },
      {
        "name": "popdisplay",
        "summary": "Function",
        "help": "Base.popdisplay()\nBase.popdisplay(d::Display)\n\n   Pop the topmost backend off of the display-backend stack, or the\n   topmost copy of \"d\" in the second variant.\n",
        "methods": 
        [
          "popdisplay() at multimedia.jl:133",
          "popdisplay(d::Display) at multimedia.jl:135"
        ]
      },
      {
        "name": "position",
        "summary": "Function",
        "help": "Base.position(s)\n\n   Get the current position of a stream.\n",
        "methods": 
        [
          "position(io::IOBuffer) at iobuffer.jl:96",
          "position(s::IOStream) at io.jl:305",
          "position(h::CFILE) at io.jl:334",
          "position(f::File) at fs.jl:236"
        ]
      },
      {
        "name": "powermod",
        "summary": "Function",
        "help": "Base.powermod(x, p, m)\n\n   Compute x^p \\pmod m\n",
        "methods": 
        [
          "powermod(x::BigInt,p::BigInt,m::BigInt) at gmp.jl:354",
          "powermod(x::BigInt,p::Integer,m::BigInt) at gmp.jl:361",
          "powermod(x::BigInt,p::Integer,m::Integer) at gmp.jl:362",
          "powermod{T}(b::Integer,p::Integer,m::T) at intfuncs.jl:90"
        ]
      },
      {
        "name": "precision",
        "summary": "Function",
        "help": "Base.precision(num::FloatingPoint)\n\n   Get the precision of a floating point number, as defined by the\n   effective number of bits in the mantissa.\n",
        "methods": 
        [
          "precision(::Float16) at float.jl:234",
          "precision(::Float32) at float.jl:235",
          "precision(::Float64) at float.jl:236",
          "precision(x::BigFloat) at mpfr.jl:586"
        ]
      },
      {
        "name": "precompile",
        "summary": "Function",
        "help": "Base.precompile(f, args::(Any..., ))\n\n   Compile the given function *f* for the argument tuple (of types)\n   *args*, but do not execute it.\n",
        "methods": 
        [
          "precompile(f,args::(Any...,)) at base.jl:188"
        ]
      },
      {
        "name": "prepend!",
        "summary": "Function",
        "help": "Base.prepend!(collection, items) -> collection\n\n   Insert the elements of \"items\" to the beginning of a collection.\n   \"prepend!([3],[1,2]) => [1,2,3]\"\n",
        "methods": 
        [
          "prepend!(A::Array{Bool,1},items::BitArray{1}) at bitarray.jl:511",
          "prepend!{T}(a::Array{T,1},items::AbstractArray{T,1}) at array.jl:480",
          "prepend!(B::BitArray{1},items::BitArray{1}) at bitarray.jl:492",
          "prepend!(B::BitArray{1},items::AbstractArray{Bool,1}) at bitarray.jl:510"
        ]
      },
      {
        "name": "prevfloat",
        "summary": "Function",
        "help": "Base.prevfloat(f) -> FloatingPoint\n\n   Get the previous floating point number in lexicographic order\n",
        "methods": 
        [
          "prevfloat(x::BigFloat) at mpfr.jl:679",
          "prevfloat(x::FloatingPoint) at float.jl:256"
        ]
      },
      {
        "name": "prevind",
        "summary": "Function",
        "help": "Base.prevind(str, i)\n\n   Get the previous valid string index before \"i\". Returns a value\n   less than \"1\" at the beginning of the string.\n",
        "methods": 
        [
          "prevind(s::DirectIndexString,i::Integer) at string.jl:106",
          "prevind(s::SubString{T<:String},i::Integer) at string.jl:648",
          "prevind(s::String,i::Integer) at string.jl:112",
          "prevind(s,i::Integer) at string.jl:107"
        ]
      },
      {
        "name": "prevpow",
        "summary": "Function",
        "help": "Base.prevpow(a, x)\n\n   The largest \"a^n\" not greater than \"x\", where \"n\" is a non-\n   negative integer. \"a\" must be greater than 1, and \"x\" must not\n   be less than 1.\n",
        "methods": 
        [
          "prevpow(a::Real,x::Real) at intfuncs.jl:130"
        ]
      },
      {
        "name": "prevpow2",
        "summary": "Function",
        "help": "Base.prevpow2(n)\n\n   The largest power of two not greater than \"n\". Returns 0 for\n   \"n==0\", and returns \"-prevpow2(-n)\" for negative arguments.\n",
        "methods": 
        [
          "prevpow2(x::Unsigned) at intfuncs.jl:114",
          "prevpow2(x::BigInt) at gmp.jl:442",
          "prevpow2(x::Integer) at intfuncs.jl:115"
        ]
      },
      {
        "name": "prevprod",
        "summary": "Function",
        "help": "Base.prevprod([k_1, k_2, ...], n)\n\n   Previous integer not greater than \"n\" that can be written as\n   \\prod k_i^{p_i} for integers p_1, p_2, etc.\n",
        "methods": 
        [
          "prevprod(a::Array{Int64,1},x) at combinatorics.jl:613"
        ]
      },
      {
        "name": "primes",
        "summary": "Function",
        "help": "Base.primes(n)\n\n   Returns a collection of the prime numbers <= \"n\".\n",
        "methods": 
        [
          "primes(n::Union(AbstractArray{Bool,1},Integer)) at primes.jl:31"
        ]
      },
      {
        "name": "print",
        "summary": "Function",
        "help": "Base.print(x)\n\n   Write (to the default output stream) a canonical (un-decorated)\n   text representation of a value if there is one, otherwise call\n   \"show\". The representation used by \"print\" includes minimal\n   formatting and tries to avoid Julia-specific details.\n\nBase.Profile.print([io::IO = STDOUT], [data::Vector]; format = :tree, C = false, combine = true, cols = tty_cols())\n\n   Prints profiling results to \"io\" (by default, \"STDOUT\"). If you\n   do not supply a \"data\" vector, the internal buffer of accumulated\n   backtraces will be used.  \"format\" can be \":tree\" or \":flat\".\n   If \"C==true\", backtraces from C and Fortran code are shown.\n   \"combine==true\" merges instruction pointers that correspond to\n   the same line of code.  \"cols\" controls the width of the display.\n\nBase.Profile.print([io::IO = STDOUT], data::Vector, lidict::Dict; format = :tree, combine = true, cols = tty_cols())\n\n   Prints profiling results to \"io\". This variant is used to examine\n   results exported by a previous call to \"Profile.retrieve()\".\n   Supply the vector \"data\" of backtraces and a dictionary\n   \"lidict\" of line information.\n",
        "methods": 
        [
          "print(io::IO,c::Char) at char.jl:52",
          "print(io::IO,s::ASCIIString) at ascii.jl:93",
          "print(io::IO,s::UTF8String) at utf8.jl:156",
          "print(io::IOBuffer,s::SubString{T<:String}) at string.jl:622",
          "print(io::IO,s::RopeString) at string.jl:789",
          "print(io::IO,s::String) at string.jl:67",
          "print(io::IO,s::Symbol) at show.jl:4",
          "print(io::IO,n::Unsigned) at show.jl:183",
          "print(io::IO,ex::Union(Expr,LabelNode,QuoteNode,GotoNode,SymbolNode,LineNumberNode,TopNode)) at show.jl:211",
          "print(io::IO,ip::IPv4) at socket.jl:30",
          "print(io::IO,ip::IPv6) at socket.jl:85",
          "print{mime}(io::IO,::MIME{mime}) at multimedia.jl:17",
          "print(io::IO,x::Float32) at grisu.jl:118",
          "print(io::IO,x::Float16) at grisu.jl:119",
          "print(io::IO,b::BigFloat) at mpfr.jl:712",
          "print(io::IO,v::VersionNumber) at version.jl:42",
          "print(io::IO,uri::URI) at /home/samuel/.julia/v0.3/URIParser/src/parser.jl:299",
          "print(io::IO,x) at string.jl:3",
          "print(io::IO,xs...) at string.jl:4",
          "print(xs...) at string.jl:7"
        ]
      },
      {
        "name": "print_escaped",
        "summary": "Function",
        "help": "Base.print_escaped(io, str::String, esc::String)\n\n   General escaping of traditional C and Unicode escape sequences,\n   plus any characters in esc are also escaped (with a backslash).\n",
        "methods": 
        [
          "print_escaped(io,s::String,esc::String) at string.jl:858"
        ]
      },
      {
        "name": "print_joined",
        "summary": "Function",
        "help": "Base.print_joined(io, items, delim[, last])\n\n   Print elements of \"items\" to \"io\" with \"delim\" between them.\n   If \"last\" is specified, it is used as the final delimiter instead\n   of \"delim\".\n",
        "methods": 
        [
          "print_joined(io,strings,delim,last) at string.jl:1370",
          "print_joined(io,strings,delim) at string.jl:1384",
          "print_joined(io,strings) at string.jl:1393"
        ]
      },
      {
        "name": "print_shortest",
        "summary": "Function",
        "help": "Base.print_shortest(io, x)\n\n   Print the shortest possible representation of number \"x\" as a\n   floating point number, ensuring that it would parse to the exact\n   same number.\n",
        "methods": 
        [
          "print_shortest(io::IO,x::Float64,dot::Bool) at grisu.jl:176",
          "print_shortest(io::IO,x::Float32,dot::Bool) at grisu.jl:177",
          "print_shortest(io::IO,x::Float16) at grisu.jl:178",
          "print_shortest(io::IO,x::Float16,dot::Bool) at grisu.jl:178",
          "print_shortest(io::IO,x::Union(FloatingPoint,Integer)) at grisu.jl:179"
        ]
      },
      {
        "name": "print_unescaped",
        "summary": "Function",
        "help": "Base.print_unescaped(io, s::String)\n\n   General unescaping of traditional C and Unicode escape sequences.\n   Reverse of \"print_escaped()\".\n",
        "methods": 
        [
          "print_unescaped(io,s::String) at string.jl:903"
        ]
      },
      {
        "name": "print_with_color",
        "summary": "Function",
        "help": "Base.print_with_color(color::Symbol[, io], strings...)\n\n   Print strings in a color specified as a symbol, for example\n   \":red\" or \":blue\".\n",
        "methods": 
        [
          "print_with_color(color::Symbol,io::IO,msg::String...) at util.jl:167",
          "print_with_color(color::Symbol,msg::String...) at util.jl:169"
        ]
      },
      {
        "name": "println",
        "summary": "Function",
        "help": "Base.println(x)\n\n   Print (using \"print()\") \"x\" followed by a newline.\n",
        "methods": 
        [
          "println(io::IO,xs...) at string.jl:5",
          "println(xs...) at string.jl:8"
        ]
      },
      {
        "name": "process_exited",
        "summary": "Function",
        "help": "Base.process_exited(p::Process)\n\n   Determine whether a process has exited.\n",
        "methods": 
        [
          "process_exited(s::Process) at process.jl:537",
          "process_exited(s::Array{Process,1}) at process.jl:538",
          "process_exited(s::ProcessChain) at process.jl:539"
        ]
      },
      {
        "name": "process_running",
        "summary": "Function",
        "help": "Base.process_running(p::Process)\n\n   Determine whether a process is currently running.\n",
        "methods": 
        [
          "process_running(s::Process) at process.jl:533",
          "process_running(s::Array{Process,1}) at process.jl:534",
          "process_running(s::ProcessChain) at process.jl:535"
        ]
      },
      {
        "name": "procs",
        "summary": "Function",
        "help": "Base.procs()\n\n   Returns a list of all process identifiers.\n\nBase.procs(d)\n\n   Get the vector of processes storing pieces of \"d\".\n\nBase.procs(S::SharedArray)\n\n   Get the vector of processes that have mapped the shared array\n",
        "methods": 
        [
          "procs() at multi.jl:271",
          "procs(pid::Integer) at multi.jl:273",
          "procs(d::DArray{T,N,A}) at darray.jl:59",
          "procs(S::SharedArray{T,N}) at sharedarray.jl:130"
        ]
      },
      {
        "name": "prod",
        "summary": "Function",
        "help": "Base.prod(itr)\n\n   Returns the product of all elements of a collection.\n\nBase.prod(A, dims)\n\n   Multiply elements of an array over the given dimensions.\n",
        "methods": 
        [
          "prod(x::()) at tuple.jl:121",
          "prod(x::(Any,Any...)) at tuple.jl:122",
          "prod(f::Function,A::AbstractArray{T,N}) at reduce.jl:442",
          "prod(f::Function,itr) at reduce.jl:413",
          "prod(x::Number) at reduce.jl:418",
          "prod{T}(A::SparseMatrixCSC{T,Ti<:Integer}) at sparse/sparsematrix.jl:706",
          "prod{T}(A::SparseMatrixCSC{T,Ti<:Integer},region) at sparse/sparsematrix.jl:707",
          "prod(A::AbstractArray{Bool,N}) at reduce.jl:420",
          "prod(A::AbstractArray{Bool,N},region) at reducedim.jl:199",
          "prod{T}(A::AbstractArray{T,N}) at reduce.jl:435",
          "prod{T}(A::AbstractArray{T,N},region) at reducedim.jl:187",
          "prod(itr) at reduce.jl:400"
        ]
      },
      {
        "name": "prod!",
        "summary": "Function",
        "help": "Base.prod!(r, A)\n\n   Multiply elements of \"A\" over the singleton dimensions of \"r\",\n   and write results to \"r\".\n",
        "methods": 
        [
          "prod!{R}(r::AbstractArray{R,N},A::AbstractArray{T,N}) at reducedim.jl:184"
        ]
      },
      {
        "name": "produce",
        "summary": "Function",
        "help": "Base.produce(value)\n\n   Send the given value to the last \"consume\" call, switching to the\n   consumer task. If the next \"consume\" call passes any values, they\n   are returned by \"produce\".\n",
        "methods": 
        [
          "produce(v) at task.jl:95",
          "produce(v...) at task.jl:134"
        ]
      },
      {
        "name": "promote",
        "summary": "Function",
        "help": "Base.promote(xs...)\n\n   Convert all arguments to their common promotion type (if any), and\n   return them all (as a tuple).\n",
        "methods": 
        [
          "promote() at promotion.jl:120",
          "promote{T,S}(x::T,y::S) at promotion.jl:123",
          "promote(x) at promotion.jl:121",
          "promote(x,y,z) at promotion.jl:128",
          "promote(x,y,zs...) at promotion.jl:133"
        ]
      },
      {
        "name": "promote_rule",
        "summary": "Function",
        "help": "Base.promote_rule(type1, type2)\n\n   Specifies what type should be used by \"promote\" when given values\n   of types \"type1\" and \"type2\". This function should not be\n   called directly, but should have definitions added to it for new\n   types as appropriate.\n",
        "methods": 
        [
          "promote_rule{T1,T2}(::Type{FloatRange{T1}},::Type{FloatRange{T2}}) at range.jl:440",
          "promote_rule{F,OR<:OrdinalRange{T,S}}(::Type{FloatRange{F}},::Type{OR<:OrdinalRange{T,S}}) at range.jl:445",
          "promote_rule{T<:Number}(::Type{Bool},::Type{T<:Number}) at bool.jl:7",
          "promote_rule(::Type{Int16},::Type{Int8}) at int.jl:399",
          "promote_rule(::Type{Int32},::Type{Int8}) at int.jl:400",
          "promote_rule(::Type{Int32},::Type{Int16}) at int.jl:401",
          "promote_rule(::Type{Int64},::Type{Int8}) at int.jl:402",
          "promote_rule(::Type{Int64},::Type{Int16}) at int.jl:403",
          "promote_rule(::Type{Int64},::Type{Int32}) at int.jl:404",
          "promote_rule(::Type{Int128},::Type{Int8}) at int.jl:405",
          "promote_rule(::Type{Int128},::Type{Int16}) at int.jl:406",
          "promote_rule(::Type{Int128},::Type{Int32}) at int.jl:407",
          "promote_rule(::Type{Int128},::Type{Int64}) at int.jl:408",
          "promote_rule(::Type{Uint16},::Type{Uint8}) at int.jl:410",
          "promote_rule(::Type{Uint32},::Type{Uint8}) at int.jl:411",
          "promote_rule(::Type{Uint32},::Type{Uint16}) at int.jl:412",
          "promote_rule(::Type{Uint64},::Type{Uint8}) at int.jl:413",
          "promote_rule(::Type{Uint64},::Type{Uint16}) at int.jl:414",
          "promote_rule(::Type{Uint64},::Type{Uint32}) at int.jl:415",
          "promote_rule(::Type{Uint128},::Type{Uint8}) at int.jl:416",
          "promote_rule(::Type{Uint128},::Type{Uint16}) at int.jl:417",
          "promote_rule(::Type{Uint128},::Type{Uint32}) at int.jl:418",
          "promote_rule(::Type{Uint128},::Type{Uint64}) at int.jl:419",
          "promote_rule(::Type{Uint8},::Type{Int8}) at int.jl:421",
          "promote_rule(::Type{Uint8},::Type{Int16}) at int.jl:422",
          "promote_rule(::Type{Uint8},::Type{Int32}) at int.jl:423",
          "promote_rule(::Type{Uint8},::Type{Int64}) at int.jl:424",
          "promote_rule(::Type{Uint8},::Type{Int128}) at int.jl:425",
          "promote_rule(::Type{Uint16},::Type{Int8}) at int.jl:427",
          "promote_rule(::Type{Uint16},::Type{Int16}) at int.jl:428",
          "promote_rule(::Type{Uint16},::Type{Int32}) at int.jl:429",
          "promote_rule(::Type{Uint16},::Type{Int64}) at int.jl:430",
          "promote_rule(::Type{Uint16},::Type{Int128}) at int.jl:431",
          "promote_rule(::Type{Uint32},::Type{Int8}) at int.jl:434",
          "promote_rule(::Type{Uint32},::Type{Int16}) at int.jl:435",
          "promote_rule(::Type{Uint32},::Type{Int32}) at int.jl:436",
          "promote_rule(::Type{Uint32},::Type{Int64}) at int.jl:442",
          "promote_rule(::Type{Uint32},::Type{Int128}) at int.jl:443",
          "promote_rule(::Type{Uint64},::Type{Int8}) at int.jl:445",
          "promote_rule(::Type{Uint64},::Type{Int16}) at int.jl:446",
          "promote_rule(::Type{Uint64},::Type{Int32}) at int.jl:447",
          "promote_rule(::Type{Uint64},::Type{Int64}) at int.jl:448",
          "promote_rule(::Type{Uint64},::Type{Int128}) at int.jl:449",
          "promote_rule(::Type{Uint128},::Type{Int8}) at int.jl:451",
          "promote_rule(::Type{Uint128},::Type{Int16}) at int.jl:452",
          "promote_rule(::Type{Uint128},::Type{Int32}) at int.jl:453",
          "promote_rule(::Type{Uint128},::Type{Int64}) at int.jl:454",
          "promote_rule(::Type{Uint128},::Type{Int128}) at int.jl:455",
          "promote_rule(::Type{Float32},::Type{Int128}) at float.jl:5",
          "promote_rule(::Type{Float32},::Type{Uint128}) at float.jl:6",
          "promote_rule(::Type{Float64},::Type{Int128}) at float.jl:10",
          "promote_rule(::Type{Float64},::Type{Uint128}) at float.jl:11",
          "promote_rule(::Type{Float16},::Type{Bool}) at float.jl:15",
          "promote_rule(::Type{Float16},::Type{Char}) at float.jl:15",
          "promote_rule(::Type{Float16},::Type{Int8}) at float.jl:15",
          "promote_rule(::Type{Float16},::Type{Int16}) at float.jl:15",
          "promote_rule(::Type{Float16},::Type{Int32}) at float.jl:15",
          "promote_rule(::Type{Float16},::Type{Int64}) at float.jl:15",
          "promote_rule(::Type{Float16},::Type{Uint8}) at float.jl:15",
          "promote_rule(::Type{Float16},::Type{Uint16}) at float.jl:15",
          "promote_rule(::Type{Float16},::Type{Uint32}) at float.jl:15",
          "promote_rule(::Type{Float16},::Type{Uint64}) at float.jl:15",
          "promote_rule(::Type{Float32},::Type{Int8}) at float.jl:22",
          "promote_rule(::Type{Float32},::Type{Int16}) at float.jl:22",
          "promote_rule(::Type{Float32},::Type{Int32}) at float.jl:22",
          "promote_rule(::Type{Float32},::Type{Int64}) at float.jl:22",
          "promote_rule(::Type{Float32},::Type{Bool}) at float.jl:28",
          "promote_rule(::Type{Float32},::Type{Char}) at float.jl:28",
          "promote_rule(::Type{Float32},::Type{Uint8}) at float.jl:28",
          "promote_rule(::Type{Float32},::Type{Uint16}) at float.jl:28",
          "promote_rule(::Type{Float32},::Type{Uint32}) at float.jl:28",
          "promote_rule(::Type{Float32},::Type{Uint64}) at float.jl:28",
          "promote_rule(::Type{Float64},::Type{Int8}) at float.jl:22",
          "promote_rule(::Type{Float64},::Type{Int16}) at float.jl:22",
          "promote_rule(::Type{Float64},::Type{Int32}) at float.jl:22",
          "promote_rule(::Type{Float64},::Type{Int64}) at float.jl:22",
          "promote_rule(::Type{Float64},::Type{Bool}) at float.jl:28",
          "promote_rule(::Type{Float64},::Type{Char}) at float.jl:28",
          "promote_rule(::Type{Float64},::Type{Uint8}) at float.jl:28",
          "promote_rule(::Type{Float64},::Type{Uint16}) at float.jl:28",
          "promote_rule(::Type{Float64},::Type{Uint32}) at float.jl:28",
          "promote_rule(::Type{Float64},::Type{Uint64}) at float.jl:28",
          "promote_rule(::Type{Float32},::Type{Float16}) at float.jl:112",
          "promote_rule(::Type{Float64},::Type{Float16}) at float.jl:113",
          "promote_rule(::Type{Float64},::Type{Float32}) at float.jl:114",
          "promote_rule{T<:Real,S<:Real}(::Type{Complex{T<:Real}},::Type{S<:Real}) at complex.jl:24",
          "promote_rule{T<:Real,S<:Real}(::Type{Complex{T<:Real}},::Type{Complex{S<:Real}}) at complex.jl:26",
          "promote_rule{T<:Integer,S<:Integer}(::Type{Rational{T<:Integer}},::Type{S<:Integer}) at rational.jl:61",
          "promote_rule{T<:Integer,S<:Integer}(::Type{Rational{T<:Integer}},::Type{Rational{S<:Integer}}) at rational.jl:62",
          "promote_rule{T<:Integer,S<:FloatingPoint}(::Type{Rational{T<:Integer}},::Type{S<:FloatingPoint}) at rational.jl:63",
          "promote_rule(::Type{Char},::Type{Int8}) at char.jl:8",
          "promote_rule(::Type{Char},::Type{Uint8}) at char.jl:9",
          "promote_rule(::Type{Char},::Type{Int16}) at char.jl:10",
          "promote_rule(::Type{Char},::Type{Uint16}) at char.jl:11",
          "promote_rule(::Type{Char},::Type{Int32}) at char.jl:12",
          "promote_rule(::Type{Char},::Type{Uint32}) at char.jl:13",
          "promote_rule(::Type{Char},::Type{Int64}) at char.jl:14",
          "promote_rule(::Type{Char},::Type{Uint64}) at char.jl:15",
          "promote_rule(::Type{Char},::Type{Int128}) at char.jl:16",
          "promote_rule(::Type{Char},::Type{Uint128}) at char.jl:17",
          "promote_rule{S<:String,T<:String}(::Type{S<:String},::Type{T<:String}) at string.jl:836",
          "promote_rule{T<:Integer}(::Type{BigInt},::Type{T<:Integer}) at gmp.jl:175",
          "promote_rule{T<:FloatingPoint}(::Type{BigFloat},::Type{T<:FloatingPoint}) at mpfr.jl:124",
          "promote_rule{T<:Real}(::Type{BigFloat},::Type{T<:Real}) at mpfr.jl:122",
          "promote_rule{T<:FloatingPoint}(::Type{BigInt},::Type{T<:FloatingPoint}) at mpfr.jl:123",
          "promote_rule{T,S}(::Type{Array{T,2}},::Type{Bidiagonal{S}}) at linalg/bidiag.jl:32",
          "promote_rule{T,S}(::Type{Tridiagonal{T}},::Type{Bidiagonal{S}}) at linalg/bidiag.jl:40",
          "promote_rule{s}(::Type{MathConst{s}},::Type{Float32}) at constants.jl:7",
          "promote_rule{s,t}(::Type{MathConst{s}},::Type{MathConst{t}}) at constants.jl:8",
          "promote_rule{s,T<:Number}(::Type{MathConst{s}},::Type{T<:Number}) at constants.jl:9",
          "promote_rule(T,S) at promotion.jl:113"
        ]
      },
      {
        "name": "promote_shape",
        "summary": "Function",
        "help": "Base.promote_shape(s1, s2)\n\n   Check two array shapes for compatibility, allowing trailing\n   singleton dimensions, and return whichever shape has more\n   dimensions.\n",
        "methods": 
        [
          "promote_shape(a::(Int64,),b::(Int64,)) at operators.jl:178",
          "promote_shape(a::(Int64,Int64),b::(Int64,)) at operators.jl:185",
          "promote_shape(a::(Int64,),b::(Int64,Int64)) at operators.jl:191",
          "promote_shape(a::(Int64,Int64),b::(Int64,Int64)) at operators.jl:194",
          "promote_shape(a::(Int64...,),b::(Int64...,)) at operators.jl:201"
        ]
      },
      {
        "name": "promote_type",
        "summary": "Function",
        "help": "Base.promote_type(type1, type2)\n\n   Determine a type big enough to hold values of each argument type\n   without loss, whenever possible. In some cases, where no type\n   exists which to which both types can be promoted losslessly, some\n   loss is tolerated; for example, \"promote_type(Int64,Float64)\"\n   returns \"Float64\" even though strictly, not all \"Int64\" values\n   can be represented exactly as \"Float64\" values.\n",
        "methods": 
        [
          "promote_type() at promotion.jl:95",
          "promote_type(::Type{None},::Type{None}) at promotion.jl:100",
          "promote_type{T}(::Type{T},::Type{None}) at promotion.jl:102",
          "promote_type{T}(::Type{None},::Type{T}) at promotion.jl:103",
          "promote_type{T}(::Type{T},::Type{T}) at promotion.jl:101",
          "promote_type{T,S}(::Type{T},::Type{S}) at promotion.jl:110",
          "promote_type(T) at promotion.jl:96",
          "promote_type(T,S) at promotion.jl:97",
          "promote_type(T,S...) at promotion.jl:98"
        ]
      },
      {
        "name": "push!",
        "summary": "Function",
        "help": "Base.push!(collection, items...) -> collection\n\n   Insert items at the end of a collection.\n",
        "methods": 
        [
          "push!(a::Array{Any,1},item) at array.jl:464",
          "push!{T}(a::Array{T,1},item) at array.jl:453",
          "push!(B::BitArray{1},item) at bitarray.jl:454",
          "push!(s::IntSet,n::Integer) at intset.jl:32",
          "push!(::EnvHash,k::String,v) at env.jl:90",
          "push!(t::Associative{K,V},key,v) at dict.jl:140",
          "push!(s::Set{T},x) at set.jl:18",
          "push!{T}(q::Deque{T},x) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:192",
          "push!(s::Stack{S},x) at /home/samuel/.julia/v0.3/DataStructures/src/stack.jl:16",
          "push!{T,V<:Number}(ct::Accumulator{T,V<:Number},x::T) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:48",
          "push!(s::IntDisjointSets,x::Integer) at /home/samuel/.julia/v0.3/DataStructures/src/disjoint_set.jl:67",
          "push!(s::IntDisjointSets) at /home/samuel/.julia/v0.3/DataStructures/src/disjoint_set.jl:76",
          "push!{T}(s::DisjointSets{T},x::T) at /home/samuel/.julia/v0.3/DataStructures/src/disjoint_set.jl:119",
          "push!{T}(h::BinaryHeap{T,Comp},v::T) at /home/samuel/.julia/v0.3/DataStructures/src/heaps/binary_heap.jl:138",
          "push!{T}(h::MutableBinaryHeap{T,Comp},v::T) at /home/samuel/.julia/v0.3/DataStructures/src/heaps/mutable_binary_heap.jl:201",
          "push!(s::OrderedSet{T},x) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:26",
          "push!(a::SynchronousStepCollection,args...) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:104",
          "push!(c::Choices,args...) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:175",
          "push!(A) at abstractarray.jl:1379",
          "push!(A,a,b) at abstractarray.jl:1380",
          "push!(A,a,b,c...) at abstractarray.jl:1381"
        ]
      },
      {
        "name": "pushdisplay",
        "summary": "Function",
        "help": "Base.pushdisplay(d::Display)\n\n   Pushes a new display \"d\" on top of the global display-backend\n   stack.  Calling \"display(x)\" or \"display(mime, x)\" will display\n   \"x\" on the topmost compatible backend in the stack (i.e., the\n   topmost backend that does not throw a \"MethodError\").\n",
        "methods": 
        [
          "pushdisplay(d::Display) at multimedia.jl:130"
        ]
      },
      {
        "name": "put",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "put(uri::URI,data::String) at /home/samuel/.julia/v0.3/Requests/src/Requests.jl:570",
          "put(uri::String) at /home/samuel/.julia/v0.3/Requests/src/Requests.jl:575",
          "put(uri::URI) at /home/samuel/.julia/v0.3/Requests/src/Requests.jl:576",
          "put(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "put!",
        "summary": "Function",
        "help": "Base.put!(RemoteRef, value)\n\n   Store a value to a remote reference. Implements \"shared queue of\n   length 1\" semantics: if a value is already present, blocks until\n   the value is removed with \"take\". Returns its first argument.\n",
        "methods": 
        [
          "put!(rv::RemoteValue,val::ANY) at multi.jl:756",
          "put!(rr::RemoteRef,val::ANY) at multi.jl:764"
        ]
      },
      {
        "name": "pwd",
        "summary": "Function",
        "help": "Base.pwd() -> String\n\n   Get the current working directory.\n",
        "methods": 
        [
          "pwd() at file.jl:4"
        ]
      },
      {
        "name": "qr",
        "summary": "Function",
        "help": "Base.qr(A, [pivot=false,][thin=true]) -> Q, R, [p]\n\n   Compute the (pivoted) QR factorization of \"A\" such that either\n   \"A = Q*R\" or \"A[:,p] = Q*R\". Also see \"qrfact\". The default\n   is to compute a thin factorization. Note that \"R\" is not extended\n   with zeros when the full \"Q\" is requested.\n",
        "methods": 
        [
          "qr(A::BitArray{2}) at linalg/bitarray.jl:100",
          "qr(A::Union(AbstractArray{T,2},Number)) at linalg/factorization.jl:182"
        ]
      },
      {
        "name": "qrfact",
        "summary": "Function",
        "help": "Base.qrfact(A[, pivot=false]) -> F\n\n   Computes the QR factorization of \"A\". The return type of \"F\"\n   depends on the element type of \"A\" and whether pivoting is\n   specified (with \"pivot=true\").\n\n      +------------------+-------------------+-----------+---------------------------------------+\n      | Return type      | \\\"eltype(A)\\\"     | \\\"pivot\\\" | Relationship between \\\"F\\\" and \\\"A\\\"  |\n      +------------------+-------------------+-----------+---------------------------------------+\n      | \\\"QR\\\"           | not \\\"BlasFloat\\\" | either    | \\\"A==F[:Q]*F[:R]\\\"                    |\n      +------------------+-------------------+-----------+---------------------------------------+\n      | \\\"QRCompactWY\\\"  | \\\"BlasFloat\\\"     | \\\"true\\\"  | \\\"A==F[:Q]*F[:R]\\\"                    |\n      +------------------+-------------------+-----------+---------------------------------------+\n      | \\\"QRPivoted\\\"    | \\\"BlasFloat\\\"     | \\\"false\\\" | \\\"A[:,F[:p]]==F[:Q]*F[:R]\\\"           |\n      +------------------+-------------------+-----------+---------------------------------------+\n\n   \"BlasFloat\" refers to any of: \"Float32\", \"Float64\",\n   \"Complex64\" or \"Complex128\".\n\n   The individual components of the factorization \"F\" can be\n   accessed by indexing:\n\n      +-------------+-----------------------------------------------+--------------------+-----------------------+--------------------+\n      | Component   | Description                                   | \\\"QR\\\"             | \\\"QRCompactWY\\\"       | \\\"QRPivoted\\\"      |\n      +-------------+-----------------------------------------------+--------------------+-----------------------+--------------------+\n      | \\\"F[:Q]\\\"   | \\\"Q\\\" (orthogonal/unitary) part of \\\"QR\\\"     | ✓ (\\\"QRPackedQ\\\")  | ✓ (\\\"QRCompactWYQ\\\")  | ✓ (\\\"QRPackedQ\\\")  |\n      +-------------+-----------------------------------------------+--------------------+-----------------------+--------------------+\n      | \\\"F[:R]\\\"   | \\\"R\\\" (upper right triangular) part of \\\"QR\\\" | ✓                  | ✓                     | ✓                  |\n      +-------------+-----------------------------------------------+--------------------+-----------------------+--------------------+\n      +-------------+-----------------------------------------------+--------------------+-----------------------+--------------------+\n      +-------------+-----------------------------------------------+--------------------+-----------------------+--------------------+\n\n   The following functions are available for the \"QR\" objects:\n   \"size\", \"\\\". When \"A\" is rectangular, \"\\\" will return a\n   least squares solution and if the solution is not unique, the one\n   with smallest norm is returned.\n\n   Multiplication with respect to either thin or full \"Q\" is\n   allowed, i.e. both \"F[:Q]*F[:R]\" and \"F[:Q]*A\" are supported. A\n   \"Q\" matrix can be converted into a regular matrix with \"full()\"\n   which has a named argument \"thin\".\n\n   Note: \"qrfact\" returns multiple types because LAPACK uses several\n     representations that minimize the memory storage requirements of\n     products of Householder elementary reflectors, so that the \"Q\"\n     and \"R\" matrices can be stored compactly rather as two separate\n     dense matrices.The data contained in \"QR\" or \"QRPivoted\" can\n     be used to construct the \"QRPackedQ\" type, which is a compact\n     representation of the rotation matrix:\n\n           Q = \\prod_{i=1}^{\\min(m,n)} (I - \\tau_i v_i v_i^T)\n\n     where \\tau_i is the scale factor and v_i is the projection\n     vector associated with the i^{th} Householder elementary\n     reflector.The data contained in \"QRCompactWY\" can be used to\n     construct the \"QRCompactWYQ\" type, which is a compact\n     representation of the rotation matrix\n\n           Q = I + Y T Y^T\n\n     where \"Y\" is m \\times r lower trapezoidal and \"T\" is r\n     \\times r upper triangular. The *compact WY* representation\n     [Schreiber1989] is not to be confused with the older, *WY*\n     representation [Bischof1987]. (The LAPACK documentation uses\n     \"V\" in lieu of \"Y\".)\n\n   [Bischof1987] C Bischof and C Van Loan, The WY representation for\n                 products of Householder matrices, SIAM J Sci Stat\n                 Comput 8 (1987), s2-s13. doi:10.1137/0908009\n\n   [Schreiber1989] R Schreiber and C Van Loan, A storage-efficient WY\n                   representation for products of Householder\n                   transformations, SIAM J Sci Stat Comput 10 (1989),\n                   53-57. doi:10.1137/0910005\n",
        "methods": 
        [
          "qrfact{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:177",
          "qrfact{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/factorization.jl:178",
          "qrfact(x::Number) at linalg/factorization.jl:179"
        ]
      },
      {
        "name": "qrfact!",
        "summary": "Function",
        "help": "Base.qrfact!(A[, pivot=false])\n\n   \"qrfact!\" is the same as \"qrfact()\", but saves space by\n   overwriting the input \"A\", instead of creating a copy.\n",
        "methods": 
        [
          "qrfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:153",
          "qrfact!{T}(A::AbstractArray{T,2}) at linalg/factorization.jl:155"
        ]
      },
      {
        "name": "qrp",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "qrp(A,thin) at deprecated.jl:26",
          "qrp(A) at deprecated.jl:26"
        ]
      },
      {
        "name": "qrpfact",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "qrpfact(A) at deprecated.jl:26"
        ]
      },
      {
        "name": "qrpfact!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "qrpfact!(A) at deprecated.jl:26"
        ]
      },
      {
        "name": "quadgk",
        "summary": "Function",
        "help": "Base.quadgk(f, a, b, c...; reltol=sqrt(eps), abstol=0, maxevals=10^7, order=7, norm=vecnorm)\n\n   Numerically integrate the function \"f(x)\" from \"a\" to \"b\",\n   and optionally over additional intervals \"b\" to \"c\" and so on.\n   Keyword options include a relative error tolerance \"reltol\"\n   (defaults to \"sqrt(eps)\" in the precision of the endpoints), an\n   absolute error tolerance \"abstol\" (defaults to 0), a maximum\n   number of function evaluations \"maxevals\" (defaults to \"10^7\"),\n   and the \"order\" of the integration rule (defaults to 7).\n\n   Returns a pair \"(I,E)\" of the estimated integral \"I\" and an\n   estimated upper bound on the absolute error \"E\".  If \"maxevals\"\n   is not exceeded then \"E <= max(abstol, reltol*norm(I))\" will\n   hold. (Note that it is useful to specify a positive \"abstol\" in\n   cases where \"norm(I)\" may be zero.)\n\n   The endpoints \"a\" etcetera can also be complex (in which case the\n   integral is performed over straight-line segments in the complex\n   plane).  If the endpoints are \"BigFloat\", then the integration\n   will be performed in \"BigFloat\" precision as well (note: it is\n   advisable to increase the integration \"order\" in rough proportion\n   to the precision, for smooth integrands).  More generally, the\n   precision is set by the precision of the integration endpoints\n   (promoted to floating-point types).\n\n   The integrand \"f(x)\" can return any numeric scalar, vector, or\n   matrix type, or in fact any type supporting \"+\", \"-\",\n   multiplication by real values, and a \"norm\" (i.e., any normed\n   vector space). Alternatively, a different norm can be specified by\n   passing a *norm*-like function as the *norm* keyword argument\n   (which defaults to *vecnorm*).\n\n   The algorithm is an adaptive Gauss-Kronrod integration technique:\n   the integral in each interval is estimated using a Kronrod rule\n   (\"2*order+1\" points) and the error is estimated using an embedded\n   Gauss rule (\"order\" points).   The interval with the largest\n   error is then subdivided into two intervals and the process is\n   repeated until the desired error tolerance is achieved.\n\n   These quadrature rules work best for smooth functions within each\n   interval, so if your function has a known discontinuity or other\n   singularity, it is best to subdivide your interval to put the\n   singularity at an endpoint.  For example, if \"f\" has a\n   discontinuity at \"x=0.7\" and you want to integrate from 0 to 1,\n   you should use \"quadgk(f, 0,0.7,1)\" to subdivide the interval at\n   the point of discontinuity.  The integrand is never evaluated\n   exactly at the endpoints of the intervals, so it is possible to\n   integrate functions that diverge at the endpoints as long as the\n   singularity is integrable (for example, a \"log(x)\" or\n   \"1/sqrt(x)\" singularity).\n\n   For real-valued endpoints, the starting and/or ending points may be\n   infinite.  (A coordinate transformation is performed internally to\n   map the infinite interval to a finite one.)\n",
        "methods": 
        [
          "quadgk{T<:FloatingPoint}(f,a::T<:FloatingPoint,b::T<:FloatingPoint,c::T<:FloatingPoint...) at quadgk.jl:156",
          "quadgk{T<:FloatingPoint}(f,a::Complex{T<:FloatingPoint},b::Complex{T<:FloatingPoint},c::Complex{T<:FloatingPoint}...) at quadgk.jl:163",
          "quadgk(f,a,b,c...) at quadgk.jl:169"
        ]
      },
      {
        "name": "quantile",
        "summary": "Function",
        "help": "Base.quantile(v, p)\n\n   Compute the quantiles of a vector \"v\" at a specified set of\n   probability values \"p\". Note: Julia does not ignore \"NaN\"\n   values in the computation.\n\nBase.quantile(v, p)\n\n   Compute the quantile of a vector \"v\" at the probability \"p\".\n   Note: Julia does not ignore \"NaN\" values in the computation.\n",
        "methods": 
        [
          "quantile(v::AbstractArray{T,1},q::AbstractArray{T,1}) at statistics.jl:571",
          "quantile(v::AbstractArray{T,1},q::Number) at statistics.jl:572"
        ]
      },
      {
        "name": "quantile!",
        "summary": "Function",
        "help": "Base.quantile!(v, p)\n\n   Like \"quantile\", but overwrites the input vector.\n",
        "methods": 
        [
          "quantile!(v::AbstractArray{T,1},q::AbstractArray{T,1}) at statistics.jl:551"
        ]
      },
      {
        "name": "quit",
        "summary": "Function",
        "help": "Base.quit()\n\n   Quit the program indicating that the processes completed\n   succesfully. This function calls \"exit(0)\" (see \"exit()\").\n",
        "methods": 
        [
          "quit() at client.jl:38"
        ]
      },
      {
        "name": "quote_string",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "quote_string(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "rad2deg",
        "summary": "Function",
        "help": "Base.rad2deg(x)\n\n   Convert \"x\" from radians to degrees\n",
        "methods": 
        [
          "rad2deg(z::Integer) at math.jl:149",
          "rad2deg(z::BigFloat) at mpfr.jl:372",
          "rad2deg(z::Real) at math.jl:147",
          "rad2deg{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "rad2deg{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "rad2deg{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "radians2degrees",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "radians2degrees(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "rand",
        "summary": "Function",
        "help": "Base.rand() -> Float64\n\n   Generate a \"Float64\" random number uniformly in [0,1)\n\nBase.rand(rng::AbstractRNG[, dims...])\n\n   Generate a random \"Float64\" number or array of the size specified\n   by dims, using the specified RNG object. Currently,\n   \"MersenneTwister\" is the only available Random Number Generator\n   (RNG), which may be seeded using srand.\n\nBase.rand(dims or [dims...])\n\n   Generate a random \"Float64\" array of the size specified by dims\n\nBase.rand(Int32|Uint32|Int64|Uint64|Int128|Uint128[, dims...])\n\n   Generate a random integer of the given type. Optionally, generate\n   an array of random integers of the given type by specifying dims.\n\nBase.rand(r[, dims...])\n\n   Generate a random integer from the inclusive interval specified by\n   \"Range1 r\" (for example, \"1:n\"). Optionally, generate a random\n   integer array.\n",
        "methods": 
        [
          "rand(::Type{Float64}) at random.jl:88",
          "rand() at random.jl:89",
          "rand(::Type{Float32}) at random.jl:91",
          "rand(::Type{Float16}) at random.jl:92",
          "rand{T<:Real}(::Type{Complex{T<:Real}}) at random.jl:94",
          "rand(r::MersenneTwister) at random.jl:97",
          "rand(::Type{Uint8}) at random.jl:104",
          "rand(::Type{Uint16}) at random.jl:105",
          "rand(::Type{Uint32}) at random.jl:106",
          "rand(::Type{Uint64}) at random.jl:107",
          "rand(::Type{Uint128}) at random.jl:108",
          "rand(::Type{Int8}) at random.jl:110",
          "rand(::Type{Int16}) at random.jl:111",
          "rand(::Type{Int32}) at random.jl:112",
          "rand(::Type{Int64}) at random.jl:113",
          "rand(::Type{Int128}) at random.jl:114",
          "rand(::Type{Float64},dims::(Int64...,)) at random.jl:118",
          "rand(::Type{Float64},dims::Int64...) at random.jl:119",
          "rand(dims::(Int64...,)) at random.jl:121",
          "rand(dims::Int64...) at random.jl:122",
          "rand(r::AbstractRNG,dims::(Int64...,)) at random.jl:124",
          "rand(r::AbstractRNG,dims::Int64...) at random.jl:125",
          "rand{T<:Number}(::Type{T<:Number}) at random.jl:134",
          "rand(T::Type{T<:Top},dims::(Int64...,)) at random.jl:133",
          "rand{T<:Number}(::Type{T<:Number},dims::Int64...) at random.jl:135",
          "rand{T<:Union(Uint64,Int64)}(g::RandIntGen{T<:Union(Uint64,Int64),Uint64}) at random.jl:177",
          "rand{T<:Integer,U<:Unsigned}(g::RandIntGen{T<:Integer,U<:Unsigned}) at random.jl:193",
          "rand{T<:Union(Char,Signed,Bool,Unsigned)}(r::UnitRange{T<:Union(Char,Signed,Bool,Unsigned)}) at random.jl:200",
          "rand{T<:Real}(r::Range{T<:Real}) at random.jl:201",
          "rand{T<:Real}(r::Range{T<:Real},dims::(Int64...,)) at random.jl:228",
          "rand(r::Range{T},dims::Int64...) at random.jl:229"
        ]
      },
      {
        "name": "rand!",
        "summary": "Function",
        "help": "Base.rand!([rng], A)\n\n   Populate the array A with random number generated from the\n   specified RNG.\n",
        "methods": 
        [
          "rand!{T}(A::Array{T,N}) at random.jl:128",
          "rand!(g::RandIntGen{T<:Integer,U<:Unsigned},A::AbstractArray{T,N}) at random.jl:204",
          "rand!{T<:Union(Char,Signed,Bool,Unsigned)}(r::UnitRange{T<:Union(Char,Signed,Bool,Unsigned)},A::AbstractArray{T,N}) at random.jl:210",
          "rand!{T<:Real}(r::Range{T<:Real},A::AbstractArray{T,N}) at random.jl:213",
          "rand!(B::BitArray{N}) at random.jl:234",
          "rand!{T}(S::SharedArray{T,N}) at sharedarray.jl:228"
        ]
      },
      {
        "name": "randbool",
        "summary": "Function",
        "help": "Base.randbool([dims...])\n\n   Generate a random boolean value. Optionally, generate an array of\n   random boolean values.\n",
        "methods": 
        [
          "randbool(dims::(Int64...,)) at random.jl:236",
          "randbool() at random.jl:239",
          "randbool(dims::Int64...) at random.jl:237"
        ]
      },
      {
        "name": "randbool!",
        "summary": "Function",
        "help": "Base.randbool!(A)\n\n   Fill an array with random boolean values. A may be an \"Array\" or\n   a \"BitArray\".\n",
        "methods": 
        [
          "randbool!(B::BitArray{N}) at random.jl:240"
        ]
      },
      {
        "name": "randcycle",
        "summary": "Function",
        "help": "Base.randcycle(n)\n\n   Construct a random cyclic permutation of the given length.\n",
        "methods": 
        [
          "randcycle(n::Integer) at combinatorics.jl:119"
        ]
      },
      {
        "name": "randn",
        "summary": "Function",
        "help": "Base.randn([rng], dims or [dims...])\n\n   Generate a normally-distributed random number with mean 0 and\n   standard deviation 1. Optionally generate an array of normally-\n   distributed random numbers.\n",
        "methods": 
        [
          "randn() at random.jl:247",
          "randn(rng::MersenneTwister) at random.jl:248",
          "randn(dims::(Int64...,)) at random.jl:251",
          "randn(dims::Int64...) at random.jl:252"
        ]
      },
      {
        "name": "randn!",
        "summary": "Function",
        "help": "Base.randn!([rng], A::Array{Float64, N})\n\n   Fill the array A with normally-distributed (mean 0, standard\n   deviation 1) random numbers. Also see the rand function.\n",
        "methods": 
        [
          "randn!(A::Array{Float64,N}) at random.jl:249",
          "randn!(rng::MersenneTwister,A::Array{Float64,N}) at random.jl:250",
          "randn!(S::SharedArray{T,N}) at sharedarray.jl:236"
        ]
      },
      {
        "name": "randperm",
        "summary": "Function",
        "help": "Base.randperm(n)\n\n   Construct a random permutation of the given length.\n",
        "methods": 
        [
          "randperm(n::Integer) at combinatorics.jl:108"
        ]
      },
      {
        "name": "randstring",
        "summary": "Function",
        "help": "Base.randstring(len)\n\n   Create a random ASCII string of length \"len\", consisting of\n   upper- and lower-case letters and the digits 0-9\n",
        "methods": 
        [
          "randstring(n::Int64) at string.jl:1648",
          "randstring() at string.jl:1649"
        ]
      },
      {
        "name": "randsubseq",
        "summary": "Function",
        "help": "Base.randsubseq(A, p) -> Vector\n\n   Return a vector consisting of a random subsequence of the given\n   array \"A\", where each element of \"A\" is included (in order)\n   with independent probability \"p\".   (Complexity is linear in\n   \"p*length(A)\", so this function is efficient even if \"p\" is\n   small and \"A\" is large.)  Technically, this process is known as\n   \"Bernoulli sampling\" of \"A\".\n",
        "methods": 
        [
          "randsubseq{T}(A::AbstractArray{T,N},p::Real) at abstractarray.jl:1424"
        ]
      },
      {
        "name": "randsubseq!",
        "summary": "Function",
        "help": "Base.randsubseq!(S, A, p)\n\n   Like \"randsubseq\", but the results are stored in \"S\" (which is\n   resized as needed).\n",
        "methods": 
        [
          "randsubseq!(S::AbstractArray{T,N},A::AbstractArray{T,N},p::Real) at abstractarray.jl:1391"
        ]
      },
      {
        "name": "range",
        "summary": "Function",
        "help": "Base.range(start[, step], length)\n\n   Construct a range by length, given a starting value and optional\n   step (defaults to 1).\n",
        "methods": 
        [
          "range(a::FloatingPoint,len::Integer) at range.jl:153",
          "range(a::Real,len::Integer) at range.jl:71",
          "range{T}(a::T,len::Integer) at range.jl:75",
          "range(a::FloatingPoint,st::FloatingPoint,len::Integer) at range.jl:154",
          "range(a::Real,st::FloatingPoint,len::Integer) at range.jl:155",
          "range(a::FloatingPoint,st::Real,len::Integer) at range.jl:156",
          "range{T,S}(a::T,step::S,len::Integer) at range.jl:86"
        ]
      },
      {
        "name": "rank",
        "summary": "Function",
        "help": "Base.rank(M)\n\n   Compute the rank of a matrix.\n",
        "methods": 
        [
          "rank(A::AbstractArray{T,2},tol::Real) at linalg/generic.jl:206",
          "rank(A::AbstractArray{T,2}) at linalg/generic.jl:208",
          "rank(x::Number) at linalg/generic.jl:213",
          "rank(C::CholeskyPivoted{T}) at linalg/factorization.jl:131"
        ]
      },
      {
        "name": "rationalize",
        "summary": "Function",
        "help": "Base.rationalize([Type], x)\n\n   Approximate the number x as a rational fraction\n",
        "methods": 
        [
          "rationalize{T<:Integer}(::Type{T<:Integer},x::FloatingPoint) at rational.jl:68",
          "rationalize(x::Union(Float64,Float32)) at rational.jl:92"
        ]
      },
      {
        "name": "read",
        "summary": "Function",
        "help": "Base.read(stream, type)\n\n   Read a value of the given type from a stream, in canonical binary\n   representation.\n\nBase.read(stream, type, dims)\n\n   Read a series of values of the given type from a stream, in\n   canonical binary representation. \"dims\" is either a tuple or a\n   series of integer arguments specifying the size of \"Array\" to\n   return.\n",
        "methods": 
        [
          "read{T<:Real}(s::IO,::Type{Complex{T<:Real}}) at complex.jl:84",
          "read(from::IOBuffer,::Type{Uint8}) at iobuffer.jl:70",
          "read{T}(from::IOBuffer,::Type{Ptr{T}}) at iobuffer.jl:87",
          "read(s::IOStream,::Type{Uint8}) at io.jl:420",
          "read(this::AsyncStream,::Type{Uint8}) at stream.jl:680",
          "read(f::File,::Type{Uint8}) at fs.jl:189",
          "read(t::UnixTerminal,::Type{Uint8}) at Terminals.jl:181",
          "read(io::Session,::Type{Uint8}) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:445",
          "read(s::IO,x::Type{Uint8}) at io.jl:103",
          "read(s::IO,::Type{Bool}) at io.jl:113",
          "read(s::IOStream,::Type{Char}) at io.jl:448",
          "read(s::IO,::Type{Char}) at io.jl:133",
          "read{T<:Integer}(s::IO,::Type{T<:Integer}) at io.jl:106",
          "read(s::IO,::Type{Float16}) at io.jl:114",
          "read(s::IO,::Type{Float32}) at io.jl:115",
          "read(s::IO,::Type{Float64}) at io.jl:116",
          "read{T}(s::IO,t::Type{T},d1::Int64,dims::Int64...) at io.jl:118",
          "read{T}(s::IO,t::Type{T},d1::Integer,dims::Integer...) at io.jl:120",
          "read{T}(s::AsyncStream,::Type{T},dims::(Int64...,)) at stream.jl:673",
          "read{T}(s::IO,::Type{T},dims::(Int64...,)) at io.jl:123",
          "read{T,N}(t::UnixTerminal,x::Array{T,N}) at Terminals.jl:177",
          "read(from::IOBuffer,a::Array{T,N}) at deprecated.jl:26",
          "read(from::IOBuffer,p::Ptr{T},nb::Integer) at deprecated.jl:26",
          "read(s::IOStream,a::Array{T,N}) at deprecated.jl:26",
          "read(this::AsyncStream,a::Array{T,N}) at deprecated.jl:26",
          "read(f::File,a::Array{T,N},nel) at deprecated.jl:26",
          "read(f::File,a::Array{T,N}) at deprecated.jl:26",
          "read(io::Session,data::Array{Uint8,1}) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:359",
          "read(s::IO,a::Array{T,N}) at deprecated.jl:26",
          "read(s::IO,B::BitArray{N}) at deprecated.jl:26"
        ]
      },
      {
        "name": "read!",
        "summary": "Function",
        "help": "Base.read!(stream, array::Array)\n\n   Read binary data from a stream, filling in the argument \"array\".\n",
        "methods": 
        [
          "read!(from::IOBuffer,a::Array{T,N}) at iobuffer.jl:43",
          "read!(from::IOBuffer,p::Ptr{T},nb::Int64) at iobuffer.jl:58",
          "read!(from::IOBuffer,p::Ptr{T},nb::Integer) at iobuffer.jl:56",
          "read!{T}(s::IOStream,a::Array{T,N}) at io.jl:428",
          "read!{Uint8}(s::AsyncStream,a::Array{Uint8,1}) at stream.jl:648",
          "read!{T}(s::AsyncStream,a::Array{T,N}) at stream.jl:641",
          "read!{T}(f::File,a::Array{T,N}) at fs.jl:198",
          "read!{T}(f::File,a::Array{T,N},nel) at fs.jl:198",
          "read!{T}(s::IO,a::Array{T,N}) at io.jl:126",
          "read!(s::IO,B::BitArray{N}) at io.jl:557"
        ]
      },
      {
        "name": "readall",
        "summary": "Function",
        "help": "Base.readall(stream)\n\n   Read the entire contents of an I/O stream as a string.\n",
        "methods": 
        [
          "readall(stream::AsyncStream) at stream.jl:635",
          "readall(io::Session) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:387",
          "readall(s::IO) at io.jl:210",
          "readall(filename::String) at io.jl:213",
          "readall(cmd::AbstractCmd) at process.jl:455",
          "readall(cmd::AbstractCmd,stdin::AsyncStream) at process.jl:455"
        ]
      },
      {
        "name": "readandwrite",
        "summary": "Function",
        "help": "Base.readandwrite(command)\n\n   Starts running a command asynchronously, and returns a tuple\n   (stdout,stdin,process) of the output stream and input stream of the\n   process, and the process object itself.\n",
        "methods": 
        [
          "readandwrite(cmds::AbstractCmd) at process.jl:441"
        ]
      },
      {
        "name": "readavailable",
        "summary": "Function",
        "help": "Base.readavailable(stream)\n\n   Read all available data on the stream, blocking the task only if no\n   data is available.\n",
        "methods": 
        [
          "readavailable(this::AsyncStream) at stream.jl:691",
          "readavailable(io::Session) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:398"
        ]
      },
      {
        "name": "readbytes",
        "summary": "Function",
        "help": "Base.readbytes(stream, nb=typemax(Int))\n\n   Read at most \"nb\" bytes from the stream, returning a\n   \"Vector{Uint8}\" of the bytes read.\n",
        "methods": 
        [
          "readbytes(io::IOBuffer) at iobuffer.jl:255",
          "readbytes(io::IOBuffer,nb) at iobuffer.jl:256",
          "readbytes(f::File) at fs.jl:226",
          "readbytes(io::File,nb) at fs.jl:223",
          "readbytes(s::IO) at io.jl:204",
          "readbytes(s::IO,nb) at io.jl:204",
          "readbytes(cmd::AbstractCmd) at process.jl:446",
          "readbytes(cmd::AbstractCmd,stdin::AsyncStream) at process.jl:446"
        ]
      },
      {
        "name": "readbytes!",
        "summary": "Function",
        "help": "Base.readbytes!(stream, b::Vector{Uint8}, nb=length(b))\n\n   Read at most \"nb\" bytes from the stream into \"b\", returning the\n   number of bytes read (increasing the size of \"b\" as needed).\n",
        "methods": 
        [
          "readbytes!(io::IOBuffer,b::Array{Uint8,N}) at iobuffer.jl:248",
          "readbytes!(io::IOBuffer,b::Array{Uint8,N},nb) at iobuffer.jl:248",
          "readbytes!(s::IOStream,b::Array{Uint8,N}) at io.jl:478",
          "readbytes!(s::IOStream,b::Array{Uint8,N},nb) at io.jl:478",
          "readbytes!(s::IO,b::AbstractArray{Uint8,N}) at io.jl:185",
          "readbytes!(s::IO,b::AbstractArray{Uint8,N},nb) at io.jl:185"
        ]
      },
      {
        "name": "readchomp",
        "summary": "Function",
        "help": "Base.readchomp(x)\n\n   Read the entirety of x as a string but remove trailing newlines.\n   Equivalent to chomp(readall(x)).\n",
        "methods": 
        [
          "readchomp(x) at io.jl:181"
        ]
      },
      {
        "name": "readcsv",
        "summary": "Function",
        "help": "Base.readcsv(source, [T::Type]; options...)\n\n   Equivalent to \"readdlm\" with \"delim\" set to comma.\n",
        "methods": 
        [
          "readcsv(io) at datafmt.jl:471",
          "readcsv(io,T::Type{T<:Top}) at datafmt.jl:472"
        ]
      },
      {
        "name": "readdir",
        "summary": "Function",
        "help": "Base.readdir([dir]) -> Vector{ByteString}\n\n   Returns the files and directories in the directory *dir* (or the\n   current working directory if not given).\n",
        "methods": 
        [
          "readdir(path::String) at file.jl:137",
          "readdir() at file.jl:163",
          "readdir(cmd::Cmd) at deprecated.jl:26"
        ]
      },
      {
        "name": "readdlm",
        "summary": "Function",
        "help": "Base.readdlm(source, delim::Char, T::Type, eol::Char; has_header=false, use_mmap, ignore_invalid_chars=false, quotes=true, dims, comments=true, comment_char='#')\n\n   Read a matrix from the source where each line (separated by\n   \"eol\") gives one row, with elements separated by the given\n   delimeter. The source can be a text file, stream or byte array.\n   Memory mapped files can be used by passing the byte array\n   representation of the mapped segment as source.\n\n   If \"T\" is a numeric type, the result is an array of that type,\n   with any non-numeric elements as \"NaN\" for floating-point types,\n   or zero. Other useful values of \"T\" include \"ASCIIString\",\n   \"String\", and \"Any\".\n\n   If \"has_header\" is \"true\", the first row of data would be read\n   as headers and the tuple \"(data_cells, header_cells)\" is returned\n   instead of only \"data_cells\".\n\n   If \"use_mmap\" is \"true\", the file specified by \"source\" is\n   memory mapped for potential speedups. Default is \"true\" except on\n   Windows. On Windows, you may want to specify \"true\" if the file\n   is large, and is only read once and not written to.\n\n   If \"ignore_invalid_chars\" is \"true\", bytes in \"source\" with\n   invalid character encoding will be ignored. Otherwise an error is\n   thrown indicating the offending character position.\n\n   If \"quotes\" is \"true\", column enclosed within double-quote (``)\n   characters are allowed to contain new lines and column delimiters.\n   Double-quote characters within a quoted field must be escaped with\n   another double-quote.\n\n   Specifying \"dims\" as a tuple of the expected rows and columns\n   (including header, if any) may speed up reading of large files.\n\n   If \"comments\" is \"true\", lines beginning with \"comment_char\"\n   and text following \"comment_char\" in any line are ignored.\n\nBase.readdlm(source, delim::Char, eol::Char; options...)\n\n   If all data is numeric, the result will be a numeric array. If some\n   elements cannot be parsed as numbers, a cell array of numbers and\n   strings is returned.\n\nBase.readdlm(source, delim::Char, T::Type; options...)\n\n   The end of line delimiter is taken as \"\\n\".\n\nBase.readdlm(source, delim::Char; options...)\n\n   The end of line delimiter is taken as \"\\n\". If all data is\n   numeric, the result will be a numeric array. If some elements\n   cannot be parsed as numbers, a cell array of numbers and strings is\n   returned.\n\nBase.readdlm(source, T::Type; options...)\n\n   The columns are assumed to be separated by one or more whitespaces.\n   The end of line delimiter is taken as \"\\n\".\n\nBase.readdlm(source; options...)\n\n   The columns are assumed to be separated by one or more whitespaces.\n   The end of line delimiter is taken as \"\\n\". If all data is\n   numeric, the result will be a numeric array. If some elements\n   cannot be parsed as numbers, a cell array of numbers and strings is\n   returned.\n",
        "methods": 
        [
          "readdlm(input,T::Type{T<:Top}) at datafmt.jl:43",
          "readdlm(input,dlm::Char,T::Type{T<:Top}) at datafmt.jl:44",
          "readdlm(input) at datafmt.jl:46",
          "readdlm(input,dlm::Char) at datafmt.jl:47",
          "readdlm(input,dlm::Char,eol::Char) at datafmt.jl:49",
          "readdlm(input,dlm::Char,T::Type{T<:Top},eol::Char) at datafmt.jl:50"
        ]
      },
      {
        "name": "readline",
        "summary": "Function",
        "help": "Base.readline(stream=STDIN)\n\n   Read a single line of text, including a trailing newline character\n   (if one is reached before the end of the input), from the given\n   \"stream\" (defaults to \"STDIN\"),\n",
        "methods": 
        [
          "readline(this::AsyncStream) at stream.jl:686",
          "readline(s::IO) at io.jl:180",
          "readline() at stream.jl:688"
        ]
      },
      {
        "name": "readlines",
        "summary": "Function",
        "help": "Base.readlines(stream)\n\n   Read all lines as an array.\n",
        "methods": 
        [
          "readlines() at io.jl:236",
          "readlines(s) at io.jl:236"
        ]
      },
      {
        "name": "readsfrom",
        "summary": "Function",
        "help": "Base.readsfrom(command)\n\n   Starts running a command asynchronously, and returns a tuple\n   (stream,process). The first value is a stream reading from the\n   process' standard output.\n",
        "methods": 
        [
          "readsfrom(cmds::AbstractCmd) at process.jl:427",
          "readsfrom(cmds::AbstractCmd,stdin::AsyncStream) at process.jl:429"
        ]
      },
      {
        "name": "readuntil",
        "summary": "Function",
        "help": "Base.readuntil(stream, delim)\n\n   Read a string, up to and including the given delimiter byte.\n",
        "methods": 
        [
          "readuntil(io::IOBuffer,delim::Uint8) at iobuffer.jl:264",
          "readuntil(t::UnixTerminal,c::Char) at Terminals.jl:179",
          "readuntil(s::IO,delim::Char) at io.jl:152",
          "readuntil(s::IOStream,delim::Uint8) at io.jl:474",
          "readuntil(t::UnixTerminal,s::String) at Terminals.jl:178",
          "readuntil(s::IO,t::String) at io.jl:497",
          "readuntil(this::AsyncStream,c::Uint8) at stream.jl:698",
          "readuntil(t::UnixTerminal,s) at Terminals.jl:180",
          "readuntil{T}(s::IO,delim::T) at io.jl:169"
        ]
      },
      {
        "name": "real",
        "summary": "Function",
        "help": "Base.real(z)\n\n   Return the real part of the complex number \"z\"\n",
        "methods": 
        [
          "real(z::Complex{T<:Real}) at complex.jl:31",
          "real(x::Real) at complex.jl:33",
          "real{T<:Real}(x::Union(DenseArray{T<:Real,N},SubArray{T<:Real,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at array.jl:680",
          "real(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:678",
          "real{T<:Real}(x::AbstractArray{T<:Real,N}) at abstractarray.jl:343"
        ]
      },
      {
        "name": "real_valued",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "real_valued(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "realmax",
        "summary": "Function",
        "help": "Base.realmax(type)\n\n   The highest finite value representable by the given floating-point\n   type\n",
        "methods": 
        [
          "realmax(::Type{Float16}) at float.jl:283",
          "realmax(::Type{Float32}) at float.jl:284",
          "realmax(::Type{Float64}) at float.jl:285",
          "realmax{T<:FloatingPoint}(x::T<:FloatingPoint) at float.jl:287",
          "realmax() at float.jl:289",
          "realmax(::Type{BigFloat}) at mpfr.jl:689"
        ]
      },
      {
        "name": "realmin",
        "summary": "Function",
        "help": "Base.realmin(type)\n\n   The smallest in absolute value non-subnormal value representable by\n   the given floating-point type\n",
        "methods": 
        [
          "realmin(::Type{Float16}) at float.jl:280",
          "realmin(::Type{Float32}) at float.jl:281",
          "realmin(::Type{Float64}) at float.jl:282",
          "realmin{T<:FloatingPoint}(x::T<:FloatingPoint) at float.jl:286",
          "realmin() at float.jl:288",
          "realmin(::Type{BigFloat}) at mpfr.jl:688"
        ]
      },
      {
        "name": "realpath",
        "summary": "Function",
        "help": "Base.realpath(path::String) -> String\n\n   Canonicalize a path by expanding symbolic links and removing \".\"\n   and \"..\" entries.\n",
        "methods": 
        [
          "realpath(path::String) at path.jl:126"
        ]
      },
      {
        "name": "recv",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "recv(sock::UdpSocket) at socket.jl:457"
        ]
      },
      {
        "name": "redirect_stderr",
        "summary": "Function",
        "help": "Base.redirect_stderr([stream])\n\n   Like redirect_stdout, but for STDERR\n",
        "methods": 
        [
          "redirect_stderr(handle::AsyncStream) at stream.jl:925",
          "redirect_stderr(handle::IOStream) at stream.jl:930",
          "redirect_stderr() at stream.jl:932"
        ]
      },
      {
        "name": "redirect_stdin",
        "summary": "Function",
        "help": "Base.redirect_stdin([stream])\n\n   Like redirect_stdout, but for STDIN. Note that the order of the\n   return tuple is still (rd,wr), i.e. data to be read from STDIN, may\n   be written to wr.\n",
        "methods": 
        [
          "redirect_stdin(handle::AsyncStream) at stream.jl:925",
          "redirect_stdin(handle::IOStream) at stream.jl:930",
          "redirect_stdin() at stream.jl:932"
        ]
      },
      {
        "name": "redirect_stdout",
        "summary": "Function",
        "help": "Base.redirect_stdout()\n\n   Create a pipe to which all C and Julia level STDOUT output will be\n   redirected. Returns a tuple (rd,wr) representing the pipe ends.\n   Data written to STDOUT may now be read from the rd end of the pipe.\n   The wr end is given for convenience in case the old STDOUT object\n   was cached by the user and needs to be replaced elsewhere.\n\nBase.redirect_stdout(stream)\n\n   Replace STDOUT by stream for all C and julia level output to\n   STDOUT. Note that *stream* must be a TTY, a Pipe or a TcpSocket.\n",
        "methods": 
        [
          "redirect_stdout(handle::AsyncStream) at stream.jl:925",
          "redirect_stdout(handle::IOStream) at stream.jl:930",
          "redirect_stdout() at stream.jl:932"
        ]
      },
      {
        "name": "redisplay",
        "summary": "Function",
        "help": "Base.redisplay(x)\nBase.redisplay(d::Display, x)\nBase.redisplay(mime, x)\nBase.redisplay(d::Display, mime, x)\n\n   By default, the \"redisplay\" functions simply call \"display\".\n   However, some display backends may override \"redisplay\" to modify\n   an existing display of \"x\" (if any).   Using \"redisplay\" is\n   also a hint to the backend that \"x\" may be redisplayed several\n   times, and the backend may choose to defer the display until (for\n   example) the next interactive prompt.\n",
        "methods": 
        [
          "redisplay(m::Union(String,MIME{mime}),x) at multimedia.jl:202",
          "redisplay(d::Display,m::Union(String,MIME{mime}),x) at multimedia.jl:211",
          "redisplay(d::Display,x) at multimedia.jl:210",
          "redisplay(x) at multimedia.jl:194"
        ]
      },
      {
        "name": "reduce",
        "summary": "Function",
        "help": "Base.reduce(op, v0, itr)\n\n   Reduce the given collection \"ìtr\" with the given binary operator.\n   Reductions for certain commonly-used operators have special\n   implementations which should be used instead: \"maximum(itr)\",\n   \"minimum(itr)\", \"sum(itr)\", \"prod(itr)\", \"any(itr)\",\n   \"all(itr)\".\n\n   The associativity of the reduction is implementation-dependent.\n   This means that you can't use non-associative operations like \"-\"\n   because it is undefined whether \"reduce(-,[1,2,3])\" should be\n   evaluated as \"(1-2)-3\" or \"1-(2-3)\". Use \"foldl\" or \"foldr\"\n   instead for guaranteed left or right associativity.\n\n   Some operations accumulate error, and parallelism will also be\n   easier if the reduction can be executed in groups. Future versions\n   of Julia might change the algorithm. Note that the elements are not\n   reordered if you use an ordered collection.\n\nBase.reduce(op, itr)\n\n   Like \"reduce\" but using the first element as v0.\n",
        "methods": 
        [
          "reduce(f::Function,d::DArray{T,N,A}) at darray.jl:303",
          "reduce(f::Function,S::SharedArray{T,N}) at sharedarray.jl:275",
          "reduce(op::Union(DataType,Function),A::AbstractArray{T,N}) at reduce.jl:123",
          "reduce(op::Union(DataType,Function),v0,A::AbstractArray{T,N}) at reduce.jl:128",
          "reduce(op::Union(DataType,Function),v,itr) at reduce.jl:93",
          "reduce(op::Union(DataType,Function),itr) at reduce.jl:96"
        ]
      },
      {
        "name": "reducedim",
        "summary": "Function",
        "help": "Base.reducedim(f, A, dims, initial)\n\n   Reduce 2-argument function \"f\" along dimensions of \"A\".\n   \"dims\" is a vector specifying the dimensions to reduce, and\n   \"initial\" is the initial value to use in the reductions.\n\n   The associativity of the reduction is implementation-dependent; if\n   you need a particular associativity, e.g. left-to-right, you should\n   write your own loop. See documentation for \"reduce\".\n",
        "methods": 
        [
          "reducedim{Tv,Ti}(f::Function,A::SparseMatrixCSC{Tv,Ti},region,v0) at sparse/sparsematrix.jl:641",
          "reducedim(f::Function,A,region,initial) at reducedim.jl:49",
          "reducedim(f::Function,A,region,initial,R) at reducedim.jl:51"
        ]
      },
      {
        "name": "reenable_sigint",
        "summary": "Function",
        "help": "Base.reenable_sigint(f::Function)\n\n   Re-enable Ctrl-C handler during execution of a function.\n   Temporarily reverses the effect of \"disable_sigint\".\n",
        "methods": 
        [
          "reenable_sigint(f::Function) at c.jl:75"
        ]
      },
      {
        "name": "ref",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "getindex(T::(Type{T<:Top}...,)) at array.jl:126",
          "getindex(t::(Any...,),i::Int64) at tuple.jl:6",
          "getindex(t::(Any...,),i::Real) at tuple.jl:7",
          "getindex(t::(Any...,),b::AbstractArray{Bool,N}) at tuple.jl:9",
          "getindex(t::(Any...,),r::AbstractArray{T,N}) at tuple.jl:8",
          "getindex{T}(r::FloatRange{T},i::Integer) at range.jl:239",
          "getindex(r::CalendarTimeRange{T<:AbstractCalendarDuration},i::Integer) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:397",
          "getindex{T}(r::Range{T},i::Integer) at range.jl:235",
          "getindex(r::Range{T},i::Real) at range.jl:232",
          "getindex(r::UnitRange{T<:Real},s::UnitRange{Int64}) at range.jl:244",
          "getindex(r::StepRange{T,S},s::Range{Int64}) at range.jl:257",
          "getindex(r::FloatRange{T<:FloatingPoint},s::UnitRange{T<:Real}) at range.jl:269",
          "getindex(x::Number) at number.jl:14",
          "getindex(x::Number,i::Integer) at number.jl:15",
          "getindex(x::Number,I::Integer...) at number.jl:16",
          "getindex(x::Number,I::Real...) at number.jl:17",
          "getindex{T}(s::SubArray{T,0,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)}) at subarray.jl:191",
          "getindex{T}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer) at subarray.jl:193",
          "getindex{T}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer,j::Integer) at subarray.jl:195",
          "getindex{T}(s::SubArray{T,2,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer,j::Integer) at subarray.jl:197",
          "getindex{T}(s::SubArray{T,3,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer,j::Integer,k::Integer) at subarray.jl:199",
          "getindex{T}(s::SubArray{T,4,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer,j::Integer,k::Integer,l::Integer) at subarray.jl:201",
          "getindex{T}(s::SubArray{T,5,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer,j::Integer,k::Integer,l::Integer,m::Integer) at subarray.jl:203",
          "getindex{T}(s::SubArray{T,2,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},ind::Integer) at multidimensional.jl:104",
          "getindex{T}(s::SubArray{T,3,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},ind::Integer) at multidimensional.jl:104",
          "getindex{T}(s::SubArray{T,4,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},ind::Integer) at multidimensional.jl:104",
          "getindex{T}(s::SubArray{T,5,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},ind::Integer) at multidimensional.jl:104",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer) at subarray.jl:220",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},is::Integer...) at subarray.jl:223",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Real) at subarray.jl:206",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i0::Real,i1::Real) at subarray.jl:207",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i0::Real,i1::Real,i2::Real) at subarray.jl:209",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i0::Real,i1::Real,i2::Real,i3::Real) at subarray.jl:211",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i0::Real,i1::Real,i2::Real,i3::Real,i4::Real) at subarray.jl:213",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i0::Real,i1::Real,i2::Real,i3::Real,i4::Real,i5::Real) at subarray.jl:215",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i0::Real,i1::Real,i2::Real,i3::Real,i4::Real,i5::Real,is::Real...) at subarray.jl:217",
          "getindex(A::Array{T,1},I::AbstractArray{Bool,1}) at array.jl:298",
          "getindex(A::Array{T,1},I::AbstractArray{Bool,N}) at array.jl:299",
          "getindex(a::Array{T,N}) at array.jl:244",
          "getindex(A::Array{T,N},i0::Real) at array.jl:246",
          "getindex(A::Array{T,N},i0::Real,i1::Real) at array.jl:247",
          "getindex(A::Array{T,N},i0::Real,i1::Real,i2::Real) at array.jl:248",
          "getindex(A::Array{T,N},i0::Real,i1::Real,i2::Real,i3::Real) at array.jl:250",
          "getindex(A::Array{T,N},i0::Real,i1::Real,i2::Real,i3::Real,i4::Real) at array.jl:252",
          "getindex(A::Array{T,N},i0::Real,i1::Real,i2::Real,i3::Real,i4::Real,i5::Real) at array.jl:254",
          "getindex(A::Array{T,N},i0::Real,i1::Real,i2::Real,i3::Real,i4::Real,i5::Real,I::Real...) at array.jl:257",
          "getindex(B::BitArray{0}) at bitarray.jl:358",
          "getindex(B::BitArray{N},i::Int64) at bitarray.jl:349",
          "getindex(B::BitArray{N},I_0::Int64,I_1::Int64) at multidimensional.jl:178",
          "getindex(B::BitArray{N},I_0::Int64,I_1::Int64,I_2::Int64) at multidimensional.jl:178",
          "getindex(B::BitArray{N},I_0::Int64,I_1::Int64,I_2::Int64,I_3::Int64) at multidimensional.jl:178",
          "getindex(B::BitArray{N},I_0::Int64,I_1::Int64,I_2::Int64,I_3::Int64,I_4::Int64) at multidimensional.jl:178",
          "getindex(B::BitArray{N},I_0::Int64,I::Int64...) at cartesian.jl:100",
          "getindex(B::BitArray{N},i::Real) at bitarray.jl:353",
          "getindex(B::BitArray{N}) at bitarray.jl:355",
          "getindex(d::DArray{T,N,A},i::Int64) at darray.jl:234",
          "getindex(d::DArray{T,N,A}) at darray.jl:245",
          "getindex(d::DArray{T,N,A},i::Int64...) at darray.jl:235",
          "getindex(d::DArray{T,N,A},I::Union(UnitRange{Int64},Int64)...) at darray.jl:246",
          "getindex(S::SharedArray{T,N}) at sharedarray.jl:209",
          "getindex(S::SharedArray{T,N},I::Real) at sharedarray.jl:210",
          "getindex(A::SparseMatrixCSC{Tv,Ti<:Integer},i::Integer) at sparse/sparsematrix.jl:715",
          "getindex{T}(A::SparseMatrixCSC{T,Ti<:Integer},i0::Integer,i1::Integer) at sparse/sparsematrix.jl:718",
          "getindex(A::SparseMatrixCSC{Tv,Ti<:Integer},I::Integer,J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1026",
          "getindex{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},i::Integer,J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:736",
          "getindex{T}(A::SymTridiagonal{T},i::Integer,j::Integer) at linalg/tridiag.jl:138",
          "getindex{T}(A::Tridiagonal{T},i::Integer,j::Integer) at linalg/tridiag.jl:197",
          "getindex{T}(A::Triangular{T},i::Integer,j::Integer) at linalg/triangular.jl:93",
          "getindex(A::Symmetric{T},i::Integer,j::Integer) at linalg/symmetric.jl:16",
          "getindex(A::Hermitian{T},i::Integer,j::Integer) at linalg/symmetric.jl:17",
          "getindex(D::Diagonal{T},i::Integer,j::Integer) at linalg/diagonal.jl:23",
          "getindex(D::Diagonal{T},i::Integer) at linalg/diagonal.jl:26",
          "getindex{T}(A::Bidiagonal{T},i::Integer,j::Integer) at linalg/bidiag.jl:25",
          "getindex(G::Givens{T},i::Integer,j::Integer) at linalg/givens.jl:204",
          "getindex(t::AbstractArray{T,N},i::Real) at abstractarray.jl:360",
          "getindex{T}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::UnitRange{Int64}) at subarray.jl:252",
          "getindex{T}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::Range{Int64}) at subarray.jl:255",
          "getindex{T}(S::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::AbstractArray{Bool,1}) at subarray.jl:246",
          "getindex{T}(S::SubArray{T,2,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::AbstractArray{Bool,2}) at subarray.jl:247",
          "getindex{T}(S::SubArray{T,3,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::AbstractArray{Bool,3}) at subarray.jl:248",
          "getindex{T}(S::SubArray{T,4,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::AbstractArray{Bool,4}) at subarray.jl:249",
          "getindex{T}(S::SubArray{T,5,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::AbstractArray{Bool,5}) at subarray.jl:250",
          "getindex{T,S<:Integer}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::AbstractArray{S<:Integer,1}) at subarray.jl:259",
          "getindex(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},I::Union(AbstractArray{T,1},Real)...) at subarray.jl:334",
          "getindex(A::Array{T,N},I::UnitRange{Int64}) at array.jl:262",
          "getindex(A::Array{T,N},I::AbstractArray{Bool,1}) at array.jl:300",
          "getindex{T<:Real}(A::Array{T,N},I::AbstractArray{T<:Real,1}) at array.jl:271",
          "getindex(A::Range{T},I::AbstractArray{Bool,1}) at array.jl:277",
          "getindex{T<:Real}(A::Range{T},I::AbstractArray{T<:Real,1}) at array.jl:274",
          "getindex(A::Array{T,N},I::AbstractArray{Bool,N}) at array.jl:301",
          "getindex(B::BitArray{N},I0::UnitRange{Int64}) at multidimensional.jl:199",
          "getindex{T<:Real}(B::BitArray{N},I0::UnitRange{T<:Real}) at multidimensional.jl:203",
          "getindex(B::BitArray{N},I::AbstractArray{Bool,1}) at bitarray.jl:381",
          "getindex{T<:Real}(B::BitArray{N},I::AbstractArray{T<:Real,1}) at bitarray.jl:361",
          "getindex(B::BitArray{N},I::AbstractArray{Bool,N}) at bitarray.jl:381",
          "getindex(A::Array{T,N},I_1::Union(AbstractArray{T,1},Real)) at multidimensional.jl:49",
          "getindex(A::Array{T,N},I_1::Union(AbstractArray{T,1},Real),I_2::Union(AbstractArray{T,1},Real)) at multidimensional.jl:49",
          "getindex(A::Array{T,N},I_1::Union(AbstractArray{T,1},Real),I_2::Union(AbstractArray{T,1},Real),I_3::Union(AbstractArray{T,1},Real)) at multidimensional.jl:49",
          "getindex(A::Array{T,N},I_1::Union(AbstractArray{T,1},Real),I_2::Union(AbstractArray{T,1},Real),I_3::Union(AbstractArray{T,1},Real),I_4::Union(AbstractArray{T,1},Real)) at multidimensional.jl:49",
          "getindex(A::Array{T,N},I::Union(AbstractArray{T,1},Real)...) at multidimensional.jl:49",
          "getindex(B::BitArray{N},I_1::Union(AbstractArray{T,1},Real)) at multidimensional.jl:250",
          "getindex(B::BitArray{N},I_1::Union(AbstractArray{T,1},Real),I_2::Union(AbstractArray{T,1},Real)) at multidimensional.jl:250",
          "getindex(B::BitArray{N},I_1::Union(AbstractArray{T,1},Real),I_2::Union(AbstractArray{T,1},Real),I_3::Union(AbstractArray{T,1},Real)) at multidimensional.jl:250",
          "getindex(B::BitArray{N},I_1::Union(AbstractArray{T,1},Real),I_2::Union(AbstractArray{T,1},Real),I_3::Union(AbstractArray{T,1},Real),I_4::Union(AbstractArray{T,1},Real)) at multidimensional.jl:250",
          "getindex(B::BitArray{N},I::Union(AbstractArray{T,1},Real)...) at cartesian.jl:100",
          "getindex(S::SharedArray{T,N},I::AbstractArray{T,N}) at sharedarray.jl:211",
          "getindex(A::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{Bool,1},J::Integer) at sparse/sparsematrix.jl:1027",
          "getindex{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{T<:Integer,1},j::Integer) at sparse/sparsematrix.jl:735",
          "getindex(A::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{Bool,1},J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1028",
          "getindex{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{T<:Integer,1},J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1029",
          "getindex{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{Bool,1},J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1030",
          "getindex{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti},I::AbstractArray{T,1},J::AbstractArray{T,1}) at sparse/sparsematrix.jl:1001",
          "getindex(A::AbstractArray{T,N},I::AbstractArray{T,N}) at abstractarray.jl:364",
          "getindex(S::SharedArray{T,N},I_1) at sharedarray.jl:212",
          "getindex(S::SharedArray{T,N},I_1,I_2) at sharedarray.jl:212",
          "getindex(S::SharedArray{T,N},I_1,I_2,I_3) at sharedarray.jl:212",
          "getindex(S::SharedArray{T,N},I_1,I_2,I_3,I_4) at sharedarray.jl:212",
          "getindex(S::SharedArray{T,N},I_1,I_2,I_3,I_4,I_5) at sharedarray.jl:212",
          "getindex(S::SharedArray{T,N},I...) at sharedarray.jl:212",
          "getindex(A::AbstractArray{T,1},i1,i2,i3...) at abstractarray.jl:435",
          "getindex(A::AbstractArray{T,2},i1,i2,i3,i4...) at abstractarray.jl:441",
          "getindex{T<:Number}(::Type{T<:Number},r::Range{T}) at array.jl:130",
          "getindex{T<:Number}(::Type{T<:Number},r1::Range{T},rs::Range{T}...) at array.jl:134",
          "getindex(T::Union(DataType,TypeConstructor,UnionType),vals...) at array.jl:119",
          "getindex{K,V}(h::Dict{K,V},key) at dict.jl:513",
          "getindex{K}(wkh::WeakKeyDict{K,V},key) at dict.jl:646",
          "getindex(::EnvHash,k::String) at env.jl:75",
          "getindex{K,V}(pq::PriorityQueue{K,V},key) at collections.jl:208",
          "getindex{K,V}(h::HashDict{K,V,O<:Union(Nothing,Int64)},key) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:411",
          "getindex(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "getindex{K,V,F<:Union(DataType,Function)}(d::DefaultDictBase{K,V,F<:Union(DataType,Function),Dict{K,V}},key) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:63",
          "getindex{K,V,F}(d::DefaultDictBase{K,V,F,Dict{K,V}},key) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:70",
          "getindex(d::DefaultDictBase{K,V,F,D<:Associative{K,V}},key) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:57",
          "getindex(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "getindex(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "getindex(t::Associative{K,V},key) at dict.jl:128",
          "getindex(t::Associative{K,V},k1,k2,ks...) at dict.jl:137",
          "getindex(x::StateUpdate,s::Symbol) at inference.jl:1058",
          "getindex(s::ASCIIString,i::Int64) at ascii.jl:11",
          "getindex(s::ASCIIString,r::Array{T,1}) at ascii.jl:17",
          "getindex(s::ASCIIString,r::UnitRange{Int64}) at ascii.jl:18",
          "getindex(s::ASCIIString,indx::AbstractArray{Int64,1}) at ascii.jl:19",
          "getindex(s::UTF8String,i::Int64) at utf8.jl:54",
          "getindex(s::UTF8String,r::UnitRange{Int64}) at utf8.jl:101",
          "getindex(s::SubString{T<:String},i::Int64) at string.jl:635",
          "getindex(s::String,i::Int64) at string.jl:57",
          "getindex(s::String,i::Integer) at string.jl:58",
          "getindex(s::String,x::Real) at string.jl:59",
          "getindex(s::String,r::UnitRange{Int64}) at string.jl:660",
          "getindex{T<:Integer}(s::String,r::UnitRange{T<:Integer}) at string.jl:60",
          "getindex(s::String,v::AbstractArray{T,1}) at string.jl:62",
          "getindex(r::RemoteRef,args...) at darray.jl:227",
          "getindex(a::ZeroOffsetVector,i) at linalg/tridiag.jl:83",
          "getindex(C::Cholesky{T},d::Symbol) at linalg/factorization.jl:63",
          "getindex{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(C::CholeskyPivoted{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},d::Symbol) at linalg/factorization.jl:69",
          "getindex(A::QR{T},d::Symbol) at linalg/factorization.jl:194",
          "getindex(A::QRCompactWY{S},d::Symbol) at linalg/factorization.jl:199",
          "getindex{T}(A::QRPivoted{T},d::Symbol) at linalg/factorization.jl:204",
          "getindex(A::Hessenberg{T},d::Symbol) at linalg/factorization.jl:489",
          "getindex(A::Union(Eigen{T,V},GeneralizedEigen{T,V}),d::Symbol) at linalg/factorization.jl:517",
          "getindex(F::SVD{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Tr},d::Symbol) at linalg/factorization.jl:657",
          "getindex{T}(obj::GeneralizedSVD{T},d::Symbol) at linalg/factorization.jl:702",
          "getindex(F::Schur{Ty<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},d::Symbol) at linalg/factorization.jl:751",
          "getindex(F::GeneralizedSchur{Ty<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},d::Symbol) at linalg/factorization.jl:776",
          "getindex{T,S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})}(A::LU{T,S<:Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})},d::Symbol) at linalg/lu.jl:95",
          "getindex(J::UniformScaling{T<:Number},i::Integer,j::Integer) at linalg/uniformscaling.jl:12",
          "getindex(lu::UmfpackLU{Tv<:Union(Float64,Complex{Float64}),Ti<:Union(Int64,Int32)},d::Symbol) at linalg/umfpack.jl:330",
          "getindex{T,V}(ct::Accumulator{T,V},x::T) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:29",
          "getindex{T,C}(cc::ClassifiedCollections{T,C},x::T) at /home/samuel/.julia/v0.3/DataStructures/src/classifiedcollections.jl:29",
          "getindex(t::Trie{T},key::String) at /home/samuel/.julia/v0.3/DataStructures/src/trie.jl:29",
          "getindex(dn::DistinguishedName,irdn::Integer,iava::Integer) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:233"
        ]
      },
      {
        "name": "ref_shape",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "ref_shape(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "reim",
        "summary": "Function",
        "help": "Base.reim(z)\n\n   Return both the real and imaginary parts of the complex number\n   \"z\"\n",
        "methods": 
        [
          "reim(z) at complex.jl:35"
        ]
      },
      {
        "name": "reinterpret",
        "summary": "Function",
        "help": "Base.reinterpret(type, A)\n\n   Change the type-interpretation of a block of memory. For example,\n   \"reinterpret(Float32, uint32(7))\" interprets the 4 bytes\n   corresponding to \"uint32(7)\" as a \"Float32\". For arrays, this\n   constructs an array with the same binary data as the given array,\n   but with the specified element type.\n",
        "methods": 
        [
          "reinterpret{T<:Real}(::Type{T<:Real},x::Real) at number.jl:42",
          "reinterpret{T,S}(::Type{T},a::Array{S,1}) at array.jl:60",
          "reinterpret{T,S}(::Type{T},a::Array{S,N}) at array.jl:65",
          "reinterpret{T,S,N}(::Type{T},a::Array{S,N},dims::NTuple{N,Int64}) at array.jl:72",
          "reinterpret{N}(::Type{Bool},B::BitArray{N},dims::NTuple{N,Int64}) at bitarray.jl:325",
          "reinterpret{T,Tv,Ti}(::Type{T},a::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:52",
          "reinterpret{T,Tv,Ti,N}(::Type{T},a::SparseMatrixCSC{Tv,Ti},dims::NTuple{N,Int64}) at sparse/sparsematrix.jl:91",
          "reinterpret(t::Type{T<:Top},x) at array.jl:84",
          "reinterpret{N}(B::BitArray{N},dims::NTuple{N,Int64}) at bitarray.jl:326"
        ]
      },
      {
        "name": "reload",
        "summary": "Function",
        "help": "Base.reload(file::String)\n\n   Like \"require\", except forces loading of files regardless of\n   whether they have been loaded before. Typically used when\n   interactively developing libraries.\n",
        "methods": 
        [
          "reload(name::String) at loading.jl:75"
        ]
      },
      {
        "name": "rem",
        "summary": "Function",
        "help": "Base.rem(x, m)\n\n   Remainder after division\n",
        "methods": 
        [
          "rem(x::Bool,y::Bool) at bool.jl:59",
          "rem(x::Signed,y::Unsigned) at int.jl:82",
          "rem(x::Unsigned,y::Signed) at int.jl:83",
          "rem{T<:Union(Int8,Int64,Int16,Int32)}(x::T<:Union(Int8,Int64,Int16,Int32),y::T<:Union(Int8,Int64,Int16,Int32)) at int.jl:99",
          "rem{T<:Union(Uint16,Uint8,Uint32,Uint64)}(x::T<:Union(Uint16,Uint8,Uint32,Uint64),y::T<:Union(Uint16,Uint8,Uint32,Uint64)) at int.jl:100",
          "rem(x::Int128,y::Int128) at int.jl:595",
          "rem(x::Uint128,y::Uint128) at int.jl:596",
          "rem(x::Float32,y::Float32) at float.jl:137",
          "rem(x::Float64,y::Float64) at float.jl:138",
          "rem(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:113",
          "rem(x::BigInt,y::BigInt) at gmp.jl:193",
          "rem(x::BigFloat,y::BigFloat) at mpfr.jl:527",
          "rem(x::Real,y::Real) at promotion.jl:174",
          "rem{T}(A::Number,B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:754",
          "rem{T}(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Number) at array.jl:761"
        ]
      },
      {
        "name": "rem1",
        "summary": "Function",
        "help": "Base.rem1(x, m)\n\n   Remainder after division, returning in the range (0,m]\n",
        "methods": 
        [
          "rem1{T<:Real}(x::T<:Real,y::T<:Real) at operators.jl:130",
          "rem1(x::Real,y::Real) at promotion.jl:178"
        ]
      },
      {
        "name": "remote_call",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "remote_call(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "remote_call_fetch",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "remote_call_fetch(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "remote_call_wait",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "remote_call_wait(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "remotecall",
        "summary": "Function",
        "help": "Base.remotecall(id, func, args...)\n\n   Call a function asynchronously on the given arguments on the\n   specified process. Returns a \"RemoteRef\".\n",
        "methods": 
        [
          "remotecall(w::LocalProcess,f,args...) at multi.jl:670",
          "remotecall(w::Worker,f,args...) at multi.jl:676",
          "remotecall(id::Integer,f,args...) at multi.jl:682"
        ]
      },
      {
        "name": "remotecall_fetch",
        "summary": "Function",
        "help": "Base.remotecall_fetch(id, func, args...)\n\n   Perform \"fetch(remotecall(...))\" in one message.\n",
        "methods": 
        [
          "remotecall_fetch(w::LocalProcess,f,args...) at multi.jl:686",
          "remotecall_fetch(w::Worker,f,args...) at multi.jl:692",
          "remotecall_fetch(id::Integer,f,args...) at multi.jl:701"
        ]
      },
      {
        "name": "remotecall_wait",
        "summary": "Function",
        "help": "Base.remotecall_wait(id, func, args...)\n\n   Perform \"wait(remotecall(...))\" in one message.\n",
        "methods": 
        [
          "remotecall_wait(w::LocalProcess,f,args...) at multi.jl:705",
          "remotecall_wait(w::Worker,f,args...) at multi.jl:708",
          "remotecall_wait(id::Integer,f,args...) at multi.jl:718"
        ]
      },
      {
        "name": "repeat",
        "summary": "Function",
        "help": "Base.repeat(A, inner = Int[], outer = Int[])\n\n   Construct an array by repeating the entries of \"A\". The i-th\n   element of \"inner\" specifies the number of times that the\n   individual entries of the i-th dimension of \"A\" should be\n   repeated. The i-th element of \"outer\" specifies the number of\n   times that a slice along the i-th dimension of \"A\" should be\n   repeated.\n",
        "methods": 
        [
          "repeat{T}(A::Array{T,N}) at abstractarray.jl:1077",
          "repeat(s::Union(UTF8String,ASCIIString),r::Integer) at string.jl:715",
          "repeat(s::String,r::Integer) at string.jl:706"
        ]
      },
      {
        "name": "repl_show",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "repl_show(io,x) at deprecated.jl:26"
        ]
      },
      {
        "name": "replace",
        "summary": "Function",
        "help": "Base.replace(string, pat, r[, n])\n\n   Search for the given pattern \"pat\", and replace each occurrence\n   with \"r\". If \"n\" is provided, replace at most \"n\"\n   occurrences.  As with search, the second argument may be a single\n   character, a vector or a set of characters, a string, or a regular\n   expression. If \"r\" is a function, each occurrence is replaced\n   with \"r(s)\" where \"s\" is the matched substring.\n",
        "methods": 
        [
          "replace(str::Union(UTF8String,ASCIIString),pattern,repl::Function,limit::Integer) at string.jl:1337",
          "replace(s::String,pat,f::Function,n::Integer) at string.jl:1365",
          "replace(s::String,pat,r,n::Integer) at string.jl:1366",
          "replace(s::String,pat,r) at string.jl:1367"
        ]
      },
      {
        "name": "repmat",
        "summary": "Function",
        "help": "Base.repmat(A, n, m)\n\n   Construct a matrix by repeating the given matrix \"n\" times in\n   dimension 1 and \"m\" times in dimension 2.\n",
        "methods": 
        [
          "repmat(a::AbstractArray{T,1},m::Int64) at abstractarray.jl:972",
          "repmat(a::Union(AbstractArray{T,2},AbstractArray{T,1}),m::Int64) at abstractarray.jl:958",
          "repmat(a::Union(AbstractArray{T,2},AbstractArray{T,1}),m::Int64,n::Int64) at abstractarray.jl:958"
        ]
      },
      {
        "name": "repr",
        "summary": "Function",
        "help": "Base.repr(x)\n\n   Create a string from any value using the \"showall\" function.\n",
        "methods": 
        [
          "repr(u::UUID) at random.jl:280",
          "repr(x) at string.jl:1677"
        ]
      },
      {
        "name": "reprmime",
        "summary": "Function",
        "help": "Base.reprmime(mime, x)\n\n   Returns a \"String\" or \"Vector{Uint8}\" containing the\n   representation of \"x\" in the requested \"mime\" type, as written\n   by \"writemime\" (throwing a \"MethodError\" if no appropriate\n   \"writemime\" is available).  A \"String\" is returned for MIME\n   types with textual representations (such as \"\"text/html\"\" or\n   \"\"application/postscript\"\"), whereas binary data is returned as\n   \"Vector{Uint8}\".  (The function \"istext(mime)\" returns whether\n   or not Julia treats a given \"mime\" type as text.)\n\n   As a special case, if \"x\" is a \"String\" (for textual MIME\n   types) or a \"Vector{Uint8}\" (for binary MIME types), the\n   \"reprmime\" function assumes that \"x\" is already in the\n   requested \"mime\" format and simply returns \"x\".\n",
        "methods": 
        [
          "reprmime(::MIME{:text/vnd.graphviz},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/latex},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/calendar},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/n3},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/richtext},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/x-setext},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/sgml},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/tab-separated-values},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/x-vcalendar},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/x-vcard},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/cmd},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/css},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/csv},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/html},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/javascript},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/markdown},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/plain},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/vcard},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:text/xml},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:application/atom+xml},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:application/ecmascript},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:application/json},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:application/rdf+xml},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:application/rss+xml},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:application/xml-dtd},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:application/postscript},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:image/svg+xml},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:application/x-latex},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:application/xhtml+xml},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:application/javascript},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:application/xml},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:model/x3d+xml},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:model/x3d+vrml},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(::MIME{:model/vrml},::Array{Uint8,1}) at multimedia.jl:63",
          "reprmime(m::MIME{mime},x::Array{Uint8,1}) at multimedia.jl:81",
          "reprmime(::MIME{:text/vnd.graphviz},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/vnd.graphviz},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/latex},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/latex},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/calendar},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/calendar},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/n3},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/n3},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/richtext},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/richtext},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/x-setext},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/x-setext},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/sgml},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/sgml},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/tab-separated-values},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/tab-separated-values},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/x-vcalendar},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/x-vcalendar},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/x-vcard},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/x-vcard},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/cmd},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/cmd},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/css},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/css},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/csv},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/csv},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/html},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/html},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/javascript},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/javascript},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/markdown},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/markdown},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/plain},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/vcard},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/vcard},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:text/xml},::String) at multimedia.jl:68",
          "reprmime(::MIME{:text/xml},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:application/atom+xml},::String) at multimedia.jl:68",
          "reprmime(::MIME{:application/atom+xml},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:application/ecmascript},::String) at multimedia.jl:68",
          "reprmime(::MIME{:application/ecmascript},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:application/json},::String) at multimedia.jl:68",
          "reprmime(::MIME{:application/json},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:application/rdf+xml},::String) at multimedia.jl:68",
          "reprmime(::MIME{:application/rdf+xml},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:application/rss+xml},::String) at multimedia.jl:68",
          "reprmime(::MIME{:application/rss+xml},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:application/xml-dtd},::String) at multimedia.jl:68",
          "reprmime(::MIME{:application/xml-dtd},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:application/postscript},::String) at multimedia.jl:68",
          "reprmime(::MIME{:application/postscript},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:image/svg+xml},::String) at multimedia.jl:68",
          "reprmime(::MIME{:image/svg+xml},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:application/x-latex},::String) at multimedia.jl:68",
          "reprmime(::MIME{:application/x-latex},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:application/xhtml+xml},::String) at multimedia.jl:68",
          "reprmime(::MIME{:application/xhtml+xml},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:application/javascript},::String) at multimedia.jl:68",
          "reprmime(::MIME{:application/javascript},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:application/xml},::String) at multimedia.jl:68",
          "reprmime(::MIME{:application/xml},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:model/x3d+xml},::String) at multimedia.jl:68",
          "reprmime(::MIME{:model/x3d+xml},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:model/x3d+vrml},::String) at multimedia.jl:68",
          "reprmime(::MIME{:model/x3d+vrml},::Any) at multimedia.jl:70",
          "reprmime(::MIME{:model/vrml},::String) at multimedia.jl:68",
          "reprmime(::MIME{:model/vrml},::Any) at multimedia.jl:70",
          "reprmime(m::MIME{mime},x) at multimedia.jl:77",
          "reprmime(m::String,x) at multimedia.jl:87"
        ]
      },
      {
        "name": "require",
        "summary": "Function",
        "help": "Base.require(file::String...)\n\n   Load source files once, in the context of the \"Main\" module, on\n   every active node, searching the system-wide \"LOAD_PATH\" for\n   files. \"require\" is considered a top-level operation, so it sets\n   the current \"include\" path but does not use it to search for\n   files (see help for \"include\"). This function is typically used\n   to load library code, and is implicitly called by \"using\" to load\n   packages.\n",
        "methods": 
        [
          "require(name::String) at loading.jl:46",
          "require(f::String,fs::String...) at loading.jl:40"
        ]
      },
      {
        "name": "reshape",
        "summary": "Function",
        "help": "Base.reshape(A, dims)\n\n   Create an array with the same data as the given array, but with\n   different dimensions. An implementation for a particular type of\n   array may choose whether the data is copied or shared.\n",
        "methods": 
        [
          "reshape{T,N}(a::Array{T,N},dims::NTuple{N,Int64}) at array.jl:88",
          "reshape{T,N}(a::Array{T,N},dims::NTuple{N,Int64}) at array.jl:99",
          "reshape{N}(B::BitArray{N},dims::NTuple{N,Int64}) at bitarray.jl:270",
          "reshape{T,S<:Array{T,N}}(A::DArray{T,1,S<:Array{T,N}},d::(Int64...,)) at darray.jl:200",
          "reshape{T,N}(a::SharedArray{T,N},dims::NTuple{N,Int64}) at sharedarray.jl:118",
          "reshape{Tv,Ti}(a::SparseMatrixCSC{Tv,Ti},dims::(Int64,Int64)) at sparse/sparsematrix.jl:110",
          "reshape(a::AbstractArray{T,N},dims::(Int64...,)) at abstractarray.jl:122",
          "reshape(a::AbstractArray{T,N},dims::Int64...) at abstractarray.jl:127"
        ]
      },
      {
        "name": "resize!",
        "summary": "Function",
        "help": "Base.resize!(collection, n) -> collection\n\n   Resize collection to contain \"n\" elements.\n",
        "methods": 
        [
          "resize!(a::Array{T,1},nl::Integer) at array.jl:494",
          "resize!(B::BitArray{1},n::Integer) at bitarray.jl:519"
        ]
      },
      {
        "name": "rethrow",
        "summary": "Function",
        "help": "Base.rethrow([e])\n\n   Throw an object without changing the current exception backtrace.\n   The default argument is the current exception (if called within a\n   \"catch\" block).\n",
        "methods": 
        [
          "rethrow() at error.jl:28",
          "rethrow(e) at error.jl:29"
        ]
      },
      {
        "name": "reverse",
        "summary": "Function",
        "help": "Base.reverse(v[, start=1[, stop=length(v)]])\n\n   Return a copy of \"v\" reversed from start to stop.\n",
        "methods": 
        [
          "reverse(t::(Any...,)) at tuple.jl:112",
          "reverse(r::OrdinalRange{T,S}) at range.jl:488",
          "reverse(r::FloatRange{T<:FloatingPoint}) at range.jl:489",
          "reverse(v::BitArray{1}) at bitarray.jl:1193",
          "reverse(v::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at array.jl:976",
          "reverse(v::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1}),s) at array.jl:977",
          "reverse(v::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1}),s,n) at array.jl:977",
          "reverse(A::AbstractArray{T,1}) at array.jl:963",
          "reverse(A::AbstractArray{T,1},s) at array.jl:963",
          "reverse(A::AbstractArray{T,1},s,n) at array.jl:963",
          "reverse(s::ASCIIString) at ascii.jl:89",
          "reverse(s::UTF8String) at utf8.jl:146",
          "reverse(s::UTF32String) at string.jl:585",
          "reverse(s::RevString{T<:String}) at string.jl:742",
          "reverse(s::String) at string.jl:741",
          "reverse{T}(l::LinkedList{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:87"
        ]
      },
      {
        "name": "reverse!",
        "summary": "Function",
        "help": "Base.reverse!(v[, start=1[, stop=length(v)]]) -> v\n\n   In-place version of \"reverse()\".\n",
        "methods": 
        [
          "reverse!(B::BitArray{1}) at bitarray.jl:1163",
          "reverse!(v::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at array.jl:979",
          "reverse!(v::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1}),s) at array.jl:979",
          "reverse!(v::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1}),s,n) at array.jl:979"
        ]
      },
      {
        "name": "rfft",
        "summary": "Function",
        "help": "Base.rfft(A[, dims])\n\n   Multidimensional FFT of a real array A, exploiting the fact that\n   the transform has conjugate symmetry in order to save roughly half\n   the computational time and storage costs compared with \"fft()\".\n   If \"A\" has size \"(n_1, ..., n_d)\", the result has size\n   \"(floor(n_1/2)+1, ..., n_d)\".\n\n   The optional \"dims\" argument specifies an iterable subset of one\n   or more dimensions of \"A\" to transform, similar to \"fft()\".\n   Instead of (roughly) halving the first dimension of \"A\" in the\n   result, the \"dims[1]\" dimension is (roughly) halved in the same\n   way.\n",
        "methods": 
        [
          "rfft(X::Union(SubArray{Float32,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Float32,N}),region) at fftw.jl:529",
          "rfft(X::Union(SubArray{Float64,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{Float64,N}),region) at fftw.jl:529",
          "rfft{T<:Real}(X::Union(DenseArray{T<:Real,N},SubArray{T<:Real,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),region) at fftw.jl:540",
          "rfft(X::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at fftw.jl:636",
          "rfft(x::Real) at fftw.jl:684",
          "rfft(x::Real,dims) at fftw.jl:691"
        ]
      },
      {
        "name": "rm",
        "summary": "Function",
        "help": "Base.rm(path::String)\n\n   Delete the file at the given path. Note that this does not work on\n   directories.\n\nBase.Pkg.rm(pkg)\n\n   Remove all requirement entries for \"pkg\" from\n   \"Pkg.dir(\"REQUIRE\")\" and call \"Pkg.resolve()\".\n",
        "methods": 
        [
          "rm(path::String) at file.jl:62"
        ]
      },
      {
        "name": "rmdir",
        "summary": "Function",
        "help": "Base.rmdir(path)\n\n   Remove the directory named \"path\".\n",
        "methods": 
        [
          "rmdir(path::String) at file.jl:55"
        ]
      },
      {
        "name": "rmprocs",
        "summary": "Function",
        "help": "Base.rmprocs(pids...)\n\n   Removes the specified workers.\n",
        "methods": 
        [
          "rmprocs(args...) at multi.jl:297"
        ]
      },
      {
        "name": "rol",
        "summary": "Function",
        "help": "Base.rol(B::BitArray{1}, i::Integer) -> BitArray{1}\n\n   Left rotation operator.\n",
        "methods": 
        [
          "rol(B::BitArray{1},i::Integer) at bitarray.jl:1219"
        ]
      },
      {
        "name": "ror",
        "summary": "Function",
        "help": "Base.ror(B::BitArray{1}, i::Integer) -> BitArray{1}\n\n   Right rotation operator.\n",
        "methods": 
        [
          "ror(B::BitArray{1},i::Integer) at bitarray.jl:1230"
        ]
      },
      {
        "name": "rot180",
        "summary": "Function",
        "help": "Base.rot180(A)\n\n   Rotate matrix \"A\" 180 degrees.\n",
        "methods": 
        [
          "rot180(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at array.jl:945",
          "rot180(A::AbstractArray{T,2},k::Integer) at array.jl:959"
        ]
      },
      {
        "name": "rotl90",
        "summary": "Function",
        "help": "Base.rotl90(A)\n\n   Rotate matrix \"A\" left 90 degrees.\n",
        "methods": 
        [
          "rotl90(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at array.jl:929",
          "rotl90(A::AbstractArray{T,2},k::Integer) at array.jl:953"
        ]
      },
      {
        "name": "rotr90",
        "summary": "Function",
        "help": "Base.rotr90(A)\n\n   Rotate matrix \"A\" right 90 degrees.\n",
        "methods": 
        [
          "rotr90(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at array.jl:937",
          "rotr90(A::AbstractArray{T,2},k::Integer) at array.jl:958"
        ]
      },
      {
        "name": "round",
        "summary": "Function",
        "help": "Base.round(x[, digits[, base]])\n\n   \"round(x)\" returns the nearest integral value of the same type as\n   \"x\" to \"x\". \"round(x, digits)\" rounds to the specified number\n   of digits after the decimal place, or before if negative, e.g.,\n   \"round(pi,2)\" is \"3.14\". \"round(x, digits, base)\" rounds\n   using a different base, defaulting to 10, e.g., \"round(pi, 1, 8)\"\n   is \"3.125\".\n",
        "methods": 
        [
          "round(x::Integer) at int.jl:368",
          "round(x::Float64) at float.jl:107",
          "round(x::Rational{T<:Integer}) at rational.jl:164",
          "round(x::Float32) at math.jl:297",
          "round{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "round(M::SymTridiagonal{T}) at linalg/tridiag.jl:32",
          "round(M::Tridiagonal{T}) at linalg/tridiag.jl:188",
          "iround(M::Bidiagonal{T}) at linalg/bidiag.jl:67",
          "round{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "round{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "round{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "round(x::Float16) at float16.jl:101",
          "round(x::BigFloat) at mpfr.jl:639",
          "round(x,digits::Integer) at floatfuncs.jl:85",
          "round(x,digits::Integer,base::Integer) at floatfuncs.jl:85"
        ]
      },
      {
        "name": "rpad",
        "summary": "Function",
        "help": "Base.rpad(string, n, p)\n\n   Make a string at least \"n\" characters long by padding on the\n   right with copies of \"p\".\n",
        "methods": 
        [
          "rpad(s::String,n::Integer) at string.jl:1260",
          "rpad(s::String,n::Integer,p::String) at string.jl:1260",
          "rpad(s,n::Integer) at string.jl:1272",
          "rpad(s,n::Integer,p) at string.jl:1272"
        ]
      },
      {
        "name": "rref",
        "summary": "Function",
        "help": "Base.rref(A)\n\n   Compute the reduced row echelon form of the matrix A.\n",
        "methods": 
        [
          "rref{T}(A::Array{T,2}) at linalg/dense.jl:167",
          "rref(x::Number) at linalg/dense.jl:200"
        ]
      },
      {
        "name": "rsearch",
        "summary": "Function",
        "help": "Base.rsearch(string, chars[, start])\n\n   Similar to \"search\", but returning the last occurance of the\n   given characters within the given string, searching in reverse from\n   \"start\".\n",
        "methods": 
        [
          "rsearch(s::ASCIIString,c::Char,i::Integer) at ascii.jl:21",
          "rsearch(s::UTF8String,c::Char,i::Integer) at utf8.jl:124",
          "rsearch(s::String,c::Union(Char,Set{Char},AbstractArray{Char,1})) at string.jl:325",
          "rsearch(s::String,c::Union(Char,Set{Char},AbstractArray{Char,1}),i::Integer) at string.jl:325",
          "rsearch(s::Union(Array{Uint8,1},Array{Int8,1}),t::Union(Array{Uint8,1},Array{Int8,1}),i) at string.jl:447",
          "rsearch(s::String,t::String) at string.jl:456",
          "rsearch(s::String,t::String,i::Integer) at string.jl:456",
          "rsearch(a::Union(Array{Uint8,1},Array{Int8,1}),b::Union(Uint8,Int8),i::Integer) at string.jl:1628",
          "rsearch(a::Union(Array{Uint8,1},Array{Int8,1}),b::Char,i::Integer) at string.jl:1636",
          "rsearch(a::Union(Array{Uint8,1},Array{Int8,1}),b::Union(Char,Uint8,Int8)) at string.jl:1642"
        ]
      },
      {
        "name": "rsearchindex",
        "summary": "Function",
        "help": "Base.rsearchindex(string, substring[, start])\n\n   Similar to \"rsearch\", but return only the start index at which\n   the substring is found, or 0 if it is not.\n",
        "methods": 
        [
          "rsearchindex(s::Union(Array{Uint8,1},Array{Int8,1}),t::Union(Array{Uint8,1},Array{Int8,1}),i) at string.jl:426",
          "rsearchindex(s::Union(UTF8String,ASCIIString),t::Union(UTF8String,ASCIIString)) at string.jl:431",
          "rsearchindex(s::Union(UTF8String,ASCIIString),t::Union(UTF8String,ASCIIString),i::Integer) at string.jl:439",
          "rsearchindex(s::String,t::String,i::Integer) at string.jl:427",
          "rsearchindex(s::String,t::String) at string.jl:428"
        ]
      },
      {
        "name": "rsplit",
        "summary": "Function",
        "help": "Base.rsplit(string, [chars, [limit,] [include_empty]])\n\n   Similar to \"split\", but starting from the end of the string.\n",
        "methods": 
        [
          "rsplit{T<:SubString{T<:String}}(str::T<:SubString{T<:String},splitter,limit::Integer,keep_empty::Bool) at string.jl:1310",
          "rsplit(s::String,spl,keep::Bool) at string.jl:1332",
          "rsplit{T<:String}(str::T<:String,splitter,limit::Integer,keep_empty::Bool) at string.jl:1311",
          "rsplit(s::String,spl,n::Integer) at string.jl:1331",
          "rsplit(s::String,spl) at string.jl:1333"
        ]
      },
      {
        "name": "rstrip",
        "summary": "Function",
        "help": "Base.rstrip(string[, chars])\n\n   Return \"string\" with any trailing whitespace removed. If\n   \"chars\" (a character, or vector or set of characters) is\n   provided, instead remove characters contained in it.\n",
        "methods": 
        [
          "rstrip(s::String) at string.jl:1433",
          "rstrip(s::String,chars::Union(Char,Set{Char},AbstractArray{Char,1})) at string.jl:1433",
          "rstrip(a::String,b::String) at deprecated.jl:26"
        ]
      },
      {
        "name": "run",
        "summary": "Function",
        "help": "Base.run(command)\n\n   Run a command object, constructed with backticks. Throws an error\n   if anything goes wrong, including the process exiting with a non-\n   zero status.\n",
        "methods": 
        [
          "run(cmds::AbstractCmd,args...) at process.jl:470",
          "run(c::Choices) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:178",
          "run(f::Function) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:409",
          "run(s::FileRule) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:413",
          "run(s::DirectoryRule) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:421",
          "run(s::BuildStep) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:432",
          "run(s::SynchronousStepCollection) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:435"
        ]
      },
      {
        "name": "safe_char",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "safe_char(c) at deprecated.jl:26"
        ]
      },
      {
        "name": "scale",
        "summary": "Function",
        "help": "Base.scale(A, b)\n\nBase.scale(b, A)\n\n   Scale an array \"A\" by a scalar \"b\", returning a new array.\n\n   If \"A\" is a matrix and \"b\" is a vector, then \"scale(A,b)\"\n   scales each column \"i\" of \"A\" by \"b[i]\" (similar to\n   \"A*diagm(b)\"), while \"scale(b,A)\" scales each row \"i\" of\n   \"A\" by \"b[i]\" (similar to \"diagm(b)*A\"), returning a new\n   array.\n\n   Note: for large \"A\", \"scale\" can be much faster than \"A .* b\"\n   or \"b .* A\", due to the use of BLAS.\n",
        "methods": 
        [
          "scale{R<:Real,S<:Complex{T<:Real}}(X::AbstractArray{R<:Real,N},s::S<:Complex{T<:Real}) at linalg/generic.jl:7",
          "scale(X::AbstractArray{T,N},s::Number) at linalg/generic.jl:3",
          "scale{R<:Real}(s::Complex{T<:Real},X::AbstractArray{R<:Real,N}) at linalg/generic.jl:12",
          "scale(s::Number,X::AbstractArray{T,N}) at linalg/generic.jl:4",
          "scale(A::Array{T,2},b::Array{T,1}) at linalg/matmul.jl:27",
          "scale(b::Array{T,1},A::Array{T,2}) at linalg/matmul.jl:28",
          "scale{Tv,Ti,T}(A::SparseMatrixCSC{Tv,Ti},b::Array{T,1}) at linalg/sparse.jl:619",
          "scale{T,Tv,Ti}(b::Array{T,1},A::SparseMatrixCSC{Tv,Ti}) at linalg/sparse.jl:622",
          "scale{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(b::Array{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},A::CholmodSparse{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:905",
          "scale{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},b::Array{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1}) at linalg/cholmod.jl:910",
          "scale(gc::GraphicsContext,::Real,::Real)"
        ]
      },
      {
        "name": "scale!",
        "summary": "Function",
        "help": "Base.scale!(A, b)\n\nBase.scale!(b, A)\n\n   Scale an array \"A\" by a scalar \"b\", similar to \"scale()\" but\n   overwriting \"A\" in-place.\n\n   If \"A\" is a matrix and \"b\" is a vector, then \"scale!(A,b)\"\n   scales each column \"i\" of \"A\" by \"b[i]\" (similar to\n   \"A*diagm(b)\"), while \"scale!(b,A)\" scales each row \"i\" of\n   \"A\" by \"b[i]\" (similar to \"diagm(b)*A\"), again operating in-\n   place on \"A\".\n",
        "methods": 
        [
          "scale!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(X::Array{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N},s::T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})) at linalg/dense.jl:11",
          "scale!{T<:Union(Complex{Float64},Complex{Float32})}(X::Array{T<:Union(Complex{Float64},Complex{Float32}),N},s::Real) at linalg/dense.jl:20",
          "scale!{T<:Union(Float64,Float32)}(X::Array{T<:Union(Float64,Float32),N},s::Complex{T<:Real}) at deprecated.jl:462",
          "scale!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(X::Array{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),N},s::Number) at linalg/dense.jl:19",
          "scale!(X::AbstractArray{T,N},s::Number) at linalg/generic.jl:20",
          "scale!(s::Number,X::AbstractArray{T,N}) at linalg/generic.jl:21",
          "scale!(C::Array{T,2},A::Array{T,2},b::Array{T,1}) at linalg/matmul.jl:8",
          "scale!(C::Array{T,2},b::Array{T,1},A::Array{T,2}) at linalg/matmul.jl:20",
          "scale!{Tv,Ti}(C::SparseMatrixCSC{Tv,Ti},A::SparseMatrixCSC{Tv,Ti<:Integer},b::Array{T,1}) at linalg/sparse.jl:594",
          "scale!{Tv,Ti}(C::SparseMatrixCSC{Tv,Ti},b::Array{T,1},A::SparseMatrixCSC{Tv,Ti<:Integer}) at linalg/sparse.jl:607",
          "scale!(A::AbstractArray{T,2},b::AbstractArray{T,1}) at linalg/generic.jl:312",
          "scale!(b::AbstractArray{T,1},A::AbstractArray{T,2}) at linalg/generic.jl:313",
          "scale!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(b::Array{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},A::CholmodSparse{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:902",
          "scale!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},b::Array{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1}) at linalg/cholmod.jl:907"
        ]
      },
      {
        "name": "schedule",
        "summary": "Function",
        "help": "Base.schedule(t::Task, [val]; error=false)\n\n   Add a task to the scheduler's queue. This causes the task to run\n   constantly when the system is otherwise idle, unless the task\n   performs a blocking operation such as \"wait\".\n\n   If a second argument is provided, it will be passed to the task\n   (via the return value of \"yieldto\") when it runs again. If\n   \"error\" is true, the value is raised as an exception in the woken\n   task.\n",
        "methods": 
        [
          "schedule(t::Task) at task.jl:235",
          "schedule(t::Task,arg) at task.jl:239"
        ]
      },
      {
        "name": "schur",
        "summary": "Function",
        "help": "Base.schur(A) -> Schur[:T], Schur[:Z], Schur[:values]\n\n   See \"schurfact()\"\n\nBase.schur(A, B) -> GeneralizedSchur[:S], GeneralizedSchur[:T], GeneralizedSchur[:Q], GeneralizedSchur[:Z]\n\n   See \"schurfact()\"\n",
        "methods": 
        [
          "schur(A::AbstractArray{T,2}) at linalg/factorization.jl:758",
          "schur(A::AbstractArray{T,2},B::AbstractArray{T,2}) at linalg/factorization.jl:787"
        ]
      },
      {
        "name": "schurfact",
        "summary": "Function",
        "help": "Base.schurfact(A) -> Schur\n\n   Computes the Schur factorization of the matrix \"A\". The (quasi)\n   triangular Schur factor can be obtained from the \"Schur\" object\n   \"F\" with either \"F[:Schur]\" or \"F[:T]\" and the\n   unitary/orthogonal Schur vectors can be obtained with\n   \"F[:vectors]\" or \"F[:Z]\" such that\n   \"A=F[:vectors]*F[:Schur]*F[:vectors]'\". The eigenvalues of \"A\"\n   can be obtained with \"F[:values]\".\n\nBase.schurfact(A, B) -> GeneralizedSchur\n\n   Computes the Generalized Schur (or QZ) factorization of the\n   matrices \"A\" and \"B\". The (quasi) triangular Schur factors can\n   be obtained from the \"Schur\" object \"F\" with \"F[:S]\" and\n   \"F[:T]\", the left unitary/orthogonal Schur vectors can be\n   obtained with \"F[:left]\" or \"F[:Q]\" and the right\n   unitary/orthogonal Schur vectors can be obtained with \"F[:right]\"\n   or \"F[:Z]\" such that \"A=F[:left]*F[:S]*F[:right]'\" and\n   \"B=F[:left]*F[:T]*F[:right]'\". The generalized eigenvalues of\n   \"A\" and \"B\" can be obtained with \"F[:alpha]./F[:beta]\".\n",
        "methods": 
        [
          "schurfact{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:747",
          "schurfact{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:772",
          "schurfact{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/factorization.jl:748",
          "schurfact{TA,TB}(A::Union(DenseArray{TA,2},SubArray{TA,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{TB,2},SubArray{TB,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:773"
        ]
      },
      {
        "name": "schurfact!",
        "summary": "Function",
        "help": "Base.schurfact!(A)\n\n   Computer the Schur factorization of \"A\", overwriting \"A\" in the\n   process. See \"schurfact()\"\n",
        "methods": 
        [
          "schurfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:746",
          "schurfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:771"
        ]
      },
      {
        "name": "sdata",
        "summary": "Function",
        "help": "Base.sdata(S::SharedArray)\n\n   Returns the actual \"Array\" object backing \"S\"\n",
        "methods": 
        [
          "sdata(S::SharedArray{T,N}) at sharedarray.jl:133",
          "sdata(A::AbstractArray{T,N}) at sharedarray.jl:134"
        ]
      },
      {
        "name": "search",
        "summary": "Function",
        "help": "Base.search(string, chars[, start])\n\n   Search for the first occurance of the given characters within the\n   given string. The second argument may be a single character, a\n   vector or a set of characters, a string, or a regular expression\n   (though regular expressions are only allowed on contiguous strings,\n   such as ASCII or UTF-8 strings). The third argument optionally\n   specifies a starting index. The return value is a range of indexes\n   where the matching sequence is found, such that \"s[search(s,x)] ==\n   x\":\n\n   \"search(string, \"substring\")\" = \"start:end\" such that\n   \"string[start:end] == \"substring\"\", or \"0:-1\" if unmatched.\n\n   \"search(string, 'c')\"         = \"index\" such that\n   \"string[index] == 'c'\", or \"0\" if unmatched.\n",
        "methods": 
        [
          "search(s::ASCIIString,c::Char,i::Integer) at ascii.jl:20",
          "search(s::UTF8String,c::Char,i::Integer) at utf8.jl:115",
          "search(buf::IOBuffer,delim) at iobuffer.jl:259",
          "search(s::String,c::Union(Char,Set{Char},AbstractArray{Char,1}),i::Integer) at string.jl:178",
          "search(s::String,c::Union(Char,Set{Char},AbstractArray{Char,1})) at string.jl:194",
          "search(s::Union(Array{Uint8,1},Array{Int8,1}),t::Union(Array{Uint8,1},Array{Int8,1}),i) at string.jl:307",
          "search(s::String,t::String) at string.jl:316",
          "search(s::String,t::String,i::Integer) at string.jl:316",
          "search(a::Union(Array{Uint8,1},Array{Int8,1}),b::Union(Uint8,Int8),i::Integer) at string.jl:1611",
          "search(a::Union(Array{Uint8,1},Array{Int8,1}),b::Char,i::Integer) at string.jl:1619",
          "search(a::Union(Array{Uint8,1},Array{Int8,1}),b::Union(Char,Uint8,Int8)) at string.jl:1625",
          "search(str::Union(ASCIIString,SubString{T<:String},UTF8String),re::Regex,idx::Integer) at regex.jl:171",
          "search(s::String,r::Regex,idx::Integer) at regex.jl:179",
          "search(s::String,r::Regex) at regex.jl:181"
        ]
      },
      {
        "name": "searchindex",
        "summary": "Function",
        "help": "Base.searchindex(string, substring[, start])\n\n   Similar to \"search\", but return only the start index at which the\n   substring is found, or 0 if it is not.\n",
        "methods": 
        [
          "searchindex(s::Union(Array{Uint8,1},Array{Int8,1}),t::Union(Array{Uint8,1},Array{Int8,1}),i) at string.jl:294",
          "searchindex(s::Union(UTF8String,ASCIIString),t::Union(UTF8String,ASCIIString)) at string.jl:299",
          "searchindex(s::Union(UTF8String,ASCIIString),t::Union(UTF8String,ASCIIString),i::Integer) at string.jl:299",
          "searchindex(s::String,t::String,i::Integer) at string.jl:295",
          "searchindex(s::String,t::String) at string.jl:296"
        ]
      },
      {
        "name": "searchsorted",
        "summary": "Function",
        "help": "Base.searchsorted(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Returns the range of indices of \"a\" which compare as equal to\n   \"x\" according to the order specified by the \"by\", \"lt\" and\n   \"rev\" keywords, assuming that \"a\" is already sorted in that\n   order. Returns an empty range located at the insertion point if\n   \"a\" does not contain values equal to \"x\".\n",
        "methods": 
        [
          "searchsorted(v::AbstractArray{T,1},x,lo::Int64,hi::Int64,o::Ordering) at sort.jl:161",
          "searchsorted{T<:Real}(a::Range{T<:Real},x::Real,o::Union(ForwardOrdering,ReverseOrdering{ForwardOrdering})) at sort.jl:212",
          "searchsorted(v::AbstractArray{T,1},x,o::Ordering) at sort.jl:217",
          "searchsorted(v::AbstractArray{T,1},x) at sort.jl:218"
        ]
      },
      {
        "name": "searchsortedfirst",
        "summary": "Function",
        "help": "Base.searchsortedfirst(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Returns the index of the first value in \"a\" greater than or equal\n   to \"x\", according to the specified order. Returns \"length(a)+1\"\n   if \"x\" is greater than all values in \"a\".\n",
        "methods": 
        [
          "searchsortedfirst(v::AbstractArray{T,1},x,lo::Int64,hi::Int64,o::Ordering) at sort.jl:128",
          "searchsortedfirst{T<:Integer}(a::Range{T<:Integer},x::Real,o::Union(ForwardOrdering,ReverseOrdering{ForwardOrdering})) at sort.jl:205",
          "searchsortedfirst{T<:Real}(a::Range{T<:Real},x::Real,o::Union(ForwardOrdering,ReverseOrdering{ForwardOrdering})) at sort.jl:188",
          "searchsortedfirst(v::AbstractArray{T,1},x,o::Ordering) at sort.jl:217",
          "searchsortedfirst(v::AbstractArray{T,1},x) at sort.jl:218"
        ]
      },
      {
        "name": "searchsortedlast",
        "summary": "Function",
        "help": "Base.searchsortedlast(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Returns the index of the last value in \"a\" less than or equal to\n   \"x\", according to the specified order. Returns \"0\" if \"x\" is\n   less than all values in \"a\".\n",
        "methods": 
        [
          "searchsortedlast(v::AbstractArray{T,1},x,lo::Int64,hi::Int64,o::Ordering) at sort.jl:144",
          "searchsortedlast{T<:Integer}(a::Range{T<:Integer},x::Real,o::Union(ForwardOrdering,ReverseOrdering{ForwardOrdering})) at sort.jl:197",
          "searchsortedlast{T<:Real}(a::Range{T<:Real},x::Real,o::Union(ForwardOrdering,ReverseOrdering{ForwardOrdering})) at sort.jl:179",
          "searchsortedlast(v::AbstractArray{T,1},x,o::Ordering) at sort.jl:217",
          "searchsortedlast(v::AbstractArray{T,1},x) at sort.jl:218"
        ]
      },
      {
        "name": "sec",
        "summary": "Function",
        "help": "Base.sec(x)\n\n   Compute the secant of \"x\", where \"x\" is in radians\n",
        "methods": 
        [
          "sec(x::BigFloat) at mpfr.jl:547",
          "sec{T<:Number}(z::T<:Number) at math.jl:158",
          "sec{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "sec{T<:Number}(z::AbstractArray{T<:Number,N}) at math.jl:159"
        ]
      },
      {
        "name": "secd",
        "summary": "Function",
        "help": "Base.secd(x)\n\n   Compute the secant of \"x\", where \"x\" is in degrees\n",
        "methods": 
        [
          "secd{T<:Number}(z::T<:Number) at math.jl:158",
          "secd{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "secd{T<:Number}(z::AbstractArray{T<:Number,N}) at math.jl:159"
        ]
      },
      {
        "name": "sech",
        "summary": "Function",
        "help": "Base.sech(x)\n\n   Compute the hyperbolic secant of \"x\"\n",
        "methods": 
        [
          "sech(x::BigFloat) at mpfr.jl:397",
          "sech{T<:Number}(z::T<:Number) at math.jl:158",
          "sech{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "sech{T<:Number}(z::AbstractArray{T<:Number,N}) at math.jl:159"
        ]
      },
      {
        "name": "seek",
        "summary": "Function",
        "help": "Base.seek(s, pos)\n\n   Seek a stream to the given position.\n",
        "methods": 
        [
          "seek(io::IOBuffer,n::Integer) at iobuffer.jl:103",
          "seek(s::IOStream,n::Integer) at io.jl:284",
          "seek(h::CFILE,offset::Integer) at io.jl:329"
        ]
      },
      {
        "name": "seek_end",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "seek_end(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "seekend",
        "summary": "Function",
        "help": "Base.seekend(s)\n\n   Seek a stream to its end.\n",
        "methods": 
        [
          "seekend(io::IOBuffer) at iobuffer.jl:108",
          "seekend(s::IOStream) at io.jl:293"
        ]
      },
      {
        "name": "seekstart",
        "summary": "Function",
        "help": "Base.seekstart(s)\n\n   Seek a stream to its beginning.\n",
        "methods": 
        [
          "seekstart(s::IO) at io.jl:290"
        ]
      },
      {
        "name": "select",
        "summary": "Function",
        "help": "Base.select(v, k, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Variant of \"select!\" which copies \"v\" before partially sorting\n   it, thereby returning the same thing as \"select!\" but leaving\n   \"v\" unmodified.\n",
        "methods": 
        [
          "select(v::AbstractArray{T,1},k::Union(UnitRange{T<:Real},Int64),o::Ordering) at deprecated.jl:26",
          "select(v::AbstractArray{T,1},k::Union(UnitRange{T<:Real},Int64),f::Function) at deprecated.jl:26",
          "select(v::AbstractArray{T,1},k::Union(OrdinalRange{T,S},Int64)) at sort.jl:120",
          "select(f::Function,v::AbstractArray{T,1},k::Union(UnitRange{T<:Real},Int64)) at deprecated.jl:26"
        ]
      },
      {
        "name": "select!",
        "summary": "Function",
        "help": "Base.select!(v, k, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Partially sort the vector \"v\" in place, according to the order\n   specified by \"by\", \"lt\" and \"rev\" so that the value at index\n   \"k\" (or range of adjacent values if \"k\" is a range) occurs at\n   the position where it would appear if the array were fully sorted.\n   If \"k\" is a single index, that values is returned; if \"k\" is a\n   range, an array of values at those indices is returned. Note that\n   \"select!\" does not fully sort the input array, but does leave the\n   returned elements where they would be if the array were fully\n   sorted.\n",
        "methods": 
        [
          "select!(v::AbstractArray{T,1},k::Int64,lo::Int64,hi::Int64,o::Ordering) at sort.jl:56",
          "select!(v::AbstractArray{T,1},r::OrdinalRange{T,S},lo::Int64,hi::Int64,o::Ordering) at sort.jl:85",
          "select!(v::AbstractArray{T,1},k::Union(OrdinalRange{T,S},Int64),o::Ordering) at sort.jl:115",
          "select!(v::AbstractArray{T,1},k::Union(UnitRange{T<:Real},Int64),f::Function) at deprecated.jl:26",
          "select!(v::AbstractArray{T,1},k::Union(OrdinalRange{T,S},Int64)) at sort.jl:116",
          "select!(f::Function,v::AbstractArray{T,1},k::Union(UnitRange{T<:Real},Int64)) at deprecated.jl:26"
        ]
      },
      {
        "name": "send",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "send(sock::UdpSocket,ipaddr,port,msg) at socket.jl:484"
        ]
      },
      {
        "name": "serialize",
        "summary": "Function",
        "help": "Base.serialize(stream, value)\n\n   Write an arbitrary value to a stream in an opaque format, such that\n   it can be read back by \"deserialize\". The read-back value will be\n   as identical as possible to the original. In general, this process\n   will not work if the reading and writing are done by different\n   versions of Julia, or an instance of Julia with a different system\n   image.\n",
        "methods": 
        [
          "serialize(s,t::Dict{K,V}) at dict.jl:268",
          "serialize{T}(s,ss::SubString{T}) at string.jl:656",
          "serialize(s,r::Regex) at regex.jl:248",
          "serialize(s,x::Bool) at serialize.jl:58",
          "serialize(s,::Ptr{T}) at serialize.jl:60",
          "serialize(s,::()) at serialize.jl:62",
          "serialize(s,t::(Any...,)) at serialize.jl:65",
          "serialize(s,x::Symbol) at serialize.jl:79",
          "serialize(s,a::Array{T,N}) at serialize.jl:115",
          "serialize{T,N,A<:Array{T,N}}(s,a::SubArray{T,N,A<:Array{T,N},I<:(Union(Range{Int64},Int64)...,)}) at serialize.jl:139",
          "serialize(s,e::Expr) at serialize.jl:149",
          "serialize(s,m::Module) at serialize.jl:165",
          "serialize(s,f::Function) at serialize.jl:170",
          "serialize(s,linfo::LambdaStaticData) at serialize.jl:225",
          "serialize(s,t::Task) at serialize.jl:244",
          "serialize(s,t::DataType) at serialize.jl:268",
          "serialize(s,rr::RemoteRef) at multi.jl:554",
          "serialize(s,n::BigInt) at gmp.jl:180",
          "serialize(s,n::BigFloat) at mpfr.jl:131",
          "serialize(s,S::SharedArray{T,N}) at sharedarray.jl:186",
          "serialize(s,t::HashDict{K,V,O<:Union(Nothing,Int64)}) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:55",
          "serialize(s,x) at serialize.jl:288"
        ]
      },
      {
        "name": "set_bigfloat_precision",
        "summary": "Function",
        "help": "Base.set_bigfloat_precision(x::Int64)\n\n   Set the precision (in bits) to be used to BigFloat arithmetic.\n",
        "methods": 
        [
          "set_bigfloat_precision(x::Int64) at mpfr.jl:591"
        ]
      },
      {
        "name": "set_bigfloat_rounding",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "set_bigfloat_rounding(r::RoundingMode) at deprecated.jl:26"
        ]
      },
      {
        "name": "set_rounding",
        "summary": "Function",
        "help": "Base.set_rounding(T, mode)\n\n   Set the rounding mode of floating point type \"T\". Note that this\n   may affect other types, for instance changing the rounding mode of\n   \"Float64\" will change the rounding mode of \"Float32\". See\n   \"get_rounding\" for available modes\n",
        "methods": 
        [
          "set_rounding{T<:Union(Float64,Float32)}(::Type{T<:Union(Float64,Float32)},r::RoundingMode) at rounding.jl:49",
          "set_rounding(::Type{BigFloat},r::RoundingMode) at mpfr.jl:616",
          "set_rounding(r::RoundingMode) at deprecated.jl:26"
        ]
      },
      {
        "name": "setdiff",
        "summary": "Function",
        "help": "Base.setdiff(s1, s2)\n\n   Construct the set of elements in \"s1\" but not \"s2\". Maintains\n   order with arrays. Note that both arguments must be collections,\n   and both will be iterated over. In particular,\n   \"setdiff(set,element)\" where \"element\" is a potential member of\n   \"set\", will not work in general.\n",
        "methods": 
        [
          "setdiff(a::IntSet,b::IntSet) at intset.jl:90",
          "setdiff(a::Set{T},b::Set{T}) at set.jl:73",
          "setdiff(a::OrderedSet{T},b) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:73",
          "setdiff(a,b) at array.jl:1352"
        ]
      },
      {
        "name": "setdiff!",
        "summary": "Function",
        "help": "Base.setdiff!(s, iterable)\n\n   Remove each element of \"iterable\" from set \"s\" in-place.\n",
        "methods": 
        [
          "setdiff!(s::IntSet,ns) at intset.jl:84",
          "setdiff!(s::Set{T},xs::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:33",
          "setdiff!(s::Set{T},xs) at set.jl:24",
          "setdiff!(s::OrderedSet{T},xs) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:32"
        ]
      },
      {
        "name": "setenv",
        "summary": "Function",
        "help": "Base.setenv(command, env)\n\n   Set environment variables to use when running the given command.\n   \"env\" is either a dictionary mapping strings to strings, or an\n   array of strings of the form \"\"var=val\"\".\n",
        "methods": 
        [
          "setenv{S<:Union(UTF8String,ASCIIString)}(cmd::Cmd,env::Array{S<:Union(UTF8String,ASCIIString),N}) at process.jl:143",
          "setenv(cmd::Cmd,env::Associative{K,V}) at process.jl:144",
          "setenv(cmd::Cmd) at process.jl:145"
        ]
      },
      {
        "name": "setfield",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setfield(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "setindex!",
        "summary": "Function",
        "help": "Base.setindex!(collection, value, key...)\n\n   Store the given value at the given key or index within a\n   collection. The syntax \"a[i,j,...] = x\" is converted by the\n   compiler to \"setindex!(a, x, i, j, ...)\".\n\nBase.setindex!(A, X, inds...)\n\n   Store values from array \"X\" within some subset of \"A\" as\n   specified by \"inds\".\n",
        "methods": 
        [
          "setindex!(a::Array{Any,N},d::Union(DArray{T,N,A},SubArray{T,N,D<:DArray{T,N,A},I<:(Union(Range{Int64},Int64)...,)}),i::Int64) at darray.jl:294",
          "setindex!(A::Array{Any,N},x,i::Real) at base.jl:170",
          "setindex!{T}(s::SubArray{T,0,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v) at subarray.jl:356",
          "setindex!{T}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,i::Integer) at subarray.jl:359",
          "setindex!{T}(s::SubArray{T,2,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,i::Integer,j::Integer) at subarray.jl:362",
          "setindex!{T}(s::SubArray{T,3,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,i::Integer,j::Integer,k::Integer) at subarray.jl:365",
          "setindex!{T}(s::SubArray{T,4,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,i::Integer,j::Integer,k::Integer,l::Integer) at subarray.jl:368",
          "setindex!{T}(s::SubArray{T,5,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,i::Integer,j::Integer,k::Integer,l::Integer,m::Integer) at subarray.jl:371",
          "setindex!{T}(s::SubArray{T,2,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,ind::Integer) at multidimensional.jl:122",
          "setindex!{T}(s::SubArray{T,3,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,ind::Integer) at multidimensional.jl:122",
          "setindex!{T}(s::SubArray{T,4,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,ind::Integer) at multidimensional.jl:122",
          "setindex!{T}(s::SubArray{T,5,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,ind::Integer) at multidimensional.jl:122",
          "setindex!(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,i::Integer) at subarray.jl:345",
          "setindex!(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,is::Integer...) at subarray.jl:348",
          "setindex!(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,I::Real) at subarray.jl:390",
          "setindex!{T}(A::Array{T,N},X::Array{T,N},I::UnitRange{Int64}) at array.jl:329",
          "setindex!(a::Array{T,N},d::DArray{T,N,A},I::UnitRange{Int64}...) at darray.jl:254",
          "setindex!(a::Array{T,N},s::SubArray{T,N,D<:DArray{T,N,A},I<:(Union(Range{Int64},Int64)...,)},I::UnitRange{Int64}...) at darray.jl:265",
          "setindex!(a::Array{T,N},d::Union(DArray{T,N,A},SubArray{T,N,D<:DArray{T,N,A},I<:(Union(Range{Int64},Int64)...,)}),I::Union(UnitRange{Int64},Int64)...) at darray.jl:296",
          "setindex!(A::Array{T,2},x::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{Bool,1},J::Integer) at sparse/sparsematrix.jl:1449",
          "setindex!(A::Array{T,2},x::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{Bool,1},J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1450",
          "setindex!{T<:Integer}(A::Array{T,2},x::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{Bool,1},J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1452",
          "setindex!(A::Array{T,N},X::AbstractArray{T,N},I::AbstractArray{Bool,1}) at array.jl:379",
          "setindex!{T<:Integer}(A::Array{T,2},x::SparseMatrixCSC{Tv,Ti<:Integer},I::AbstractArray{T<:Integer,1},J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1451",
          "setindex!{T<:Real}(A::Array{T,N},X::AbstractArray{T,N},I::AbstractArray{T<:Real,1}) at array.jl:337",
          "setindex!(A::Array{T,N},x,I::AbstractArray{Bool,1}) at array.jl:381",
          "setindex!{T<:Real}(A::Array{T,N},x,I::AbstractArray{T<:Real,1}) at array.jl:322",
          "setindex!(A::Array{T,N},X::AbstractArray{T,N},I::AbstractArray{Bool,N}) at array.jl:380",
          "setindex!(A::Array{T,2},x::SparseMatrixCSC{Tv,Ti<:Integer},I::Integer,J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1448",
          "setindex!{T}(A::Array{T,N},x) at array.jl:305",
          "setindex!{T}(A::Array{T,N},x,i0::Real) at array.jl:307",
          "setindex!{T}(A::Array{T,N},x,i0::Real,i1::Real) at array.jl:308",
          "setindex!{T}(A::Array{T,N},x,i0::Real,i1::Real,i2::Real) at array.jl:310",
          "setindex!{T}(A::Array{T,N},x,i0::Real,i1::Real,i2::Real,i3::Real) at array.jl:312",
          "setindex!{T}(A::Array{T,N},x,i0::Real,i1::Real,i2::Real,i3::Real,i4::Real) at array.jl:314",
          "setindex!{T}(A::Array{T,N},x,i0::Real,i1::Real,i2::Real,i3::Real,i4::Real,i5::Real) at array.jl:316",
          "setindex!{T}(A::Array{T,N},x,i0::Real,i1::Real,i2::Real,i3::Real,i4::Real,i5::Real,I::Real...) at array.jl:318",
          "setindex!(B::BitArray{N},x::Bool,i::Int64) at bitarray.jl:415",
          "setindex!(B::BitArray{N},X::AbstractArray{T,N},I::AbstractArray{Bool,N}) at bitarray.jl:434",
          "setindex!(B::BitArray{N},x::Bool,I_0::Int64,I_1::Int64) at multidimensional.jl:273",
          "setindex!(B::BitArray{N},x::Bool,I_0::Int64,I_1::Int64,I_2::Int64) at multidimensional.jl:273",
          "setindex!(B::BitArray{N},x::Bool,I_0::Int64,I_1::Int64,I_2::Int64,I_3::Int64) at multidimensional.jl:273",
          "setindex!(B::BitArray{N},x::Bool,I_0::Int64,I_1::Int64,I_2::Int64,I_3::Int64,I_4::Int64) at multidimensional.jl:273",
          "setindex!(B::BitArray{N},x::Bool,I_0::Int64,I::Int64...) at cartesian.jl:100",
          "setindex!(B::BitArray{N},X::AbstractArray{T,N},i::Real) at multidimensional.jl:396",
          "setindex!(B::BitArray{N},X::AbstractArray{T,N},I_1::Union(Real,AbstractArray{T,N})) at multidimensional.jl:403",
          "setindex!(B::BitArray{N},X::AbstractArray{T,N},I_1::Union(Real,AbstractArray{T,N}),I_2::Union(Real,AbstractArray{T,N})) at multidimensional.jl:403",
          "setindex!(B::BitArray{N},X::AbstractArray{T,N},I_1::Union(Real,AbstractArray{T,N}),I_2::Union(Real,AbstractArray{T,N}),I_3::Union(Real,AbstractArray{T,N})) at multidimensional.jl:403",
          "setindex!(B::BitArray{N},X::AbstractArray{T,N},I_1::Union(Real,AbstractArray{T,N}),I_2::Union(Real,AbstractArray{T,N}),I_3::Union(Real,AbstractArray{T,N}),I_4::Union(Real,AbstractArray{T,N})) at multidimensional.jl:403",
          "setindex!(B::BitArray{N},X::AbstractArray{T,N},I::Union(AbstractArray{T,N},Real)...) at cartesian.jl:100",
          "setindex!(B::BitArray{N},x) at bitarray.jl:412",
          "setindex!(B::BitArray{N},x,i::Real) at multidimensional.jl:382",
          "setindex!(S::SharedArray{T,N},x) at sharedarray.jl:214",
          "setindex!(S::SharedArray{T,N},x,I::Real) at sharedarray.jl:215",
          "setindex!(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Array{T,2},I::Integer,J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1442",
          "setindex!{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},v::AbstractArray{T,2},i::Integer,J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1140",
          "setindex!{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Number,i::Integer,J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1143",
          "setindex!(A::SparseMatrixCSC{Tv,Ti<:Integer},v,i::Integer) at sparse/sparsematrix.jl:1033",
          "setindex!{T,Ti}(A::SparseMatrixCSC{T,Ti},v,i0::Integer,i1::Integer) at sparse/sparsematrix.jl:1036",
          "setindex!{Tv,Ti,T<:Integer}(A::SparseMatrixCSC{Tv,Ti},v::AbstractArray{T,1},i::Integer,J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1317",
          "setindex!(t::AbstractArray{T,N},x,i::Real) at abstractarray.jl:425",
          "setindex!{T}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,I::UnitRange{Int64}) at subarray.jl:374",
          "setindex!{T}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,I::Range{Int64}) at subarray.jl:377",
          "setindex!{T,S<:Integer}(s::SubArray{T,1,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,I::AbstractArray{S<:Integer,1}) at subarray.jl:381",
          "setindex!(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},v,I::Union(AbstractArray{T,N},Real)...) at subarray.jl:394",
          "setindex!(A::Array{T,N},x,I::AbstractArray{Bool,N}) at array.jl:382",
          "setindex!(B::BitArray{N},x,I::AbstractArray{Bool,N}) at bitarray.jl:423",
          "setindex!(A::Array{T,N},x,J_1::Union(Real,AbstractArray{T,N})) at multidimensional.jl:61",
          "setindex!(A::Array{T,N},x,J_1::Union(Real,AbstractArray{T,N}),J_2::Union(Real,AbstractArray{T,N})) at multidimensional.jl:61",
          "setindex!(A::Array{T,N},x,J_1::Union(Real,AbstractArray{T,N}),J_2::Union(Real,AbstractArray{T,N}),J_3::Union(Real,AbstractArray{T,N})) at multidimensional.jl:61",
          "setindex!(A::Array{T,N},x,J_1::Union(Real,AbstractArray{T,N}),J_2::Union(Real,AbstractArray{T,N}),J_3::Union(Real,AbstractArray{T,N}),J_4::Union(Real,AbstractArray{T,N})) at multidimensional.jl:61",
          "setindex!(A::Array{T,N},x,J::Union(AbstractArray{T,N},Real)...) at cartesian.jl:100",
          "setindex!(B::BitArray{N},x,I_1::Union(Real,AbstractArray{T,N})) at multidimensional.jl:387",
          "setindex!(B::BitArray{N},x,I_1::Union(Real,AbstractArray{T,N}),I_2::Union(Real,AbstractArray{T,N})) at multidimensional.jl:387",
          "setindex!(B::BitArray{N},x,I_1::Union(Real,AbstractArray{T,N}),I_2::Union(Real,AbstractArray{T,N}),I_3::Union(Real,AbstractArray{T,N})) at multidimensional.jl:387",
          "setindex!(B::BitArray{N},x,I_1::Union(Real,AbstractArray{T,N}),I_2::Union(Real,AbstractArray{T,N}),I_3::Union(Real,AbstractArray{T,N}),I_4::Union(Real,AbstractArray{T,N})) at multidimensional.jl:387",
          "setindex!(B::BitArray{N},x,I::Union(AbstractArray{T,N},Real)...) at cartesian.jl:100",
          "setindex!(S::SharedArray{T,N},x,I::AbstractArray{T,N}) at sharedarray.jl:216",
          "setindex!(S::SharedArray{T,N},x,I_1) at sharedarray.jl:217",
          "setindex!(S::SharedArray{T,N},x,I_1,I_2) at sharedarray.jl:217",
          "setindex!(S::SharedArray{T,N},x,I_1,I_2,I_3) at sharedarray.jl:217",
          "setindex!(S::SharedArray{T,N},x,I_1,I_2,I_3,I_4) at sharedarray.jl:217",
          "setindex!(S::SharedArray{T,N},x,I_1,I_2,I_3,I_4,I_5) at sharedarray.jl:217",
          "setindex!(S::SharedArray{T,N},x,I...) at sharedarray.jl:217",
          "setindex!(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Array{T,2},I::AbstractArray{Bool,1},J::Integer) at sparse/sparsematrix.jl:1443",
          "setindex!{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},v::AbstractArray{T,2},I::AbstractArray{T<:Integer,1},j::Integer) at sparse/sparsematrix.jl:1141",
          "setindex!{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Number,I::AbstractArray{T<:Integer,1},j::Integer) at sparse/sparsematrix.jl:1144",
          "setindex!{Tv,T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Number,I::AbstractArray{T<:Integer,1},J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1146",
          "setindex!(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Array{T,2},I::AbstractArray{Bool,1},J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1444",
          "setindex!{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Array{T,2},I::AbstractArray{T<:Integer,1},J::AbstractArray{Bool,1}) at sparse/sparsematrix.jl:1445",
          "setindex!{T<:Integer}(A::SparseMatrixCSC{Tv,Ti<:Integer},x::Array{T,2},I::AbstractArray{Bool,1},J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1446",
          "setindex!{Tv,Ti,T<:Integer}(A::SparseMatrixCSC{Tv,Ti},S::Array{T,2},I::AbstractArray{T<:Integer,1},J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1313",
          "setindex!{Tv,Ti,T<:Integer}(A::SparseMatrixCSC{Tv,Ti},v::AbstractArray{T,1},I::AbstractArray{T<:Integer,1},j::Integer) at sparse/sparsematrix.jl:1316",
          "setindex!{Tv,Ti,T<:Integer}(A::SparseMatrixCSC{Tv,Ti},B::SparseMatrixCSC{Tv,Ti},I::AbstractArray{T<:Integer,1},J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1324",
          "setindex!{Tv,Ti,T<:Integer}(A::SparseMatrixCSC{Tv,Ti},v::AbstractArray{T,1},I::AbstractArray{T<:Integer,1},J::AbstractArray{T<:Integer,1}) at sparse/sparsematrix.jl:1318",
          "setindex!(A::AbstractArray{T,1},x,i1,i2,i3...) at abstractarray.jl:448",
          "setindex!(A::AbstractArray{T,2},x,i1,i2,i3,i4...) at abstractarray.jl:454",
          "setindex!(t::AbstractArray{T,N},x) at abstractarray.jl:427",
          "setindex!(t::ObjectIdDict,v::ANY,k::ANY) at dict.jl:168",
          "setindex!{K,V}(h::Dict{K,V},v0,key0) at dict.jl:444",
          "setindex!{K}(wkh::WeakKeyDict{K,V},v,key) at dict.jl:627",
          "setindex!(::EnvHash,v,k::String) at env.jl:89",
          "setindex!{K,V}(pq::PriorityQueue{K,V},value,key) at collections.jl:220",
          "setindex!{K,V}(h::HashDict{K,V,O<:Union(Nothing,Int64)},v0,key0) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:347",
          "setindex!(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "setindex!(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "setindex!(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "setindex!(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "setindex!(t::Associative{K,V},v,k1,k2,ks...) at dict.jl:138",
          "setindex!(a::ZeroOffsetVector,x,i) at linalg/tridiag.jl:84",
          "setindex!{T}(t::Trie{T},val::T,key::String) at /home/samuel/.julia/v0.3/DataStructures/src/trie.jl:17"
        ]
      },
      {
        "name": "shift!",
        "summary": "Function",
        "help": "Base.shift!(collection) -> item\n\n   Remove the first item in a collection.\n",
        "methods": 
        [
          "shift!(a::Array{T,1}) at array.jl:531",
          "shift!(B::BitArray{1}) at bitarray.jl:572",
          "shift!(s::IntSet) at intset.jl:152",
          "shift!{T}(q::Deque{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:262"
        ]
      },
      {
        "name": "show",
        "summary": "Function",
        "help": "Base.show(x)\n\n   Write an informative text representation of a value to the current\n   output stream. New types should overload \"show(io, x)\" where the\n   first argument is a stream. The representation used by \"show\"\n   generally includes Julia-specific formatting and type information.\n",
        "methods": 
        [
          "show(io::IO,r::UnitRange{T<:Real}) at range.jl:274",
          "show{T}(io::IO,r::CalendarTimeRange{T}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:380",
          "show(io::IO,r::Range{T}) at range.jl:272",
          "show(io::IO,tv::TypeVar) at expr.jl:46",
          "show(io::IO,z::Complex{T<:Real}) at complex.jl:80",
          "show(io::IO,x::Rational{T<:Integer}) at rational.jl:31",
          "show(io::IO,s::IntSet) at intset.jl:170",
          "show(io::IO,::EnvHash) at env.jl:141",
          "show{K,V}(io::IO,t::Associative{K,V}) at dict.jl:15",
          "show(io::IO,s::Set{T}) at set.jl:10",
          "show(io::IO,c::Char) at char.jl:53",
          "show(io::IO,s::String) at string.jl:69",
          "show(io::IO,re::Regex) at regex.jl:56",
          "show(io::IO,m::RegexMatch) at regex.jl:84",
          "show(io::IO,t::Task) at task.jl:3",
          "show(io::IO,s::IOStream) at io.jl:263",
          "show(io::IO,f::Function) at show.jl:35",
          "show(io::IO,x::IntrinsicFunction) at show.jl:45",
          "show(io::IO,x::UnionType) at show.jl:49",
          "show(io::IO,x::TypeConstructor) at show.jl:58",
          "show(io::IO,x::DataType) at show.jl:61",
          "show(io::IO,tn::TypeName) at show.jl:178",
          "show(io::IO,::Nothing) at show.jl:179",
          "show(io::IO,b::Bool) at show.jl:180",
          "show(io::IO,n::Signed) at show.jl:181",
          "show(io::IO,n::Unsigned) at show.jl:182",
          "show{T}(io::IO,p::Ptr{T}) at show.jl:94",
          "show(io::IO,m::Module) at show.jl:98",
          "show(io::IO,l::LambdaStaticData) at show.jl:106",
          "show(io::IO,t::(Any...,)) at show.jl:175",
          "show(io::IO,s::Symbol) at show.jl:177",
          "show(io::IO,ex::Union(Expr,LabelNode,QuoteNode,GotoNode,SymbolNode,LineNumberNode,TopNode)) at show.jl:212",
          "show(io::IO,W::Woodbury{T}) at linalg/woodbury.jl:42",
          "show(io::IO,M::Bidiagonal{T}) at linalg/bidiag.jl:55",
          "show(io::IO,v::AbstractArray{Any,1}) at show.jl:1079",
          "show(io::IO,v::AbstractArray{T,1}) at show.jl:1080",
          "show(io::IO,X::AbstractArray{T,N}) at show.jl:1015",
          "show(io::IO,stream::Pipe) at stream.jl:166",
          "show(io::IO,stream::PipeServer) at stream.jl:168",
          "show(io::IO,stream::TTY) at stream.jl:210",
          "show(io::IO,e::UVError) at stream.jl:814",
          "show(io::IO,ip::IPv4) at socket.jl:29",
          "show(io::IO,ip::IPv6) at socket.jl:81",
          "show(io::IO,sock::TcpSocket) at socket.jl:324",
          "show(io::IO,sock::TcpServer) at socket.jl:327",
          "show(io::IO,st::StatStruct) at stat.jl:31",
          "show(io::IO,cmd::Cmd) at process.jl:33",
          "show(io::IO,cmds::OrCmds) at process.jl:51",
          "show(io::IO,cmds::AndCmds) at process.jl:69",
          "show(io::IO,cr::CmdRedirect) at process.jl:123",
          "show(io::IO,p::Process) at process.jl:614",
          "show{mime}(io::IO,::MIME{mime}) at multimedia.jl:16",
          "show(io::IO,x::Float64) at grisu.jl:114",
          "show(io::IO,x::Float32) at grisu.jl:115",
          "show(io::IO,x::Float16) at grisu.jl:116",
          "show(io::IO,m::Method) at methodshow.jl:35",
          "show(io::IO,mt::MethodTable) at methodshow.jl:74",
          "show(io::IO,cman::LocalManager) at multi.jl:1109",
          "show(io::IO,cman::SSHManager) at multi.jl:1144",
          "show(io::IO,x::BigInt) at gmp.jl:416",
          "show(io::IO,b::BigFloat) at mpfr.jl:713",
          "show(io::IO,u::UUID) at random.jl:279",
          "show(io::IO,v::VersionNumber) at version.jl:57",
          "show(io::IO,x::Prompt) at LineEdit.jl:45",
          "show(io::IO,C::Cholesky{T}) at linalg/factorization.jl:83",
          "show(io::IO,J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:14",
          "show(io::IO,f::UmfpackLU{Tv<:Union(Float64,Complex{Float64}),Ti<:Union(Int64,Int32)}) at linalg/umfpack.jl:134",
          "show(io::IO,cd::CholmodDense{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/cholmod.jl:382",
          "show(io::IO,L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:914",
          "show(io::IO,A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:915",
          "show(io::IO,info::CPUinfo) at sysinfo.jl:58",
          "show(io::IO,info::CPUinfo,header::Bool) at sysinfo.jl:58",
          "show(io::IO,info::CPUinfo,header::Bool,prefix::String) at sysinfo.jl:58",
          "show{sym}(io::IO,x::MathConst{sym}) at constants.jl:5",
          "show(io::IO,i::VersionInterval) at pkg/types.jl:13",
          "show(io::IO,s::VersionSet) at pkg/types.jl:36",
          "show(io::IO,a::Available) at pkg/types.jl:69",
          "show(io::IO,f::Fixed) at pkg/types.jl:81",
          "show(io::IO,blk::DequeBlock{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:46",
          "show(io::IO,q::Deque{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:143",
          "show(io::IO,h::MutableBinaryHeap{VT,Comp}) at /home/samuel/.julia/v0.3/DataStructures/src/heaps/mutable_binary_heap.jl:177",
          "show(io::IO,s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:18",
          "show{T}(io::IO,l::LinkedList{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:20",
          "show(io::IO,t::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:207",
          "show(io::IO,d::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:270",
          "show(io::IO,d::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:293",
          "show(io::IO,r::Response) at /home/samuel/.julia/v0.3/HttpCommon/src/HttpCommon.jl:190",
          "show(io::IO,p::Parser) at /home/samuel/.julia/v0.3/HttpParser/src/HttpParser.jl:81",
          "show(io::IO,r::Request) at /home/samuel/.julia/v0.3/HttpParser/src/HttpParser.jl:86",
          "show(io::IO,err::HttpParserError) at /home/samuel/.julia/v0.3/HttpParser/src/HttpParser.jl:134",
          "show(io::IO,uri::URI) at /home/samuel/.julia/v0.3/URIParser/src/parser.jl:296",
          "show(io::IO,dep::LibraryDependency) at /home/samuel/.julia/v0.3/BinDeps/src/dependencies.jl:30",
          "show(io::IO,x::PackageManager) at /home/samuel/.julia/v0.3/BinDeps/src/show.jl:6",
          "show(io::IO,x::SimpleBuild) at /home/samuel/.julia/v0.3/BinDeps/src/show.jl:7",
          "show(io::IO,x::Sources) at /home/samuel/.julia/v0.3/BinDeps/src/show.jl:8",
          "show(io::IO,x::Binaries) at /home/samuel/.julia/v0.3/BinDeps/src/show.jl:9",
          "show(io::IO,x::Autotools) at /home/samuel/.julia/v0.3/BinDeps/src/show.jl:10",
          "show(io::IO,err::GnuTLSException) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:45",
          "show(io::IO,c::Certificate) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:257",
          "show(io::IO,x::ANY) at show.jl:7",
          "show(x) at show.jl:2"
        ]
      },
      {
        "name": "showall",
        "summary": "Function",
        "help": "Base.showall(x)\n\n   Similar to \"show\", except shows all elements of arrays.\n",
        "methods": 
        [
          "showall(io::IO,x) at show.jl:1030",
          "showall(x) at show.jl:1028"
        ]
      },
      {
        "name": "showcompact",
        "summary": "Function",
        "help": "Base.showcompact(x)\n\n   Show a more compact representation of a value. This is used for\n   printing array elements. If a new type has a different compact\n   representation, it should overload \"showcompact(io, x)\" where the\n   first argument is a stream.\n",
        "methods": 
        [
          "showcompact(io::IO,z::Complex{T<:Real}) at complex.jl:81",
          "showcompact(io::IO,x::Float64) at grisu.jl:121",
          "showcompact(io::IO,x::Float32) at grisu.jl:122",
          "showcompact(io::IO,x::Float16) at grisu.jl:123",
          "showcompact(io::IO,b::BigFloat) at mpfr.jl:714",
          "showcompact(io::IO,x) at show.jl:71",
          "showcompact(x) at show.jl:72"
        ]
      },
      {
        "name": "showerror",
        "summary": "Function",
        "help": "Base.showerror(io, e)\n\n   Show a descriptive representation of an exception object.\n",
        "methods": 
        [
          "showerror(io::IO,e::TypeError) at replutil.jl:44",
          "showerror(io::IO,e::LoadError) at replutil.jl:72",
          "showerror(io::IO,e::LoadError,bt) at replutil.jl:74",
          "showerror(io::IO,e::DomainError,bt) at replutil.jl:79",
          "showerror(io::IO,e::SystemError) at replutil.jl:94",
          "showerror(io::IO,::DivideError) at replutil.jl:95",
          "showerror(io::IO,::StackOverflowError) at replutil.jl:96",
          "showerror(io::IO,::UndefRefError) at replutil.jl:97",
          "showerror(io::IO,e::UndefVarError) at replutil.jl:98",
          "showerror(io::IO,::EOFError) at replutil.jl:99",
          "showerror(io::IO,e::ErrorException) at replutil.jl:100",
          "showerror(io::IO,e::KeyError) at replutil.jl:101",
          "showerror(io::IO,e::InterruptException) at replutil.jl:102",
          "showerror(io::IO,e::MethodError) at replutil.jl:105",
          "showerror(io::IO,r::Error) at test.jl:29",
          "showerror(io::IO,r::Error,bt) at test.jl:31",
          "showerror(io::IO,e) at replutil.jl:41",
          "showerror(io::IO,e,bt) at replutil.jl:65"
        ]
      },
      {
        "name": "shuffle",
        "summary": "Function",
        "help": "Base.shuffle(v)\n\n   Return a randomly permuted copy of \"v\".\n",
        "methods": 
        [
          "shuffle(a::AbstractArray{T,1}) at combinatorics.jl:105"
        ]
      },
      {
        "name": "shuffle!",
        "summary": "Function",
        "help": "Base.shuffle!(v)\n\n   In-place version of \"shuffle()\".\n",
        "methods": 
        [
          "shuffle!(a::AbstractArray{T,1}) at combinatorics.jl:98"
        ]
      },
      {
        "name": "sign",
        "summary": "Function",
        "help": "Base.sign(x)\n\n   Return \"+1\" if \"x\" is positive, \"0\" if \"x == 0\", and \"-1\"\n   if \"x\" is negative.\n",
        "methods": 
        [
          "sign(x::Bool) at bool.jl:27",
          "sign(x::Rational{T<:Integer}) at rational.jl:99",
          "sign(x::Real) at number.jl:23",
          "sign(z::Complex{T<:Real}) at complex.jl:107",
          "sign(B::BitArray{N}) at bitarray.jl:820",
          "sign(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:667"
        ]
      },
      {
        "name": "signbit",
        "summary": "Function",
        "help": "Base.signbit(x)\n\n   Returns \"1\" if the value of the sign of \"x\" is negative,\n   otherwise \"0\".\n",
        "methods": 
        [
          "signbit(x::Bool) at bool.jl:26",
          "signbit(x::Unsigned) at int.jl:57",
          "signbit(x::Integer) at int.jl:56",
          "signbit(x::Rational{T<:Integer}) at rational.jl:100",
          "signbit(x::Float64) at floatfuncs.jl:15",
          "signbit(x::Float32) at floatfuncs.jl:16",
          "signbit(x::Float16) at floatfuncs.jl:17",
          "signbit(x::BigFloat) at mpfr.jl:583",
          "signbit(x::Real) at number.jl:22"
        ]
      },
      {
        "name": "signed",
        "summary": "Function",
        "help": "Base.signed(x)\n\n   Convert a number to a signed integer\n",
        "methods": 
        [
          "signed(x::FloatingPoint) at int.jl:507",
          "signed(z::Complex{T<:Real}) at complex.jl:60",
          "signed(x::Rational{T<:Integer}) at rational.jl:171",
          "signed(r::StepRange{T,S}) at abstractarray.jl:327",
          "signed(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "signed(x) at int.jl:364"
        ]
      },
      {
        "name": "signif",
        "summary": "Function",
        "help": "Base.signif(x, digits[, base])\n\n   Rounds (in the sense of \"round\") \"x\" so that there are\n   \"digits\" significant digits, under a base \"base\"\n   representation, default 10. E.g., \"signif(123.456, 2)\" is\n   \"120.0\", and \"signif(357.913, 4, 2)\" is \"352.0\".\n",
        "methods": 
        [
          "signif(x,digits::Integer) at floatfuncs.jl:71",
          "signif(x,digits::Integer,base::Integer) at floatfuncs.jl:71"
        ]
      },
      {
        "name": "significand",
        "summary": "Function",
        "help": "Base.significand(x)\n\n   Extract the significand(s) (a.k.a. mantissa), in binary\n   representation, of a floating-point number or array.\n\n   For example, \"significand(15.2)/15.2 == 0.125\", and\n   \"significand(15.2)*8 == 15.2\"\n",
        "methods": 
        [
          "significand(x::Float64) at math.jl:291",
          "significand(x::Float32) at math.jl:292",
          "significand{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "significand{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "significand{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "similar",
        "summary": "Function",
        "help": "Base.similar(array, element_type, dims)\n\n   Create an uninitialized array of the same type as the given array,\n   but with the specified element type and dimensions. The second and\n   third arguments are both optional. The \"dims\" argument may be a\n   tuple or a series of integer arguments.\n",
        "methods": 
        [
          "similar(r::Range{T},T::Type{T<:Top},dims::(Int64...,)) at range.jl:160",
          "similar(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},T,dims::(Int64...,)) at subarray.jl:189",
          "similar{T}(a::Array{T,1}) at array.jl:108",
          "similar{T}(a::Array{T,2}) at array.jl:109",
          "similar{T}(a::Array{T,1},dims::(Int64...,)) at array.jl:110",
          "similar{T}(a::Array{T,1},m::Int64) at array.jl:111",
          "similar{T}(a::Array{T,1},S) at array.jl:112",
          "similar{T}(a::Array{T,2},dims::(Int64...,)) at array.jl:113",
          "similar{T}(a::Array{T,2},m::Int64) at array.jl:114",
          "similar{T}(a::Array{T,2},S) at array.jl:115",
          "similar(a::Array{T,N},T,dims::(Int64...,)) at array.jl:107",
          "similar(B::BitArray{N}) at bitarray.jl:205",
          "similar(B::BitArray{N},dims::Int64...) at bitarray.jl:206",
          "similar(B::BitArray{N},dims::(Int64...,)) at bitarray.jl:207",
          "similar(B::BitArray{N},T::Type{Bool},dims::(Int64...,)) at bitarray.jl:209",
          "similar(B::BitArray{N},T::Type{T<:Top},dims::(Int64...,)) at bitarray.jl:212",
          "similar{T}(d::DArray{T,N,A},dims::(Int64...,)) at darray.jl:55",
          "similar(d::DArray{T,N,A},T,dims::(Int64...,)) at darray.jl:53",
          "similar(d::DArray{T,N,A},T) at darray.jl:54",
          "similar{T}(d::DArray{T,N,A}) at darray.jl:56",
          "similar(S::SharedArray{T,N},dims::(Int64...,)) at sharedarray.jl:270",
          "similar(S::SharedArray{T,N},T,dims::(Int64...,)) at sharedarray.jl:268",
          "similar(S::SharedArray{T,N},T) at sharedarray.jl:269",
          "similar(S::SharedArray{T,N}) at sharedarray.jl:271",
          "similar(S::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:130",
          "similar(S::SparseMatrixCSC{Tv,Ti<:Integer},Tv::Union(DataType,TypeConstructor,UnionType)) at sparse/sparsematrix.jl:130",
          "similar{Tv,Ti,TvNew}(S::SparseMatrixCSC{Tv,Ti},::Type{TvNew},::Type{Ti}) at sparse/sparsematrix.jl:131",
          "similar{Tv,Ti,TvNew,TiNew}(S::SparseMatrixCSC{Tv,Ti},::Type{TvNew},::Type{TiNew}) at sparse/sparsematrix.jl:132",
          "similar(S::SparseMatrixCSC{Tv,Ti<:Integer},Tv::Type{T<:Top},d::(Integer,Integer)) at sparse/sparsematrix.jl:133",
          "similar(M::Tridiagonal{T},T,dims::(Int64...,)) at linalg/tridiag.jl:176",
          "similar(W::Woodbury{T},T,dims::(Int64...,)) at linalg/woodbury.jl:60",
          "similar{T}(D::Diagonal{T},::Type{T},d::(Int64,Int64)) at linalg/diagonal.jl:13",
          "similar{T}(a::AbstractArray{T,N}) at abstractarray.jl:115",
          "similar{T}(a::AbstractArray{T,N},dims::(Int64...,)) at abstractarray.jl:117",
          "similar{T}(a::AbstractArray{T,N},dims::Int64...) at abstractarray.jl:118",
          "similar(a::AbstractArray{T,N},T) at abstractarray.jl:116",
          "similar(a::AbstractArray{T,N},T,dims::Int64...) at abstractarray.jl:119",
          "similar(s::IntSet) at intset.jl:11",
          "similar(d::ObjectIdDict) at dict.jl:165",
          "similar{K,V}(d::Dict{K,V}) at dict.jl:265",
          "similar{T}(s::Set{T}) at set.jl:26",
          "similar(::EnvHash) at env.jl:73",
          "similar{K,V,O}(d::HashDict{K,V,O}) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:52",
          "similar{K,V}(d::OrderedDict{K,V}) at /home/samuel/.julia/v0.3/DataStructures/src/ordereddict.jl:43",
          "similar{T}(s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:35",
          "similar{K,V,F}(d::DefaultDictBase{K,V,F,D<:Associative{K,V}}) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:52",
          "similar{K,V,F}(d::DefaultDict{K,V,F}) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:121",
          "similar{K,V,F}(d::DefaultOrderedDict{K,V,F}) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:121"
        ]
      },
      {
        "name": "sin",
        "summary": "Function",
        "help": "Base.sin(x)\n\n   Compute sine of \"x\", where \"x\" is in radians\n",
        "methods": 
        [
          "sin(a::Complex{Float16}) at float16.jl:134",
          "sin(z::Complex{T<:Real}) at complex.jl:511",
          "sin(x::Float64) at math.jl:277",
          "sin(x::Float32) at math.jl:278",
          "sin(a::Float16) at float16.jl:133",
          "sin(x::BigFloat) at mpfr.jl:547",
          "sin(x::Real) at math.jl:279",
          "sin{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "sin{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "sin{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "sin{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "sinc",
        "summary": "Function",
        "help": "Base.sinc(x)\n\n   Compute \\sin(\\pi x) / (\\pi x) if x \\neq 0, and 1 if x = 0.\n",
        "methods": 
        [
          "sinc(x::Integer) at math.jl:139",
          "sinc{T<:Integer}(x::Complex{T<:Integer}) at math.jl:140",
          "sinc(x::Number) at math.jl:138",
          "sinc{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:485",
          "sinc{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "sinc{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "sinc{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "sind",
        "summary": "Function",
        "help": "Base.sind(x)\n\n   Compute sine of \"x\", where \"x\" is in degrees\n",
        "methods": 
        [
          "sind(x::Real) at math.jl:172",
          "sind{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "sind{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "sind{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "sind{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "sind(z) at math.jl:231"
        ]
      },
      {
        "name": "sinh",
        "summary": "Function",
        "help": "Base.sinh(x)\n\n   Compute hyperbolic sine of \"x\"\n",
        "methods": 
        [
          "sinh(a::Complex{Float16}) at float16.jl:134",
          "sinh(z::Complex{T<:Real}) at complex.jl:585",
          "sinh(x::Float64) at math.jl:253",
          "sinh(x::Float32) at math.jl:254",
          "sinh(a::Float16) at float16.jl:133",
          "sinh(x::BigFloat) at mpfr.jl:397",
          "sinh(x::FloatingPoint) at math.jl:264",
          "sinh(x::Real) at math.jl:255",
          "sinh{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "sinh{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "sinh{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "sinh{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "sinpi",
        "summary": "Function",
        "help": "Base.sinpi(x)\n\n   Compute \\sin(\\pi x) more accurately than \"sin(pi*x)\",\n   especially for large \"x\".\n",
        "methods": 
        [
          "sinpi(x::Integer) at math.jl:104",
          "sinpi(x::Real) at math.jl:52",
          "sinpi(z::Complex{T<:Real}) at math.jl:108",
          "sinpi{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "sinpi{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "sinpi{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "sinpi{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "size",
        "summary": "Function",
        "help": "Base.size(A)\n\n   Returns a tuple containing the dimensions of A\n",
        "methods": 
        [
          "size(t::(Any...,),d) at tuple.jl:5",
          "size(r::CalendarTimeRange{T<:AbstractCalendarDuration}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:401",
          "size(r::Range{T}) at range.jl:162",
          "size(x::Number) at number.jl:6",
          "size(x::Number,d) at number.jl:7",
          "size(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)}) at subarray.jl:179",
          "size(a::Array{T,2}) at array.jl:20",
          "size(a::Array{T,N}) at array.jl:18",
          "size(a::Array{T,N},d) at array.jl:19",
          "size(B::BitArray{1}) at bitarray.jl:43",
          "size(B::BitArray{1},d) at bitarray.jl:46",
          "size(B::BitArray{N}) at bitarray.jl:44",
          "size{N}(B::BitArray{N},d) at bitarray.jl:47",
          "size(d::DArray{T,N,A}) at darray.jl:58",
          "size(S::SharedArray{T,N}) at sharedarray.jl:115",
          "size(S::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:17",
          "size(m::SymTridiagonal{T}) at linalg/tridiag.jl:26",
          "size(m::SymTridiagonal{T},d::Integer) at linalg/tridiag.jl:27",
          "size(M::Tridiagonal{T}) at linalg/tridiag.jl:160",
          "size(M::Tridiagonal{T},d::Integer) at linalg/tridiag.jl:161",
          "size(A::Union(QRPackedQ{T},QRCompactWYQ{S}),dim::Integer) at linalg/factorization.jl:235",
          "size(A::Union(QRPackedQ{T},QRCompactWYQ{S})) at linalg/factorization.jl:236",
          "size(A::HessenbergQ{T},args...) at linalg/factorization.jl:486",
          "size(A::Triangular{T<:Number},args...) at linalg/triangular.jl:84",
          "size(A::Union(Symmetric{T},Hermitian{T}),args...) at linalg/symmetric.jl:15",
          "size(W::Woodbury{T}) at linalg/woodbury.jl:39",
          "size(D::Diagonal{T}) at linalg/diagonal.jl:19",
          "size(D::Diagonal{T},d::Integer) at linalg/diagonal.jl:20",
          "size(M::Bidiagonal{T}) at linalg/bidiag.jl:62",
          "size(M::Bidiagonal{T},d::Integer) at linalg/bidiag.jl:63",
          "size(G::Givens{T}) at linalg/givens.jl:205",
          "size(G::Givens{T},i::Integer) at linalg/givens.jl:206",
          "size{T,n}(t::AbstractArray{T,n},d) at abstractarray.jl:9",
          "size(t::TTYTerminal) at Terminals.jl:159",
          "size(::TextTerminal) at Terminals.jl:46",
          "size(C::Union(Cholesky{T},CholeskyPivoted{T})) at linalg/factorization.jl:59",
          "size(C::Union(Cholesky{T},CholeskyPivoted{T}),d::Integer) at linalg/factorization.jl:60",
          "size(A::Union(QR{T},QRCompactWY{S},QRPivoted{T}),dim::Integer) at linalg/factorization.jl:233",
          "size(A::Union(QR{T},QRCompactWY{S},QRPivoted{T})) at linalg/factorization.jl:234",
          "size(A::LU{T,S<:AbstractArray{T,2}}) at linalg/lu.jl:83",
          "size(A::LU{T,S<:AbstractArray{T,2}},n) at linalg/lu.jl:84",
          "size(B::BunchKaufman{T}) at linalg/bunchkaufman.jl:27",
          "size(B::BunchKaufman{T},d::Integer) at linalg/bunchkaufman.jl:28",
          "size(S::LDLt{T,S<:AbstractArray{T,2}}) at linalg/ldlt.jl:5",
          "size(S::LDLt{T,S<:AbstractArray{T,2}},i::Integer) at linalg/ldlt.jl:6",
          "size(B::CholmodDense{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/cholmod.jl:917",
          "size(B::CholmodDense{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})},d) at linalg/cholmod.jl:918",
          "size(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:919",
          "size(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},d::Integer) at linalg/cholmod.jl:921",
          "size(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:923",
          "size(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)},d::Integer) at linalg/cholmod.jl:924"
        ]
      },
      {
        "name": "sizehint",
        "summary": "Function",
        "help": "Base.sizehint(s, n)\n\n   Suggest that collection \"s\" reserve capacity for at least \"n\"\n   elements. This can improve performance.\n",
        "methods": 
        [
          "sizehint(a::Array{T,1},sz::Integer) at array.jl:507",
          "sizehint(B::BitArray{1},sz::Integer) at bitarray.jl:514",
          "sizehint(s::IntSet,top::Integer) at intset.jl:18",
          "sizehint(d::Dict{K,V},newsz) at dict.jl:344",
          "sizehint(s::Set{T},newsz) at set.jl:29",
          "sizehint(d::HashDict{K,V,O<:Union(Nothing,Int64)},newsz) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:224",
          "sizehint(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "sizehint(::OrderedSet{T},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "sizehint(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "sizehint(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "sizehint(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11"
        ]
      },
      {
        "name": "sizeof",
        "summary": "Function",
        "help": "Base.sizeof(type)\n\n   Size, in bytes, of the canonical binary representation of the given\n   type, if any.\n\nBase.sizeof(s::String)\n\n   The number of bytes in string \"s\".\n",
        "methods": 
        [
          "sizeof(::Type{Bool}) at bool.jl:12",
          "sizeof(::Type{Int8}) at int.jl:482",
          "sizeof(::Type{Uint8}) at int.jl:483",
          "sizeof(::Type{Int16}) at int.jl:484",
          "sizeof(::Type{Uint16}) at int.jl:485",
          "sizeof(::Type{Int32}) at int.jl:486",
          "sizeof(::Type{Uint32}) at int.jl:487",
          "sizeof(::Type{Int64}) at int.jl:488",
          "sizeof(::Type{Uint64}) at int.jl:489",
          "sizeof(::Type{Int128}) at int.jl:490",
          "sizeof(::Type{Uint128}) at int.jl:491",
          "sizeof(::Type{Symbol}) at operators.jl:164",
          "sizeof{T<:Array{T,N}}(::Type{T<:Array{T,N}}) at operators.jl:165",
          "sizeof{T<:Ptr{T}}(::Type{T<:Ptr{T}}) at pointer.jl:60",
          "sizeof(::Type{Float16}) at float.jl:298",
          "sizeof(::Type{Float32}) at float.jl:299",
          "sizeof(::Type{Float64}) at float.jl:300",
          "sizeof{T<:Real}(::Type{Complex{T<:Real}}) at complex.jl:14",
          "sizeof(::Type{Char}) at char.jl:48",
          "sizeof(T::DataType) at operators.jl:163",
          "sizeof(T::Type{T<:Top}) at operators.jl:162",
          "sizeof(a::Array{T,N}) at array.jl:23",
          "sizeof(s::ASCIIString) at ascii.jl:15",
          "sizeof(s::UTF8String) at utf8.jl:93",
          "sizeof(s::UTF16String) at utf16.jl:48",
          "sizeof(s::UTF32String) at string.jl:587",
          "sizeof{T<:Union(UTF8String,ASCIIString)}(s::SubString{T<:Union(UTF8String,ASCIIString)}) at string.jl:624",
          "sizeof(s::RepString) at string.jl:694",
          "sizeof(s::RevString{T<:String}) at string.jl:734",
          "sizeof(s::RopeString) at string.jl:791",
          "sizeof(s::String) at string.jl:71",
          "sizeof(x) at operators.jl:166"
        ]
      },
      {
        "name": "skip",
        "summary": "Function",
        "help": "Base.skip(s, offset)\n\n   Seek a stream relative to the current position.\n",
        "methods": 
        [
          "skip(io::IOBuffer,n::Integer) at iobuffer.jl:99",
          "skip(s::IOStream,delta::Integer) at io.jl:298"
        ]
      },
      {
        "name": "skipchars",
        "summary": "Function",
        "help": "Base.skipchars(stream, predicate; linecomment::Char)\n\n   Advance the stream until before the first character for which\n   \"predicate\" returns false. For example \"skipchars(stream,\n   isspace)\" will skip all whitespace. If keyword argument\n   \"linecomment\" is specified, characters from that character\n   through the end of a line will also be skipped.\n",
        "methods": 
        [
          "skipchars(s::IOStream,pred) at io.jl:542"
        ]
      },
      {
        "name": "sleep",
        "summary": "Function",
        "help": "Base.sleep(seconds)\n\n   Block the current task for a specified number of seconds.\n",
        "methods": 
        [
          "sleep(sec::Real) at stream.jl:494"
        ]
      },
      {
        "name": "slice",
        "summary": "Function",
        "help": "Base.slice(A, inds...)\n\n   Create a view of the given indexes of array \"A\", dropping\n   dimensions indexed with scalars.\n",
        "methods": 
        [
          "slice{T,N}(A::AbstractArray{T,N},i::NTuple{N,Union(Range{Int64},Int64)}) at subarray.jl:108",
          "slice{T,N,M}(A::AbstractArray{T,N},i::NTuple{M,Union(Range{Int64},Int64)}) at subarray.jl:111",
          "slice(A::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Union(Range{Int64},Int64)...) at subarray.jl:116",
          "slice(A::AbstractArray{T,N},i::Union(Range{Int64},Int64)...) at subarray.jl:113",
          "slice(A::AbstractArray{T,N},I::Union(Range{Int64},Colon,Int64)...) at subarray.jl:132"
        ]
      },
      {
        "name": "slicedim",
        "summary": "Function",
        "help": "Base.slicedim(A, d, i)\n\n   Return all the data of \"A\" where the index for dimension \"d\"\n   equals \"i\". Equivalent to \"A[:,:,...,i,:,:,...]\" where \"i\" is\n   in position \"d\".\n",
        "methods": 
        [
          "slicedim(A::Array{T,N},d::Integer,i::Integer) at array.jl:838",
          "slicedim(A::BitArray{N},d::Integer,i::Integer) at bitarray.jl:1075",
          "slicedim(A::AbstractArray{T,N},d::Integer,i) at abstractarray.jl:373"
        ]
      },
      {
        "name": "sort",
        "summary": "Function",
        "help": "Base.sort(v, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Variant of \"sort!\" that returns a sorted copy of \"v\" leaving\n   \"v\" itself unmodified.\n\nBase.sort(A, dim, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Sort a multidimensional array \"A\" along the given dimension.\n",
        "methods": 
        [
          "sort(r::UnitRange{T<:Real}) at range.jl:496",
          "sort{T<:Real}(r::Range{T<:Real}) at range.jl:499",
          "sort(v::AbstractArray{T,1}) at sort.jl:334",
          "sort(v::AbstractArray{T,1},d::Integer,o::Ordering) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},d::Integer,a::Algorithm) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},d::Integer,a::Algorithm,o::Ordering) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},d::Integer,o::Ordering,a::Algorithm) at deprecated.jl:26",
          "sort(A::AbstractArray{T,N},dim::Integer) at sort.jl:344",
          "sort(v::AbstractArray{T,1},o::Ordering) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},a::Algorithm,o::Ordering) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},o::Ordering,a::Algorithm) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},f::Function) at deprecated.jl:26",
          "sort(f::Function,v::AbstractArray{T,1}) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},a::Algorithm,f::Function) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},f::Function,a::Algorithm) at deprecated.jl:26",
          "sort(f::Function,v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26"
        ]
      },
      {
        "name": "sort!",
        "summary": "Function",
        "help": "Base.sort!(v, [dim,] [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Sort the vector \"v\" in place. \"QuickSort\" is used by default\n   for numeric arrays while \"MergeSort\" is used for other arrays.\n   You can specify an algorithm to use via the \"alg\" keyword (see\n   Sorting Algorithms for available algorithms). The \"by\" keyword\n   lets you provide a function that will be applied to each element\n   before comparison; the \"lt\" keyword allows providing a custom\n   \"less than\" function; use \"rev=true\" to reverse the sorting\n   order. These options are independent and can be used together in\n   all possible combinations: if both \"by\" and \"lt\" are specified,\n   the \"lt\" function is applied to the result of the \"by\"\n   function; \"rev=true\" reverses whatever ordering specified via the\n   \"by\" and \"lt\" keywords.\n",
        "methods": 
        [
          "sort!(r::UnitRange{T<:Real}) at range.jl:497",
          "sort!(v::AbstractArray{T,1},lo::Int64,hi::Int64,::InsertionSortAlg,o::Ordering) at sort.jl:242",
          "sort!(v::AbstractArray{T,1},lo::Int64,hi::Int64,a::QuickSortAlg,o::Ordering) at sort.jl:259",
          "sort!(v::AbstractArray{T,1},lo::Int64,hi::Int64,a::MergeSortAlg,o::Ordering) at sort.jl:289",
          "sort!(v::AbstractArray{T,1},lo::Int64,hi::Int64,a::MergeSortAlg,o::Ordering,t) at sort.jl:289",
          "sort!{T<:Union(Float64,Float32)}(v::AbstractArray{T<:Union(Float64,Float32),1},a::Algorithm,o::Union(ForwardOrdering,ReverseOrdering{ForwardOrdering})) at sort.jl:441",
          "sort!{O<:Union(ForwardOrdering,ReverseOrdering{ForwardOrdering}),T<:Union(Float64,Float32)}(v::Array{Int64,1},a::Algorithm,o::Perm{O<:Union(ForwardOrdering,ReverseOrdering{ForwardOrdering}),Array{T<:Union(Float64,Float32),1}}) at sort.jl:442",
          "sort!(v::AbstractArray{T,1},alg::Algorithm,order::Ordering) at sort.jl:329",
          "sort!(v::AbstractArray{T,1}) at sort.jl:330",
          "sort!{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:809",
          "sort!{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:809",
          "sort!(v::AbstractArray{T,1},o::Ordering) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},o::Ordering,a::Algorithm) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},f::Function) at deprecated.jl:26",
          "sort!(f::Function,v::AbstractArray{T,1}) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},a::Algorithm,f::Function) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},f::Function,a::Algorithm) at deprecated.jl:26",
          "sort!(f::Function,v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},d::Integer,o::Ordering) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},d::Integer,a::Algorithm) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},d::Integer,a::Algorithm,o::Ordering) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},d::Integer,o::Ordering,a::Algorithm) at deprecated.jl:26"
        ]
      },
      {
        "name": "sortby",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "sortby(v::AbstractArray{T,1},f::Function) at deprecated.jl:26",
          "sortby(f::Function,v::AbstractArray{T,1}) at deprecated.jl:26",
          "sortby(v::AbstractArray{T,1},a::Algorithm,f::Function) at deprecated.jl:26",
          "sortby(v::AbstractArray{T,1},f::Function,a::Algorithm) at deprecated.jl:26",
          "sortby(f::Function,v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26"
        ]
      },
      {
        "name": "sortby!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "sortby!(v::AbstractArray{T,1},f::Function) at deprecated.jl:26",
          "sortby!(f::Function,v::AbstractArray{T,1}) at deprecated.jl:26",
          "sortby!(v::AbstractArray{T,1},a::Algorithm,f::Function) at deprecated.jl:26",
          "sortby!(v::AbstractArray{T,1},f::Function,a::Algorithm) at deprecated.jl:26",
          "sortby!(f::Function,v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26"
        ]
      },
      {
        "name": "sortcols",
        "summary": "Function",
        "help": "Base.sortcols(A, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Sort the columns of matrix \"A\" lexicographically.\n",
        "methods": 
        [
          "sortcols(A::AbstractArray{T,2}) at sort.jl:354",
          "sortcols(v::AbstractArray{T,2},o::Ordering) at deprecated.jl:26",
          "sortcols(v::AbstractArray{T,2},a::Algorithm) at deprecated.jl:26",
          "sortcols(v::AbstractArray{T,2},a::Algorithm,o::Ordering) at deprecated.jl:26",
          "sortcols(v::AbstractArray{T,2},o::Ordering,a::Algorithm) at deprecated.jl:26"
        ]
      },
      {
        "name": "sortperm",
        "summary": "Function",
        "help": "Base.sortperm(v, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Return a permutation vector of indices of \"v\" that puts it in\n   sorted order. Specify \"alg\" to choose a particular sorting\n   algorithm (see Sorting Algorithms). \"MergeSort\" is used by\n   default, and since it is stable, the resulting permutation will be\n   the lexicographically first one that puts the input array into\n   sorted order – i.e. indices of equal elements appear in ascending\n   order. If you choose a non-stable sorting algorithm such as\n   \"QuickSort\", a different permutation that puts the array into\n   order may be returned. The order is specified using the same\n   keywords as \"sort!\".\n",
        "methods": 
        [
          "sortperm(r::UnitRange{T<:Real}) at range.jl:501",
          "sortperm{T<:Real}(r::Range{T<:Real}) at range.jl:502",
          "sortperm(v::AbstractArray{T,1}) at sort.jl:338",
          "sortperm(v::AbstractArray{T,1},o::Ordering) at deprecated.jl:26",
          "sortperm(v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26",
          "sortperm(v::AbstractArray{T,1},a::Algorithm,o::Ordering) at deprecated.jl:26",
          "sortperm(v::AbstractArray{T,1},o::Ordering,a::Algorithm) at deprecated.jl:26",
          "sortperm(v::AbstractArray{T,1},f::Function) at deprecated.jl:26",
          "sortperm(f::Function,v::AbstractArray{T,1}) at deprecated.jl:26",
          "sortperm(v::AbstractArray{T,1},a::Algorithm,f::Function) at deprecated.jl:26",
          "sortperm(v::AbstractArray{T,1},f::Function,a::Algorithm) at deprecated.jl:26",
          "sortperm(f::Function,v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26"
        ]
      },
      {
        "name": "sortrows",
        "summary": "Function",
        "help": "Base.sortrows(A, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Sort the rows of matrix \"A\" lexicographically.\n",
        "methods": 
        [
          "sortrows(A::AbstractArray{T,2}) at sort.jl:347",
          "sortrows(v::AbstractArray{T,2},o::Ordering) at deprecated.jl:26",
          "sortrows(v::AbstractArray{T,2},a::Algorithm) at deprecated.jl:26",
          "sortrows(v::AbstractArray{T,2},a::Algorithm,o::Ordering) at deprecated.jl:26",
          "sortrows(v::AbstractArray{T,2},o::Ordering,a::Algorithm) at deprecated.jl:26"
        ]
      },
      {
        "name": "sparse",
        "summary": "Function",
        "help": "Base.sparse(I, J, V[, m, n, combine])\n\n   Create a sparse matrix \"S\" of dimensions \"m x n\" such that\n   \"S[I[k], J[k]] = V[k]\". The \"combine\" function is used to\n   combine duplicates. If \"m\" and \"n\" are not specified, they are\n   set to \"max(I)\" and \"max(J)\" respectively. If the \"combine\"\n   function is not supplied, duplicates are added by default.\n\nBase.sparse(A)\n\n   Convert a dense matrix \"A\" into a sparse matrix.\n",
        "methods": 
        [
          "sparse(a::Array{T,1}) at sparse/sparsematrix.jl:210",
          "sparse{Tv}(A::Array{Tv,2}) at sparse/sparsematrix.jl:214",
          "sparse(S::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:216",
          "sparse(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:1026",
          "sparse(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:1032",
          "sparse(D::CholmodDense{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/cholmod.jl:1033",
          "sparse(T::CholmodTriplet{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:1034",
          "sparse(I,J,v::Number) at sparse/sparsematrix.jl:271",
          "sparse(I,J,V::AbstractArray{Bool,1},m,n) at sparse/sparsematrix.jl:279",
          "sparse{Tv,Ti<:Integer}(I::AbstractArray{Ti<:Integer,1},J::AbstractArray{Ti<:Integer,1},V::AbstractArray{Tv,1},nrow::Integer,ncol::Integer,combine::Function) at sparse/csparse.jl:19",
          "sparse(I,J,V::AbstractArray{T,1}) at sparse/sparsematrix.jl:273",
          "sparse(I,J,v::Number,m,n) at sparse/sparsematrix.jl:275",
          "sparse(I,J,V::AbstractArray{T,1},m,n) at sparse/sparsematrix.jl:277",
          "sparse(I,J,v::Number,m,n,combine::Function) at sparse/sparsematrix.jl:281"
        ]
      },
      {
        "name": "sparsevec",
        "summary": "Function",
        "help": "Base.sparsevec(I, V[, m, combine])\n\n   Create a sparse matrix \"S\" of size \"m x 1\" such that \"S[I[k]]\n   = V[k]\". Duplicates are combined using the \"combine\" function,\n   which defaults to \"+\" if it is not provided. In julia, sparse\n   vectors are really just sparse matrices with one column. Given\n   Julia's Compressed Sparse Columns (CSC) storage format, a sparse\n   column matrix with one column is sparse, whereas a sparse row\n   matrix with one row ends up being dense.\n\nBase.sparsevec(D::Dict[, m])\n\n   Create a sparse matrix of size \"m x 1\" where the row values are\n   keys from the dictionary, and the nonzero values are the values\n   from the dictionary.\n\nBase.sparsevec(A)\n\n   Convert a dense vector \"A\" into a sparse matrix of size \"m x\n   1\". In julia, sparse vectors are really just sparse matrices with\n   one column.\n",
        "methods": 
        [
          "sparsevec{K<:Integer,V}(d::Dict{K<:Integer,V},len::Int64) at sparse/sparsematrix.jl:184",
          "sparsevec{K<:Integer,V}(d::Dict{K<:Integer,V}) at sparse/sparsematrix.jl:186",
          "sparsevec(a::Array{T,1}) at sparse/sparsematrix.jl:203",
          "sparsevec(I::AbstractArray{T,1},V,m::Integer) at sparse/sparsematrix.jl:188",
          "sparsevec(I::AbstractArray{T,1},V) at sparse/sparsematrix.jl:190",
          "sparsevec(I::AbstractArray{T,1},V,m::Integer,combine::Function) at sparse/sparsematrix.jl:193"
        ]
      },
      {
        "name": "spawn",
        "summary": "Function",
        "help": "Base.spawn(command)\n\n   Run a command object asynchronously, returning the resulting\n   \"Process\" object.\n",
        "methods": 
        [
          "spawn(pc::Union(ProcessChain,Bool),redirect::CmdRedirect,stdios::(Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect),Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect),Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect)),exitcb::Union(Function,Bool),closecb::Union(Function,Bool)) at process.jl:244",
          "spawn(pc::Union(ProcessChain,Bool),cmds::OrCmds,stdios::(Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect),Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect),Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect)),exitcb::Union(Function,Bool),closecb::Union(Function,Bool)) at process.jl:250",
          "spawn(pc::Union(ProcessChain,Bool),cmds::ErrOrCmds,stdios::(Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect),Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect),Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect)),exitcb::Union(Function,Bool),closecb::Union(Function,Bool)) at process.jl:272",
          "spawn(pc::Union(ProcessChain,Bool),cmd::Cmd,stdios::(Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect),Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect),Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect)),exitcb::Union(Function,Bool),closecb::Union(Function,Bool)) at process.jl:342",
          "spawn(pc::Union(ProcessChain,Bool),cmds::AndCmds,stdios::(Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect),Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect),Union(AsyncStream,File,RawFD,IOStream,Ptr{None},FileRedirect)),exitcb::Union(Function,Bool),closecb::Union(Function,Bool)) at process.jl:358",
          "spawn(pc::Union(ProcessChain,Bool),cmds::AbstractCmd,args...) at process.jl:388",
          "spawn(cmds::AbstractCmd,args...) at process.jl:389"
        ]
      },
      {
        "name": "spdiagm",
        "summary": "Function",
        "help": "Base.spdiagm(B, d[, m, n])\n\n   Construct a sparse diagonal matrix. \"B\" is a tuple of vectors\n   containing the diagonals and \"d\" is a tuple containing the\n   positions of the diagonals. In the case the input contains only one\n   diagonaly, \"B\" can be a vector (instead of a tuple) and \"d\" can\n   be the diagonal position (instead of a tuple), defaulting to 0\n   (diagonal). Optionally, \"m\" and \"n\" specify the size of the\n   resulting sparse matrix.\n",
        "methods": 
        [
          "spdiagm(B::AbstractArray{T,1},d::Number,m::Integer,n::Integer) at sparse/sparsematrix.jl:1661",
          "spdiagm(B::AbstractArray{T,1}) at sparse/sparsematrix.jl:1663",
          "spdiagm(B::AbstractArray{T,1},d::Number) at sparse/sparsematrix.jl:1663",
          "spdiagm(B,d,m::Integer,n::Integer) at sparse/sparsematrix.jl:1652",
          "spdiagm(B,d) at sparse/sparsematrix.jl:1657"
        ]
      },
      {
        "name": "speye",
        "summary": "Function",
        "help": "Base.speye(type, m[, n])\n\n   Create a sparse identity matrix of specified type of size \"m x\n   m\". In case \"n\" is supplied, create a sparse identity matrix of\n   size \"m x n\".\n",
        "methods": 
        [
          "speye(n::Integer) at sparse/sparsematrix.jl:393",
          "speye(T::Type{T<:Top},n::Integer) at sparse/sparsematrix.jl:394",
          "speye(m::Integer,n::Integer) at sparse/sparsematrix.jl:395",
          "speye{T}(S::SparseMatrixCSC{T,Ti<:Integer}) at sparse/sparsematrix.jl:396",
          "speye(T::Type{T<:Top},m::Integer,n::Integer) at sparse/sparsematrix.jl:400"
        ]
      },
      {
        "name": "splice!",
        "summary": "Function",
        "help": "Base.splice!(collection, index[, replacement]) -> item\n\n   Remove the item at the given index, and return the removed item.\n   Subsequent items are shifted down to fill the resulting gap. If\n   specified, replacement values from an ordered collection will be\n   spliced in place of the removed item.\n\nBase.splice!(collection, range[, replacement]) -> items\n\n   Remove items in the specified index range, and return a collection\n   containing the removed items. Subsequent items are shifted down to\n   fill the resulting gap. If specified, replacement values from an\n   ordered collection will be spliced in place of the removed items.\n",
        "methods": 
        [
          "splice!(a::Array{T,1},i::Integer) at array.jl:600",
          "splice!(a::Array{T,1},i::Integer,ins::AbstractArray{T,N}) at array.jl:600",
          "splice!{T<:Integer}(a::Array{T,1},r::UnitRange{T<:Integer}) at array.jl:616",
          "splice!{T<:Integer}(a::Array{T,1},r::UnitRange{T<:Integer},ins::AbstractArray{T,N}) at array.jl:616",
          "splice!(B::BitArray{1},i::Integer) at bitarray.jl:728",
          "splice!(B::BitArray{1},r::Union(UnitRange{Int64},Integer)) at bitarray.jl:739",
          "splice!(B::BitArray{1},r::Union(UnitRange{Int64},Integer),ins::BitArray{1}) at bitarray.jl:739",
          "splice!(B::BitArray{1},r::Union(UnitRange{Int64},Integer),ins::AbstractArray{Bool,1}) at bitarray.jl:776"
        ]
      },
      {
        "name": "split",
        "summary": "Function",
        "help": "Base.split(string, [chars, [limit,] [include_empty]])\n\n   Return an array of substrings by splitting the given string on\n   occurrences of the given character delimiters, which may be\n   specified in any of the formats allowed by \"search\"'s second\n   argument (i.e. a single character, collection of characters,\n   string, or regular expression). If \"chars\" is omitted, it\n   defaults to the set of all space characters, and \"include_empty\"\n   is taken to be false. The last two arguments are also optional:\n   they are are a maximum size for the result and a flag determining\n   whether empty fields should be included in the result.\n",
        "methods": 
        [
          "split{T<:SubString{T<:String}}(str::T<:SubString{T<:String},splitter,limit::Integer,keep_empty::Bool) at string.jl:1278",
          "split(s::String,spl,keep::Bool) at string.jl:1302",
          "split{T<:String}(str::T<:String,splitter,limit::Integer,keep_empty::Bool) at string.jl:1279",
          "split(s::String,spl,n::Integer) at string.jl:1301",
          "split(s::String,spl) at string.jl:1303",
          "split(str::String) at string.jl:1307"
        ]
      },
      {
        "name": "splitdir",
        "summary": "Function",
        "help": "Base.splitdir(path::String) -> (String, String)\n\n   Split a path into a tuple of the directory name and file name.\n",
        "methods": 
        [
          "splitdir(path::Union(UTF8String,ASCIIString)) at path.jl:31",
          "splitdir(path::String) at path.jl:37"
        ]
      },
      {
        "name": "splitdrive",
        "summary": "Function",
        "help": "Base.splitdrive(path::String) -> (String, String)\n\n   On Windows, split a path into the drive letter part and the path\n   part. On Unix systems, the first component is always the empty\n   string.\n",
        "methods": 
        [
          "splitdrive(path::String) at path.jl:9"
        ]
      },
      {
        "name": "splitext",
        "summary": "Function",
        "help": "Base.splitext(path::String) -> (String, String)\n\n   If the last component of a path contains a dot, split the path into\n   everything before the dot and everything including and after the\n   dot. Otherwise, return a tuple of the argument unmodified and the\n   empty string.\n",
        "methods": 
        [
          "splitext(path::String) at path.jl:43"
        ]
      },
      {
        "name": "spones",
        "summary": "Function",
        "help": "Base.spones(S)\n\n   Create a sparse matrix with the same structure as that of \"S\",\n   but with every nonzero element having the value \"1.0\".\n",
        "methods": 
        [
          "spones{T}(S::SparseMatrixCSC{T,Ti<:Integer}) at sparse/sparsematrix.jl:384"
        ]
      },
      {
        "name": "sprand",
        "summary": "Function",
        "help": "Base.sprand(m, n, p[, rng])\n\n   Create a random \"m\" by \"n\" sparse matrix, in which the\n   probability of any element being nonzero is independently given by\n   \"p\" (and hence the mean density of nonzeros is also exactly\n   \"p\"). Nonzero values are sampled from the distribution specified\n   by \"rng\". The uniform distribution is used in case \"rng\" is not\n   specified.\n",
        "methods": 
        [
          "sprand(m::Integer,n::Integer,density::FloatingPoint,rng::Function) at sparse/sparsematrix.jl:342",
          "sprand{T}(m::Integer,n::Integer,density::FloatingPoint,rng::Function,::Type{T}) at sparse/sparsematrix.jl:342",
          "sprand(m::Integer,n::Integer,density::FloatingPoint) at sparse/sparsematrix.jl:379"
        ]
      },
      {
        "name": "sprandbool",
        "summary": "Function",
        "help": "Base.sprandbool(m, n, p)\n\n   Create a random \"m\" by \"n\" sparse boolean matrix with the\n   specified (independent) probability \"p\" of any entry being\n   \"true\".\n",
        "methods": 
        [
          "sprandbool(m::Integer,n::Integer,density::FloatingPoint) at sparse/sparsematrix.jl:382"
        ]
      },
      {
        "name": "sprandn",
        "summary": "Function",
        "help": "Base.sprandn(m, n, p)\n\n   Create a random \"m\" by \"n\" sparse matrix with the specified\n   (independent) probability \"p\" of any entry being nonzero, where\n   nonzero values are sampled from the normal distribution.\n",
        "methods": 
        [
          "sprandn(m::Integer,n::Integer,density::FloatingPoint) at sparse/sparsematrix.jl:380"
        ]
      },
      {
        "name": "sprint",
        "summary": "Function",
        "help": "Base.sprint(f::Function, args...)\n\n   Call the given function with an I/O stream and the supplied extra\n   arguments. Everything written to this I/O stream is returned as a\n   string.\n",
        "methods": 
        [
          "sprint(size::Integer,f::Function,args...) at io.jl:463",
          "sprint(f::Function,args...) at io.jl:469"
        ]
      },
      {
        "name": "spzeros",
        "summary": "Function",
        "help": "Base.spzeros(m, n)\n\n   Create an empty sparse matrix of size \"m x n\".\n",
        "methods": 
        [
          "spzeros(m::Integer,n::Integer) at sparse/sparsematrix.jl:387",
          "spzeros(Tv::Type{T<:Top},m::Integer,n::Integer) at sparse/sparsematrix.jl:388",
          "spzeros(Tv::Type{T<:Top},Ti::Type{T<:Top},m::Integer,n::Integer) at sparse/sparsematrix.jl:390",
          "spzeros(m::Integer) at deprecated.jl:26",
          "spzeros(Tv::Type{T<:Top},m::Integer) at deprecated.jl:26"
        ]
      },
      {
        "name": "sqrt",
        "summary": "Function",
        "help": "Base.sqrt(x)\n\n   Return \\sqrt{x}. Throws \"DomainError\" for negative \"Real\"\n   arguments. Use complex negative arguments instead. The prefix\n   operator \"√\" is equivalent to \"sqrt\".\n",
        "methods": 
        [
          "sqrt(a::Complex{Float16}) at float16.jl:134",
          "sqrt{T<:FloatingPoint}(z::Complex{T<:FloatingPoint}) at complex.jl:237",
          "sqrt(z::Complex{T<:Real}) at complex.jl:261",
          "sqrt(x::Float64) at math.jl:284",
          "sqrt(x::Float32) at math.jl:285",
          "sqrt(a::Float16) at float16.jl:133",
          "sqrt(x::BigFloat) at mpfr.jl:362",
          "sqrt(x::BigInt) at mpfr.jl:370",
          "sqrt(x::Real) at math.jl:286",
          "sqrt{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "sqrt{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "sqrt{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "sqrtm",
        "summary": "Function",
        "help": "Base.sqrtm(A)\n\n   Compute the matrix square root of \"A\". If \"B = sqrtm(A)\", then\n   \"B*B == A\" within roundoff error.\n\n   \"sqrtm\" uses a polyalgorithm, computing the matrix square root\n   using Schur factorizations (\"schurfact()\") unless it detects the\n   matrix to be Hermitian or real symmetric, in which case it computes\n   the matrix square root from an eigendecomposition (\"eigfact()\").\n   In the latter situation for positive definite matrices, the matrix\n   square root has \"Real\" elements, otherwise it has \"Complex\"\n   elements.\n",
        "methods": 
        [
          "sqrtm{T<:Real}(A::Union(SubArray{T<:Real,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Real,2})) at linalg/dense.jl:301",
          "sqrtm{T<:Complex{T<:Real}}(A::Union(SubArray{T<:Complex{T<:Real},2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Complex{T<:Real},2})) at linalg/dense.jl:309",
          "sqrtm(a::Complex{T<:Real}) at linalg/dense.jl:316",
          "sqrtm(a::Number) at linalg/dense.jl:315",
          "sqrtm{T}(A::Triangular{T}) at linalg/triangular.jl:118",
          "sqrtm{T<:Real}(A::Union(Hermitian{Complex{T<:Real}},Symmetric{T<:Real},Hermitian{T<:Real})) at linalg/symmetric.jl:65",
          "sqrtm(D::Diagonal{T}) at linalg/diagonal.jl:89"
        ]
      },
      {
        "name": "square",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "square(x::Number) at deprecated.jl:26"
        ]
      },
      {
        "name": "squeeze",
        "summary": "Function",
        "help": "Base.squeeze(A, dims)\n\n   Remove the dimensions specified by \"dims\" from array \"A\"\n",
        "methods": 
        [
          "squeeze(A::AbstractArray{T,N},dims) at abstractarray.jl:133"
        ]
      },
      {
        "name": "srand",
        "summary": "Function",
        "help": "Base.srand([rng], seed)\n\n   Seed the RNG with a \"seed\", which may be an unsigned integer or a\n   vector of unsigned integers. \"seed\" can even be a filename, in\n   which case the seed is read from a file. If the argument \"rng\" is\n   not provided, the default global RNG is seeded.\n",
        "methods": 
        [
          "srand(r::MersenneTwister,seed) at random.jl:27",
          "srand(seed::Array{Uint32,1}) at random.jl:60",
          "srand(n::Integer) at random.jl:63",
          "srand(filename::String,n::Integer) at random.jl:78",
          "srand(filename::String) at random.jl:84"
        ]
      },
      {
        "name": "start",
        "summary": "Function",
        "help": "Base.start(iter) -> state\n\n   Get initial iteration state for an iterable object\n",
        "methods": 
        [
          "start(mt::MethodTable) at reflection.jl:123",
          "start(t::(Any...,)) at tuple.jl:13",
          "start(r::FloatRange{T<:FloatingPoint}) at range.jl:215",
          "start(r::StepRange{T,S}) at range.jl:221",
          "start(r::UnitRange{T<:Real}) at range.jl:225",
          "start(x::Number) at number.jl:36",
          "start(B::BitArray{N}) at bitarray.jl:199",
          "start(r::CalendarTimeRange{T<:AbstractCalendarDuration}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:404",
          "start(a::AbstractArray{T,N}) at abstractarray.jl:245",
          "start(s::IntSet) at intset.jl:130",
          "start(v::Union(ValueIterator{T<:Associative{K,V}},KeyIterator{T<:Associative{K,V}})) at dict.jl:48",
          "start(t::ObjectIdDict) at dict.jl:190",
          "start(t::Dict{K,V}) at dict.jl:574",
          "start(t::WeakKeyDict{K,V}) at dict.jl:649",
          "start(s::Set{T}) at set.jl:32",
          "start(e::Enumerate{I}) at iterator.jl:11",
          "start(z::Zip{I<:(Any...,)}) at iterator.jl:31",
          "start(z::Zip2{I1,I2}) at iterator.jl:55",
          "start(f::Filter{I}) at iterator.jl:70",
          "start(i::Rest{I,S}) at iterator.jl:107",
          "start(s::String) at string.jl:55",
          "start(itr::RegexMatchIterator) at regex.jl:194",
          "start(::EnvHash) at env.jl:93",
          "start(t::Task) at task.jl:165",
          "start(itr::EachLine) at io.jl:225",
          "start(pq::PriorityQueue{K,V}) at collections.jl:270",
          "start(c::Combinations{T}) at combinatorics.jl:250",
          "start(p::Permutations{T}) at combinatorics.jl:284",
          "start(p::IntegerPartitions) at combinatorics.jl:317",
          "start(f::FixedPartitions) at combinatorics.jl:383",
          "start(p::SetPartitions{T<:AbstractArray{T,1}}) at combinatorics.jl:441",
          "start(p::FixedSetPartitions{T<:AbstractArray{T,1}}) at combinatorics.jl:508",
          "start(d::SpDiagIterator{Tv,Ti}) at sparse/sparsematrix.jl:1682",
          "start{T}(q::Deque{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:105",
          "start(ct::Accumulator{T,V<:Number}) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:38",
          "start(cc::ClassifiedCollections{K,Collection}) at /home/samuel/.julia/v0.3/DataStructures/src/classifiedcollections.jl:37",
          "start(t::HashDict{K,V,O<:Union(Nothing,Int64)}) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:486",
          "start(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "start(s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:40",
          "start(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "start(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "start(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "start{T}(l::Nil{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:124",
          "start{T}(l::Cons{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:125",
          "start(it::Count{S<:Number}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:35",
          "start(it::Take{I}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:52",
          "start(it::Drop{I}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:78",
          "start(it::Cycle{I}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:104",
          "start(it::Repeat{O}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:133",
          "start(it::RepeatForever{O}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:148",
          "start(it::Chain) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:174",
          "start(it::Product) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:217",
          "start(it::Distinct{I}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:275",
          "start(it::Partition{I}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:326",
          "start(it::GroupBy{I}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:392",
          "start(it::IMap) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:442",
          "start(it::Subsets) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:473",
          "start(it::Iterate{T}) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:510"
        ]
      },
      {
        "name": "start_reading",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "start_reading(stream::AsyncStream) at stream.jl:597",
          "start_reading(stream::AsyncStream,cb::Function) at stream.jl:612",
          "start_reading(stream::AsyncStream,cb::Bool) at stream.jl:620",
          "start_reading(t::UnixTerminal) at Terminals.jl:182"
        ]
      },
      {
        "name": "start_timer",
        "summary": "Function",
        "help": "Base.start_timer(t::Timer, delay, repeat)\n\n   Start invoking the callback for a \"Timer\" after the specified\n   initial delay, and then repeating with the given interval. Times\n   are in seconds. If \"repeat\" is \"0\", the timer is only triggered\n   once.\n",
        "methods": 
        [
          "start_timer(timer::Timer,timeout::Int64,repeat::Int64) at deprecated.jl:211",
          "start_timer(timer::Timer,timeout::Real,repeat::Real) at stream.jl:476"
        ]
      },
      {
        "name": "start_watching",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "start_watching(t::FDWatcher,events::FDEvent) at poll.jl:239",
          "start_watching(f::Function,t::FDWatcher,events::FDEvent) at poll.jl:247",
          "start_watching(t::PollingFileWatcher,interval) at poll.jl:250",
          "start_watching(f::Function,t::PollingFileWatcher,interval) at poll.jl:255"
        ]
      },
      {
        "name": "stat",
        "summary": "Function",
        "help": "Base.stat(file)\n\n   Returns a structure whose fields contain information about the\n   file. The fields of the structure are:\n\n   +-----------+------------------------------------------------------------------------+\n   | size      | The size (in bytes) of the file                                        |\n   +-----------+------------------------------------------------------------------------+\n   | device    | ID of the device that contains the file                                |\n   +-----------+------------------------------------------------------------------------+\n   | inode     | The inode number of the file                                           |\n   +-----------+------------------------------------------------------------------------+\n   | mode      | The protection mode of the file                                        |\n   +-----------+------------------------------------------------------------------------+\n   | nlink     | The number of hard links to the file                                   |\n   +-----------+------------------------------------------------------------------------+\n   | uid       | The user id of the owner of the file                                   |\n   +-----------+------------------------------------------------------------------------+\n   | gid       | The group id of the file owner                                         |\n   +-----------+------------------------------------------------------------------------+\n   | rdev      | If this file refers to a device, the ID of the device it refers to     |\n   +-----------+------------------------------------------------------------------------+\n   | blksize   | The file-system preffered block size for the file                      |\n   +-----------+------------------------------------------------------------------------+\n   | blocks    | The number of such blocks allocated                                    |\n   +-----------+------------------------------------------------------------------------+\n   | mtime     | Unix timestamp of when the file was last modified                      |\n   +-----------+------------------------------------------------------------------------+\n   | ctime     | Unix timestamp of when the file was created                            |\n   +-----------+------------------------------------------------------------------------+\n",
        "methods": 
        [
          "stat(fd::RawFD) at stat.jl:49",
          "stat(fd::Integer) at stat.jl:50",
          "stat(path::Union(UTF8String,ASCIIString)) at stat.jl:51",
          "stat(path::String) at stat.jl:52",
          "stat(f::File) at fs.jl:242",
          "stat(path...) at stat.jl:56"
        ]
      },
      {
        "name": "std",
        "summary": "Function",
        "help": "Base.std(v[, region])\n\n   Compute the sample standard deviation of a vector or array \"v\",\n   optionally along dimensions in \"region\". The algorithm returns an\n   estimator of the generative distribution's standard deviation under\n   the assumption that each entry of \"v\" is an IID drawn from that\n   generative distribution. This computation is equivalent to\n   calculating \"sqrt(sum((v - mean(v)).^2) / (length(v) - 1))\".\n   Note: Julia does not ignore \"NaN\" values in the computation. For\n   applications requiring the handling of missing data, the\n   \"DataArray\" package is recommended.\n",
        "methods": 
        [
          "std(v::AbstractArray{T,N}) at statistics.jl:176",
          "std(v::AbstractArray{T,N},region) at statistics.jl:179",
          "std(iterable) at statistics.jl:182"
        ]
      },
      {
        "name": "stdm",
        "summary": "Function",
        "help": "Base.stdm(v, m)\n\n   Compute the sample standard deviation of a vector \"v\" with known\n   mean \"m\". Note: Julia does not ignore \"NaN\" values in the\n   computation.\n",
        "methods": 
        [
          "stdm(v::AbstractArray{T,N},m::Number) at statistics.jl:173",
          "stdm(iterable,m::Number) at statistics.jl:185"
        ]
      },
      {
        "name": "step",
        "summary": "Function",
        "help": "Base.step(r)\n\n   Get the step size of a \"Range\" object.\n",
        "methods": 
        [
          "step(r::StepRange{T,S}) at range.jl:169",
          "step(r::UnitRange{T<:Real}) at range.jl:170",
          "step(r::FloatRange{T<:FloatingPoint}) at range.jl:171",
          "step(r::CalendarTimeRange{T<:AbstractCalendarDuration}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:403"
        ]
      },
      {
        "name": "stop_reading",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "stop_reading(stream::AsyncStream) at stream.jl:623",
          "stop_reading(t::UnixTerminal) at Terminals.jl:183"
        ]
      },
      {
        "name": "stop_timer",
        "summary": "Function",
        "help": "Base.stop_timer(t::Timer)\n\n   Stop invoking the callback for a timer.\n",
        "methods": 
        [
          "stop_timer(timer::Timer) at stream.jl:485"
        ]
      },
      {
        "name": "strchr",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "strchr(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "strerror",
        "summary": "Function",
        "help": "Base.strerror(n)\n\n   Convert a system call error code to a descriptive string\n",
        "methods": 
        [
          "strerror(e::Integer) at error.jl:37",
          "strerror() at error.jl:38"
        ]
      },
      {
        "name": "strftime",
        "summary": "Function",
        "help": "Base.strftime([format], time)\n\n   Convert time, given as a number of seconds since the epoch or a\n   \"TmStruct\", to a formatted string using the given format.\n   Supported formats are the same as those in the standard C library.\n",
        "methods": 
        [
          "strftime(fmt::String,t::Real) at libc.jl:37",
          "strftime(fmt::String,tm::TmStruct) at libc.jl:39",
          "strftime(t) at libc.jl:36"
        ]
      },
      {
        "name": "stride",
        "summary": "Function",
        "help": "Base.stride(A, k)\n\n   Returns the distance in memory (in number of elements) between\n   adjacent elements in dimension k\n",
        "methods": 
        [
          "stride(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Integer) at subarray.jl:398",
          "stride(a::AbstractArray{T,N},i::Integer) at abstractarray.jl:30"
        ]
      },
      {
        "name": "strides",
        "summary": "Function",
        "help": "Base.strides(A)\n\n   Returns a tuple of the memory strides in each dimension\n",
        "methods": 
        [
          "strides{T}(a::Array{T,1}) at array.jl:25",
          "strides{T}(a::Array{T,2}) at array.jl:26",
          "strides{T}(a::Array{T,3}) at array.jl:27",
          "strides(a::AbstractArray{T,N}) at abstractarray.jl:40"
        ]
      },
      {
        "name": "string",
        "summary": "Function",
        "help": "Base.string(xs...)\n\n   Create a string from any values using the \"print\" function.\n",
        "methods": 
        [
          "string() at string.jl:29",
          "string(c::ASCIIString...) at ascii.jl:24",
          "string(a::Union(UTF8String,ASCIIString)...) at utf8.jl:134",
          "string(s::String) at string.jl:30",
          "string(x::Union(Int128,Int8,Int64,Int16,Int32)) at string.jl:1562",
          "string(x::BigInt) at gmp.jl:415",
          "string(x::BigFloat) at mpfr.jl:702",
          "string(xs...) at string.jl:31"
        ]
      },
      {
        "name": "stringmime",
        "summary": "Function",
        "help": "Base.stringmime(mime, x)\n\n   Returns a \"String\" containing the representation of \"x\" in the\n   requested \"mime\" type.  This is similar to \"reprmime\" except\n   that binary data is base64-encoded as an ASCII string.\n",
        "methods": 
        [
          "stringmime(::MIME{:text/vnd.graphviz},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/latex},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/calendar},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/n3},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/richtext},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/x-setext},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/sgml},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/tab-separated-values},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/x-vcalendar},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/x-vcard},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/cmd},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/css},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/csv},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/html},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/javascript},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/markdown},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/plain},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/vcard},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:text/xml},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:application/atom+xml},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:application/ecmascript},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:application/json},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:application/rdf+xml},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:application/rss+xml},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:application/xml-dtd},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:application/postscript},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:image/svg+xml},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:application/x-latex},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:application/xhtml+xml},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:application/javascript},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:application/xml},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:model/x3d+xml},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:model/x3d+vrml},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(::MIME{:model/vrml},::Array{Uint8,1}) at multimedia.jl:64",
          "stringmime(m::MIME{mime},x::Array{Uint8,1}) at multimedia.jl:83",
          "stringmime(::MIME{:text/vnd.graphviz},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/latex},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/calendar},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/n3},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/richtext},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/x-setext},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/sgml},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/tab-separated-values},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/x-vcalendar},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/x-vcard},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/cmd},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/css},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/csv},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/html},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/javascript},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/markdown},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/plain},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/vcard},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:text/xml},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:application/atom+xml},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:application/ecmascript},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:application/json},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:application/rdf+xml},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:application/rss+xml},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:application/xml-dtd},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:application/postscript},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:image/svg+xml},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:application/x-latex},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:application/xhtml+xml},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:application/javascript},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:application/xml},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:model/x3d+xml},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:model/x3d+vrml},::Any) at multimedia.jl:71",
          "stringmime(::MIME{:model/vrml},::Any) at multimedia.jl:71",
          "stringmime(m::MIME{mime},x) at multimedia.jl:82",
          "stringmime(m::String,x) at multimedia.jl:88"
        ]
      },
      {
        "name": "strip",
        "summary": "Function",
        "help": "Base.strip(string[, chars])\n\n   Return \"string\" with any leading and trailing whitespace removed.\n   If \"chars\" (a character, or vector or set of characters) is\n   provided, instead remove characters contained in it.\n",
        "methods": 
        [
          "strip(s::String) at string.jl:1445",
          "strip(s::String,chars::Union(Char,Set{Char},AbstractArray{Char,1})) at string.jl:1446"
        ]
      },
      {
        "name": "strptime",
        "summary": "Function",
        "help": "Base.strptime([format], timestr)\n\n   Parse a formatted time string into a \"TmStruct\" giving the\n   seconds, minute, hour, date, etc. Supported formats are the same as\n   those in the standard C library. On some platforms, timezones will\n   not be parsed correctly. If the result of this function will be\n   passed to \"time\" to convert it to seconds since the epoch, the\n   \"isdst\" field should be filled in manually. Setting it to \"-1\"\n   will tell the C library to use the current system settings to\n   determine the timezone.\n",
        "methods": 
        [
          "strptime(timestr::String) at libc.jl:48",
          "strptime(fmt::String,timestr::String) at libc.jl:50"
        ]
      },
      {
        "name": "strwidth",
        "summary": "Function",
        "help": "Base.strwidth(s)\n\n   Gives the number of columns needed to print a string.\n",
        "methods": 
        [
          "strwidth(s::Union(UTF8String,ASCIIString)) at string.jl:536",
          "strwidth(s::String) at string.jl:535"
        ]
      },
      {
        "name": "sub",
        "summary": "Function",
        "help": "Base.sub(A, inds...)\n\n   Returns a SubArray, which stores the input \"A\" and \"inds\"\n   rather than computing the result immediately. Calling \"getindex\"\n   on a SubArray computes the indices on the fly.\n",
        "methods": 
        [
          "sub{T,N}(A::Array{T,N},i::(Range{Int64},)) at subarray.jl:51",
          "sub{N}(A::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::NTuple{N,Union(Range{Int64},Int64)}) at subarray.jl:77",
          "sub{T,N}(A::AbstractArray{T,N},i::NTuple{N,Union(Range{Int64},Int64)}) at subarray.jl:74",
          "sub(A::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)},i::Union(Range{Int64},Int64)...) at subarray.jl:82",
          "sub(A::AbstractArray{T,N},i::Union(Range{Int64},Int64)...) at subarray.jl:79",
          "sub(A::AbstractArray{T,N},I::Union(Range{Int64},Colon,Int64)...) at subarray.jl:131"
        ]
      },
      {
        "name": "sub2ind",
        "summary": "Function",
        "help": "Base.sub2ind(dims, i, j, k...) -> index\n\n   The inverse of \"ind2sub\", returns the linear index corresponding\n   to the provided subscripts\n",
        "methods": 
        [
          "sub2ind{T<:Integer}(dims::Array{T<:Integer,N},sub::Array{T<:Integer,N}) at abstractarray.jl:1005",
          "sub2ind(dims) at abstractarray.jl:981",
          "sub2ind(dims,i::Int64,j::Int64) at abstractarray.jl:984",
          "sub2ind(dims,i0::Int64,i1::Int64,i2::Int64) at abstractarray.jl:986",
          "sub2ind(dims,i0::Int64,i1::Int64,i2::Int64,i3::Int64) at abstractarray.jl:990",
          "sub2ind(dims,i::Integer) at abstractarray.jl:982",
          "sub2ind(dims,i::Integer,j::Integer) at abstractarray.jl:983",
          "sub2ind(dims,i0::Integer,i1::Integer,i2::Integer) at abstractarray.jl:985",
          "sub2ind(dims,i0::Integer,i1::Integer,i2::Integer,i3::Integer) at abstractarray.jl:988",
          "sub2ind(dims,I::Integer...) at abstractarray.jl:994",
          "sub2ind{T<:Integer}(dims,I::AbstractArray{T<:Integer,1}...) at abstractarray.jl:1015"
        ]
      },
      {
        "name": "subtype",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "subtype(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "subtypes",
        "summary": "Function",
        "help": "Base.subtypes(T::DataType)\n\n   Return a list of immediate subtypes of DataType T.  Note that all\n   currently loaded subtypes are included, including those not visible\n   in the current module.\n",
        "methods": 
        [
          "subtypes(m::Module,x::DataType) at reflection.jl:65",
          "subtypes(x::DataType) at reflection.jl:66"
        ]
      },
      {
        "name": "success",
        "summary": "Function",
        "help": "Base.success(command)\n\n   Run a command object, constructed with backticks, and tell whether\n   it was successful (exited with a code of 0). An exception is raised\n   if the process cannot be started.\n",
        "methods": 
        [
          "success(x::Process) at process.jl:484",
          "success(procs::Array{Process,1}) at process.jl:488",
          "success(procs::ProcessChain) at process.jl:489",
          "success(cmd::AbstractCmd) at process.jl:490"
        ]
      },
      {
        "name": "sum",
        "summary": "Function",
        "help": "Base.sum(itr)\n\n   Returns the sum of all elements in a collection.\n\nBase.sum(A, dims)\n\n   Sum elements of an array over the given dimensions.\n\nBase.sum(f, itr)\n\n   Sum the results of calling function \"f\" on each element of\n   \"itr\".\n",
        "methods": 
        [
          "sum(x::(Any,Any...)) at tuple.jl:118",
          "sum{T<:Real}(r::Range{T<:Real}) at range.jl:505",
          "sum(f::Union(Func{1},Function),a::AbstractArray{T,N}) at reduce.jl:332",
          "sum{T}(f::Union(Func{1},Function),A::AbstractArray{T,N},region) at reducedim.jl:156",
          "sum(f::Union(Func{1},Function),itr) at reduce.jl:245",
          "sum(x::Number) at reduce.jl:250",
          "sum(A::BitArray{N},region) at bitarray.jl:1388",
          "sum(B::BitArray{N}) at bitarray.jl:1390",
          "sum{T}(A::SparseMatrixCSC{T,Ti<:Integer}) at sparse/sparsematrix.jl:703",
          "sum{T}(A::SparseMatrixCSC{T,Ti<:Integer},region) at sparse/sparsematrix.jl:704",
          "sum(A::AbstractArray{Bool,N}) at reduce.jl:251",
          "sum(arr::AbstractArray{BigInt,N}) at gmp.jl:386",
          "sum(arr::AbstractArray{BigFloat,N}) at mpfr.jl:533",
          "sum{T}(a::AbstractArray{T,N}) at reduce.jl:340",
          "sum(A::AbstractArray{T,N},region) at reducedim.jl:174",
          "sum(itr) at reduce.jl:233"
        ]
      },
      {
        "name": "sum!",
        "summary": "Function",
        "help": "Base.sum!(r, A)\n\n   Sum elements of \"A\" over the singleton dimensions of \"r\", and\n   write results to \"r\".\n",
        "methods": 
        [
          "sum!{R}(f::Union(Func{1},Function),r::AbstractArray{R,N},A::AbstractArray{T,N}) at reducedim.jl:169",
          "sum!{R}(r::AbstractArray{R,N},A::AbstractArray{T,N}) at reducedim.jl:175"
        ]
      },
      {
        "name": "sum_kbn",
        "summary": "Function",
        "help": "Base.sum_kbn(A)\n\n   Returns the sum of all array elements, using the Kahan-Babuska-\n   Neumaier compensated summation algorithm for additional accuracy.\n",
        "methods": 
        [
          "sum_kbn{T<:FloatingPoint}(A::AbstractArray{T<:FloatingPoint,N}) at reduce.jl:359"
        ]
      },
      {
        "name": "summary",
        "summary": "Function",
        "help": "Base.summary(x)\n\n   Return a string giving a brief description of a value. By default\n   returns \"string(typeof(x))\". For arrays, returns strings like\n   \"2x2 Float64 Array\".\n",
        "methods": 
        [
          "summary(a::AbstractArray{T,N}) at show.jl:893",
          "summary(x) at show.jl:887"
        ]
      },
      {
        "name": "super",
        "summary": "Function",
        "help": "Base.super(T::DataType)\n\n   Return the supertype of DataType T\n",
        "methods": 
        [
          "super(T::DataType) at operators.jl:5"
        ]
      },
      {
        "name": "svd",
        "summary": "Function",
        "help": "Base.svd(A[, thin=true]) -> U, S, V\n\n   Wrapper around \"svdfact\" extracting all parts the factorization\n   to a tuple. Direct use of \"svdfact\" is therefore generally more\n   efficient. Computes the SVD of A, returning \"U\", vector \"S\",\n   and \"V\" such that \"A == U*diagm(S)*V'\". If \"thin\" is\n   \"true\", an economy mode decomposition is returned. The default is\n   to produce a thin decomposition.\n\nBase.svd(A, B) -> U, V, Q, D1, D2, R0\n\n   Wrapper around \"svdfact\" extracting all parts the factorization\n   to a tuple. Direct use of \"svdfact\" is therefore generally more\n   efficient. The function returns the generalized SVD of \"A\" and\n   \"B\", returning \"U\", \"V\", \"Q\", \"D1\", \"D2\", and \"R0\"\n   such that \"A = U*D1*R0*Q'\" and \"B = V*D2*R0*Q'\".\n",
        "methods": 
        [
          "svd(A::Triangular{T<:Number}) at linalg/triangular.jl:211",
          "svd{T<:Union(Float64,Float32)}(M::Bidiagonal{T<:Union(Float64,Float32)}) at linalg/bidiag.jl:48",
          "svd(A::BitArray{2}) at linalg/bitarray.jl:99",
          "svd(A::AbstractArray{T,2},B::AbstractArray{T,2}) at linalg/factorization.jl:697",
          "svd(A::Union(AbstractArray{T,N},Number)) at linalg/factorization.jl:652",
          "svd(A,thin) at deprecated.jl:26"
        ]
      },
      {
        "name": "svdfact",
        "summary": "Function",
        "help": "Base.svdfact(A[, thin=true]) -> SVD\n\n   Compute the Singular Value Decomposition (SVD) of \"A\" and return\n   an \"SVD\" object. \"U\", \"S\", \"V\" and \"Vt\" can be obtained\n   from the factorization \"F\" with \"F[:U]\", \"F[:S]\", \"F[:V]\"\n   and \"F[:Vt]\", such that \"A = U*diagm(S)*Vt\". If \"thin\" is\n   \"true\", an economy mode decomposition is returned. The algorithm\n   produces \"Vt\" and hence \"Vt\" is more efficient to extract than\n   \"V\". The default is to produce a thin decomposition.\n\nBase.svdfact(A, B) -> GeneralizedSVD\n\n   Compute the generalized SVD of \"A\" and \"B\", returning a\n   \"GeneralizedSVD\" Factorization object \"F\", such that \"A =\n   F[:U]*F[:D1]*F[:R0]*F[:Q]'\" and \"B =\n   F[:V]*F[:D2]*F[:R0]*F[:Q]'\".\n",
        "methods": 
        [
          "svdfact{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:646",
          "svdfact{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:693",
          "svdfact{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2},SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at linalg/factorization.jl:647",
          "svdfact{TA,TB}(A::Union(DenseArray{TA,2},SubArray{TA,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{TB,2},SubArray{TB,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:694",
          "svdfact(x::Integer) at linalg/factorization.jl:649",
          "svdfact(x::Number) at linalg/factorization.jl:648",
          "svdfact(A::Triangular{T<:Number}) at linalg/triangular.jl:211",
          "svdfact(D::Diagonal{T}) at linalg/diagonal.jl:126",
          "svdfact(D::Diagonal{T},thin) at linalg/diagonal.jl:126",
          "svdfact(M::Bidiagonal{T}) at linalg/bidiag.jl:214",
          "svdfact(M::Bidiagonal{T},thin::Bool) at linalg/bidiag.jl:214",
          "svdfact(A,thin) at deprecated.jl:26"
        ]
      },
      {
        "name": "svdfact!",
        "summary": "Function",
        "help": "Base.svdfact!(A[, thin=true]) -> SVD\n\n   \"svdfact!\" is the same as \"svdfact()\", but saves space by\n   overwriting the input A, instead of creating a copy. If \"thin\" is\n   \"true\", an economy mode decomposition is returned. The default is\n   to produce a thin decomposition.\n",
        "methods": 
        [
          "svdfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:638",
          "svdfact!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:690",
          "svdfact!(A::Triangular{T<:Number}) at linalg/triangular.jl:211",
          "svdfact!(A,thin) at deprecated.jl:26"
        ]
      },
      {
        "name": "svdvals",
        "summary": "Function",
        "help": "Base.svdvals(A)\n\n   Returns the singular values of \"A\".\n\nBase.svdvals(A, B)\n\n   Return only the singular values from the generalized singular value\n   decomposition of \"A\" and \"B\".\n",
        "methods": 
        [
          "svdvals{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:665",
          "svdvals{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:737",
          "svdvals{T}(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at linalg/factorization.jl:666",
          "svdvals(x::Number) at linalg/factorization.jl:667",
          "svdvals{TA,TB}(A::Union(DenseArray{TA,2},SubArray{TA,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{TB,2},SubArray{TB,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:738",
          "svdvals(A::Triangular{T<:Number}) at linalg/triangular.jl:211",
          "svdvals(D::Diagonal{T}) at linalg/diagonal.jl:124",
          "svdvals{T<:Union(Float64,Float32)}(M::Bidiagonal{T<:Union(Float64,Float32)}) at linalg/bidiag.jl:47"
        ]
      },
      {
        "name": "svdvals!",
        "summary": "Function",
        "help": "Base.svdvals!(A)\n\n   Returns the singular values of \"A\", while saving space by\n   overwriting the input.\n",
        "methods": 
        [
          "svdvals!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:664",
          "svdvals!{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at linalg/factorization.jl:734"
        ]
      },
      {
        "name": "symbol",
        "summary": "Function",
        "help": "Base.symbol(str) -> Symbol\n\n   Convert a string to a \"Symbol\".\n",
        "methods": 
        [
          "symbol(s::Symbol) at expr.jl:3",
          "symbol(s::ASCIIString) at expr.jl:4",
          "symbol(s::UTF8String) at expr.jl:5",
          "symbol(a::Array{Uint8,1}) at expr.jl:6",
          "symbol(x::Char) at expr.jl:8",
          "symbol(s::String) at string.jl:65"
        ]
      },
      {
        "name": "symdiff",
        "summary": "Function",
        "help": "Base.symdiff(s1, s2...)\n\n   Construct the symmetric difference of elements in the passed in\n   sets or arrays. Maintains order with arrays.\n",
        "methods": 
        [
          "symdiff(s1::IntSet,s2::IntSet) at intset.jl:91",
          "symdiff(a) at array.jl:1369",
          "symdiff(a,b) at array.jl:1370",
          "symdiff(a,b,rest...) at array.jl:1371"
        ]
      },
      {
        "name": "symdiff!",
        "summary": "Function",
        "help": "Base.symdiff!(s, n)\n\n   IntSet s is destructively modified to toggle the inclusion of\n   integer \"n\".\n\nBase.symdiff!(s, itr)\n\n   For each element in \"itr\", destructively toggle its inclusion in\n   set \"s\".\n\nBase.symdiff!(s1, s2)\n\n   Construct the symmetric difference of IntSets \"s1\" and \"s2\",\n   storing the result in \"s1\".\n",
        "methods": 
        [
          "symdiff!(s::IntSet,n::Integer) at intset.jl:100",
          "symdiff!(s::IntSet,s2::IntSet) at intset.jl:245",
          "symdiff!(s::IntSet,ns) at intset.jl:109"
        ]
      },
      {
        "name": "symmetrize!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "symmetrize!(A) at deprecated.jl:26",
          "symmetrize!(A,uplo) at deprecated.jl:26"
        ]
      },
      {
        "name": "symperm",
        "summary": "Function",
        "help": "Base.symperm(A, p)\n\n   Return the symmetric permutation of A, which is \"A[p,p]\". A\n   should be symmetric and sparse, where only the upper triangular\n   part of the matrix is stored. This algorithm ignores the lower\n   triangular part of the matrix. Only the upper triangular part of\n   the result is returned as well.\n",
        "methods": 
        [
          "symperm{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti},pinv::Array{Ti,1}) at sparse/csparse.jl:307"
        ]
      },
      {
        "name": "system_error",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "system_error(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "systemerror",
        "summary": "Function",
        "help": "Base.systemerror(sysfunc, iftrue)\n\n   Raises a \"SystemError\" for \"errno\" with the descriptive string\n   \"sysfunc\" if \"bool\" is true\n",
        "methods": 
        [
          "systemerror(p,b::Bool) at error.jl:39"
        ]
      },
      {
        "name": "take",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "take(xs,n::Int64) at /home/samuel/.julia/v0.3/Iterators/src/Iterators.jl:50",
          "take(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "take!",
        "summary": "Function",
        "help": "Base.take!(RemoteRef)\n\n   Fetch the value of a remote reference, removing it so that the\n   reference is empty again.\n",
        "methods": 
        [
          "take!(rv::RemoteValue) at multi.jl:767",
          "take!(rr::RemoteRef) at multi.jl:776"
        ]
      },
      {
        "name": "takebuf_array",
        "summary": "Function",
        "help": "Base.takebuf_array(b::IOBuffer)\n\n   Obtain the contents of an \"IOBuffer\" as an array, without\n   copying.\n",
        "methods": 
        [
          "takebuf_array(io::IOBuffer) at iobuffer.jl:175",
          "takebuf_array(s::IOStream) at io.jl:453"
        ]
      },
      {
        "name": "takebuf_string",
        "summary": "Function",
        "help": "Base.takebuf_string(b::IOBuffer)\n\n   Obtain the contents of an \"IOBuffer\" as a string, without\n   copying.\n",
        "methods": 
        [
          "takebuf_string(io::IOBuffer) at iobuffer.jl:195",
          "takebuf_string(s::IOStream) at io.jl:450"
        ]
      },
      {
        "name": "tan",
        "summary": "Function",
        "help": "Base.tan(x)\n\n   Compute tangent of \"x\", where \"x\" is in radians\n",
        "methods": 
        [
          "tan(a::Complex{Float16}) at float16.jl:134",
          "tan(z::Complex{T<:Real}) at complex.jl:537",
          "tan(x::Float64) at math.jl:277",
          "tan(x::Float32) at math.jl:278",
          "tan(a::Float16) at float16.jl:133",
          "tan(x::BigFloat) at mpfr.jl:547",
          "tan(x::Real) at math.jl:279",
          "tan{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "tan{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "tan{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "tan{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "tand",
        "summary": "Function",
        "help": "Base.tand(x)\n\n   Compute tangent of \"x\", where \"x\" is in degrees\n",
        "methods": 
        [
          "tand(x::Real) at math.jl:226",
          "tand{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "tand{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "tand{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "tand{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "tand(z) at math.jl:231"
        ]
      },
      {
        "name": "tanh",
        "summary": "Function",
        "help": "Base.tanh(x)\n\n   Compute hyperbolic tangent of \"x\"\n",
        "methods": 
        [
          "tanh(a::Complex{Float16}) at float16.jl:134",
          "tanh{T<:FloatingPoint}(z::Complex{T<:FloatingPoint}) at complex.jl:598",
          "tanh(z::Complex{T<:Real}) at complex.jl:616",
          "tanh(x::Float64) at math.jl:253",
          "tanh(x::Float32) at math.jl:254",
          "tanh(a::Float16) at float16.jl:133",
          "tanh(x::BigFloat) at mpfr.jl:397",
          "tanh(x::FloatingPoint) at math.jl:264",
          "tanh(x::Real) at math.jl:255",
          "tanh{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "tanh{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "tanh{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "tanh{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "task_local_storage",
        "summary": "Function",
        "help": "Base.task_local_storage(symbol)\n\n   Look up the value of a symbol in the current task's task-local\n   storage.\n\nBase.task_local_storage(symbol, value)\n\n   Assign a value to a symbol in the current task's task-local\n   storage.\n\nBase.task_local_storage(body, symbol, value)\n\n   Call the function \"body\" with a modified task-local storage, in\n   which \"value\" is assigned to \"symbol\"; the previous value of\n   \"symbol\", or lack thereof, is restored afterwards. Useful for\n   emulating dynamic scoping.\n",
        "methods": 
        [
          "task_local_storage() at task.jl:20",
          "task_local_storage(body::Function,key,val) at task.jl:30",
          "task_local_storage(key) at task.jl:26",
          "task_local_storage(key,val) at task.jl:27"
        ]
      },
      {
        "name": "tempdir",
        "summary": "Function",
        "help": "Base.tempdir()\n\n   Obtain the path of a temporary directory.\n",
        "methods": 
        [
          "tempdir() at file.jl:79"
        ]
      },
      {
        "name": "tempname",
        "summary": "Function",
        "help": "Base.tempname()\n\n   Generate a unique temporary filename.\n",
        "methods": 
        [
          "tempname() at file.jl:69"
        ]
      },
      {
        "name": "tic",
        "summary": "Function",
        "help": "Base.tic()\n\n   Set a timer to be read by the next call to \"toc()\" or \"toq()\".\n   The macro call \"@time expr\" can also be used to time evaluation.\n",
        "methods": 
        [
          "tic() at util.jl:13"
        ]
      },
      {
        "name": "time",
        "summary": "Function",
        "help": "Base.time([t::TmStruct])\n\n   Get the system time in seconds since the epoch, with fairly high\n   (typically, microsecond) resolution. When passed a \"TmStruct\",\n   converts it to a number of seconds since the epoch.\n",
        "methods": 
        [
          "time(tm::TmStruct) at libc.jl:70",
          "time() at util.jl:4"
        ]
      },
      {
        "name": "time_ns",
        "summary": "Function",
        "help": "Base.time_ns()\n\n   Get the time in nanoseconds. The time corresponding to 0 is\n   undefined, and wraps every 5.8 years.\n",
        "methods": 
        [
          "time_ns() at util.jl:7"
        ]
      },
      {
        "name": "timedwait",
        "summary": "Function",
        "help": "Base.timedwait(testcb::Function, secs::Float64; pollint::Float64=0.1)\n\n   Waits till \"testcb\" returns \"true\" or for \"secs`\" seconds,\n   whichever is earlier. \"testcb\" is polled every \"pollint\"\n   seconds.\n",
        "methods": 
        [
          "timedwait(testcb::Function,secs::Float64) at multi.jl:1519"
        ]
      },
      {
        "name": "toc",
        "summary": "Function",
        "help": "Base.toc()\n\n   Print and return the time elapsed since the last \"tic()\".\n",
        "methods": 
        [
          "toc() at util.jl:30"
        ]
      },
      {
        "name": "toq",
        "summary": "Function",
        "help": "Base.toq()\n\n   Return, but do not print, the time elapsed since the last\n   \"tic()\".\n",
        "methods": 
        [
          "toq() at util.jl:19"
        ]
      },
      {
        "name": "touch",
        "summary": "Function",
        "help": "Base.touch(path::String)\n\n   Update the last-modified timestamp on a file to the current time.\n",
        "methods": 
        [
          "touch(path::String) at file.jl:65"
        ]
      },
      {
        "name": "trace",
        "summary": "Function",
        "help": "Base.trace(M)\n\n   Matrix trace\n",
        "methods": 
        [
          "trace{Tv}(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:1704",
          "trace{T}(A::Array{T,2}) at linalg/dense.jl:127",
          "trace(D::Diagonal{T}) at linalg/diagonal.jl:78",
          "trace(A::AbstractArray{T,2}) at linalg/generic.jl:216",
          "trace(x::Number) at linalg/generic.jl:219"
        ]
      },
      {
        "name": "trailing_ones",
        "summary": "Function",
        "help": "Base.trailing_ones(x::Integer) -> Integer\n\n   Number of ones trailing the binary representation of \"x\".\n\n   **Example**: \"trailing_ones(3) -> 2\"\n",
        "methods": 
        [
          "trailing_ones(x::BigInt) at gmp.jl:313",
          "trailing_ones(x::Integer) at int.jl:240"
        ]
      },
      {
        "name": "trailing_zeros",
        "summary": "Function",
        "help": "Base.trailing_zeros(x::Integer) -> Integer\n\n   Number of zeros trailing the binary representation of \"x\".\n\n   **Example**: \"trailing_zeros(2) -> 1\"\n",
        "methods": 
        [
          "trailing_zeros(x::Int8) at int.jl:227",
          "trailing_zeros(x::Uint8) at int.jl:228",
          "trailing_zeros(x::Int16) at int.jl:229",
          "trailing_zeros(x::Uint16) at int.jl:230",
          "trailing_zeros(x::Int32) at int.jl:231",
          "trailing_zeros(x::Uint32) at int.jl:232",
          "trailing_zeros(x::Int64) at int.jl:233",
          "trailing_zeros(x::Uint64) at int.jl:234",
          "trailing_zeros(x::Int128) at int.jl:235",
          "trailing_zeros(x::Uint128) at int.jl:236",
          "trailing_zeros(x::BigInt) at gmp.jl:312"
        ]
      },
      {
        "name": "transpose",
        "summary": "Function",
        "help": "Base.transpose(A)\n\n   The transposition operator (\".'\").\n",
        "methods": 
        [
          "transpose(r::Range{T}) at range.jl:207",
          "transpose(x::Number) at number.jl:29",
          "transpose(B::BitArray{1}) at bitarray.jl:1474",
          "transpose(B::BitArray{2}) at bitarray.jl:1526",
          "transpose(A::Union(SubArray{T,2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,2})) at array.jl:1306",
          "transpose(x::Union(SubArray{T,1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,1})) at array.jl:1315",
          "transpose{Tv,Ti}(S::SparseMatrixCSC{Tv,Ti}) at sparse/csparse.jl:149",
          "transpose(M::SymTridiagonal{T}) at linalg/tridiag.jl:36",
          "transpose(M::Tridiagonal{T}) at linalg/tridiag.jl:192",
          "transpose(A::Triangular{T<:Number}) at linalg/triangular.jl:98",
          "transpose(A::Symmetric{T}) at linalg/symmetric.jl:32",
          "transpose(D::Diagonal{T}) at linalg/diagonal.jl:74",
          "transpose(M::Bidiagonal{T}) at linalg/bidiag.jl:70",
          "transpose(J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:17",
          "transpose{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:822",
          "transpose{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:822"
        ]
      },
      {
        "name": "trigamma",
        "summary": "Function",
        "help": "Base.trigamma(x)\n\n   Compute the trigamma function of \"x\" (the logarithmic second\n   derivative of \"gamma(x)\")\n",
        "methods": 
        [
          "trigamma(x::Real) at math.jl:1081",
          "trigamma{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "trigamma{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "trigamma{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "tril",
        "summary": "Function",
        "help": "Base.tril(M)\n\n   Lower triangle of a matrix.\n",
        "methods": 
        [
          "tril(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/csparse.jl:366",
          "tril(M::Array{T,2},k::Integer) at linalg/dense.jl:85",
          "tril(B::BitArray{2},k::Integer) at linalg/bitarray.jl:56",
          "tril{Tv,Ti}(S::SparseMatrixCSC{Tv,Ti},k::Integer) at linalg/sparse.jl:314",
          "tril(M::AbstractArray{T,2}) at linalg/generic.jl:26"
        ]
      },
      {
        "name": "tril!",
        "summary": "Function",
        "help": "Base.tril!(M)\n\n   Lower triangle of a matrix, overwriting \"M\" in the process.\n",
        "methods": 
        [
          "tril!(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/csparse.jl:365",
          "tril!{T}(M::Array{T,2},k::Integer) at linalg/dense.jl:73",
          "tril!(M::AbstractArray{T,2}) at linalg/generic.jl:30"
        ]
      },
      {
        "name": "triu",
        "summary": "Function",
        "help": "Base.triu(M)\n\n   Upper triangle of a matrix.\n",
        "methods": 
        [
          "triu(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/csparse.jl:364",
          "triu(M::Array{T,2},k::Integer) at linalg/dense.jl:70",
          "triu(B::BitArray{2},k::Integer) at linalg/bitarray.jl:44",
          "triu{Tv,Ti}(S::SparseMatrixCSC{Tv,Ti},k::Integer) at linalg/sparse.jl:286",
          "triu(M::AbstractArray{T,2}) at linalg/generic.jl:25"
        ]
      },
      {
        "name": "triu!",
        "summary": "Function",
        "help": "Base.triu!(M)\n\n   Upper triangle of a matrix, overwriting \"M\" in the process.\n",
        "methods": 
        [
          "triu!(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/csparse.jl:363",
          "triu!{T}(M::Array{T,2},k::Integer) at linalg/dense.jl:58",
          "triu!(M::AbstractArray{T,2}) at linalg/generic.jl:29"
        ]
      },
      {
        "name": "trues",
        "summary": "Function",
        "help": "Base.trues(dims)\n\n   Create a \"BitArray\" with all values set to true\n",
        "methods": 
        [
          "trues(args...) at bitarray.jl:228"
        ]
      },
      {
        "name": "trunc",
        "summary": "Function",
        "help": "Base.trunc(x[, digits[, base]])\n\n   Returns the nearest integral value of the same type as \"x\" not\n   greater in magnitude than \"x\". \"digits\" and \"base\" work as\n   above.\n",
        "methods": 
        [
          "trunc(x::Integer) at int.jl:369",
          "trunc(x::Rational{T<:Integer}) at rational.jl:161",
          "trunc(x::Float64) at math.jl:291",
          "trunc(x::Float32) at math.jl:292",
          "trunc{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:431",
          "trunc{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "trunc{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "trunc{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357",
          "trunc(x::Float16) at float16.jl:102",
          "trunc(x::BigFloat) at mpfr.jl:639",
          "trunc(x,digits::Integer) at floatfuncs.jl:85",
          "trunc(x,digits::Integer,base::Integer) at floatfuncs.jl:85"
        ]
      },
      {
        "name": "truncate",
        "summary": "Function",
        "help": "Base.truncate(file, n)\n\n   Resize the file or buffer given by the first argument to exactly\n   *n* bytes, filling previously unallocated space with '0' if the\n   file or buffer is grown\n",
        "methods": 
        [
          "truncate(io::IOBuffer,n::Integer) at iobuffer.jl:112",
          "truncate(s::IOStream,n::Integer) at io.jl:279"
        ]
      },
      {
        "name": "typeintersect",
        "summary": "Function",
        "help": "Base.typeintersect(T, S)\n\n   Compute a type that contains the intersection of \"T\" and \"S\".\n   Usually this will be the smallest such type or one close to it.\n",
        "methods": 
        [
          "typeintersect(a::ANY,b::ANY) at reflection.jl:41"
        ]
      },
      {
        "name": "typejoin",
        "summary": "Function",
        "help": "Base.typejoin(T, S)\n\n   Compute a type that contains both \"T\" and \"S\".\n",
        "methods": 
        [
          "typejoin() at promotion.jl:3",
          "typejoin(t::ANY) at promotion.jl:4",
          "typejoin(a::ANY,b::ANY) at promotion.jl:7",
          "typejoin(t::ANY,ts...) at promotion.jl:5"
        ]
      },
      {
        "name": "typemax",
        "summary": "Function",
        "help": "Base.typemax(type)\n\n   The highest value representable by the given (real) numeric type.\n",
        "methods": 
        [
          "typemax(::Type{Bool}) at bool.jl:15",
          "typemax(::Type{Int8}) at int.jl:460",
          "typemax(::Type{Uint8}) at int.jl:462",
          "typemax(::Type{Int16}) at int.jl:464",
          "typemax(::Type{Uint16}) at int.jl:466",
          "typemax(::Type{Int32}) at int.jl:468",
          "typemax(::Type{Uint32}) at int.jl:470",
          "typemax(::Type{Int64}) at int.jl:472",
          "typemax(::Type{Uint64}) at int.jl:474",
          "typemax(::Type{Uint128}) at int.jl:477",
          "typemax(::Type{Int128}) at int.jl:479",
          "typemax(::Type{Float16}) at float.jl:272",
          "typemax(::Type{Float32}) at float.jl:274",
          "typemax(::Type{Float64}) at float.jl:276",
          "typemax{T<:Real}(x::T<:Real) at float.jl:278",
          "typemax{T<:Integer}(::Type{Rational{T<:Integer}}) at rational.jl:105",
          "typemax(::Type{BigFloat}) at mpfr.jl:667",
          "typemax(::Type{VersionNumber}) at version.jl:97"
        ]
      },
      {
        "name": "typemin",
        "summary": "Function",
        "help": "Base.typemin(type)\n\n   The lowest value representable by the given (real) numeric type.\n",
        "methods": 
        [
          "typemin(::Type{Bool}) at bool.jl:14",
          "typemin(::Type{Int8}) at int.jl:459",
          "typemin(::Type{Uint8}) at int.jl:461",
          "typemin(::Type{Int16}) at int.jl:463",
          "typemin(::Type{Uint16}) at int.jl:465",
          "typemin(::Type{Int32}) at int.jl:467",
          "typemin(::Type{Uint32}) at int.jl:469",
          "typemin(::Type{Int64}) at int.jl:471",
          "typemin(::Type{Uint64}) at int.jl:473",
          "typemin(::Type{Uint128}) at int.jl:476",
          "typemin(::Type{Int128}) at int.jl:478",
          "typemin(::Type{Float16}) at float.jl:271",
          "typemin(::Type{Float32}) at float.jl:273",
          "typemin(::Type{Float64}) at float.jl:275",
          "typemin{T<:Real}(x::T<:Real) at float.jl:277",
          "typemin{T<:Integer}(::Type{Rational{T<:Integer}}) at rational.jl:104",
          "typemin(::Type{BigFloat}) at mpfr.jl:668",
          "typemin(::Type{VersionNumber}) at version.jl:96",
          "typemin{T}(::Type{HierarchicalValue{T}}) at pkg/resolve/versionweight.jl:15",
          "typemin(::Type{VWPreBuildItem}) at pkg/resolve/versionweight.jl:79",
          "typemin(::Type{VWPreBuild}) at pkg/resolve/versionweight.jl:117",
          "typemin(::Type{VersionWeight}) at pkg/resolve/versionweight.jl:157",
          "typemin(::Type{FieldValue}) at pkg/resolve/fieldvalue.jl:38"
        ]
      },
      {
        "name": "ucfirst",
        "summary": "Function",
        "help": "Base.ucfirst(string)\n\n   Returns \"string\" with the first character converted to uppercase.\n",
        "methods": 
        [
          "ucfirst(s::ASCIIString) at ascii.jl:42",
          "ucfirst(s::String) at string.jl:802"
        ]
      },
      {
        "name": "uint",
        "summary": "Function",
        "help": "Base.uint(x)\n\n   Convert a number or array to the default unsigned integer type on\n   your platform. Alternatively, \"x\" can be a string, which is\n   parsed as an unsigned integer.\n",
        "methods": 
        [
          "uint(x::Uint64) at base.jl:104",
          "uint(x::FloatingPoint) at int.jl:514",
          "uint(z::Complex{T<:Real}) at complex.jl:60",
          "uint(x::Rational{T<:Integer}) at rational.jl:171",
          "uint(r::StepRange{T,S}) at abstractarray.jl:327",
          "uint(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "uint(x::AbstractArray{Uint64,N}) at abstractarray.jl:267",
          "uint{S<:String}(a::AbstractArray{S<:String,N}) at string.jl:1603",
          "uint(x::AbstractArray{T,N}) at abstractarray.jl:270",
          "uint(s::String) at string.jl:1548",
          "uint(x) at base.jl:103"
        ]
      },
      {
        "name": "uint128",
        "summary": "Function",
        "help": "Base.uint128(x)\n\n   Convert a number or array to \"Uint128\" data type\n",
        "methods": 
        [
          "uint128(x::FloatingPoint) at int.jl:514",
          "uint128(z::Complex{T<:Real}) at complex.jl:60",
          "uint128(x::Rational{T<:Integer}) at rational.jl:171",
          "uint128(r::StepRange{T,S}) at abstractarray.jl:327",
          "uint128(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "uint128(x::AbstractArray{Uint128,N}) at abstractarray.jl:267",
          "uint128(x::AbstractArray{T,N}) at abstractarray.jl:270",
          "uint128(s::String) at string.jl:1558",
          "uint128(x) at int.jl:362"
        ]
      },
      {
        "name": "uint16",
        "summary": "Function",
        "help": "Base.uint16(x)\n\n   Convert a number or array to \"Uint16\" data type\n",
        "methods": 
        [
          "uint16(x::FloatingPoint) at int.jl:514",
          "uint16(z::Complex{T<:Real}) at complex.jl:60",
          "uint16(x::Rational{T<:Integer}) at rational.jl:171",
          "uint16(r::StepRange{T,S}) at abstractarray.jl:327",
          "uint16(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "uint16(x::AbstractArray{Uint16,N}) at abstractarray.jl:267",
          "uint16{S<:String}(a::AbstractArray{S<:String,N}) at string.jl:1603",
          "uint16(x::AbstractArray{T,N}) at abstractarray.jl:270",
          "uint16(s::String) at string.jl:1552",
          "uint16(x) at int.jl:359"
        ]
      },
      {
        "name": "uint32",
        "summary": "Function",
        "help": "Base.uint32(x)\n\n   Convert a number or array to \"Uint32\" data type\n",
        "methods": 
        [
          "uint32(x::FloatingPoint) at int.jl:514",
          "uint32(z::Complex{T<:Real}) at complex.jl:60",
          "uint32(x::Rational{T<:Integer}) at rational.jl:171",
          "uint32(r::StepRange{T,S}) at abstractarray.jl:327",
          "uint32(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "uint32(x::AbstractArray{Uint32,N}) at abstractarray.jl:267",
          "uint32{S<:String}(a::AbstractArray{S<:String,N}) at string.jl:1603",
          "uint32(x::AbstractArray{T,N}) at abstractarray.jl:270",
          "uint32(s::String) at string.jl:1554",
          "uint32(x) at int.jl:360"
        ]
      },
      {
        "name": "uint64",
        "summary": "Function",
        "help": "Base.uint64(x)\n\n   Convert a number or array to \"Uint64\" data type\n",
        "methods": 
        [
          "uint64(x::FloatingPoint) at int.jl:514",
          "uint64(z::Complex{T<:Real}) at complex.jl:60",
          "uint64(x::Rational{T<:Integer}) at rational.jl:171",
          "uint64(r::StepRange{T,S}) at abstractarray.jl:327",
          "uint64(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "uint64(x::AbstractArray{Uint64,N}) at abstractarray.jl:267",
          "uint64{S<:String}(a::AbstractArray{S<:String,N}) at string.jl:1603",
          "uint64(x::AbstractArray{T,N}) at abstractarray.jl:270",
          "uint64(s::String) at string.jl:1556",
          "uint64(x) at int.jl:361"
        ]
      },
      {
        "name": "uint8",
        "summary": "Function",
        "help": "Base.uint8(x)\n\n   Convert a number or array to \"Uint8\" data type\n",
        "methods": 
        [
          "uint8(x::FloatingPoint) at int.jl:514",
          "uint8(z::Complex{T<:Real}) at complex.jl:60",
          "uint8(x::Rational{T<:Integer}) at rational.jl:171",
          "uint8(r::StepRange{T,S}) at abstractarray.jl:327",
          "uint8(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "uint8(x::AbstractArray{Uint8,N}) at abstractarray.jl:267",
          "uint8{S<:String}(a::AbstractArray{S<:String,N}) at string.jl:1603",
          "uint8(x::AbstractArray{T,N}) at abstractarray.jl:270",
          "uint8(s::String) at string.jl:1550",
          "uint8(x) at int.jl:358"
        ]
      },
      {
        "name": "unescape_string",
        "summary": "Function",
        "help": "Base.unescape_string(s::String) -> String\n\n   General unescaping of traditional C and Unicode escape sequences.\n   Reverse of \"escape_string()\". See also \"print_unescaped()\".\n",
        "methods": 
        [
          "unescape_string(s::String) at string.jl:955"
        ]
      },
      {
        "name": "union",
        "summary": "Function",
        "help": "Base.union(s1, s2...)\n\n   Construct the union of two or more sets. Maintains order with\n   arrays.\n",
        "methods": 
        [
          "union(s1::IntSet) at intset.jl:208",
          "union(s1::IntSet,s2::IntSet) at intset.jl:209",
          "union(s1::IntSet,ss::IntSet...) at intset.jl:210",
          "union() at set.jl:43",
          "union(s::Set{T}) at set.jl:44",
          "union(s::Set{T},sets::Set{T}...) at set.jl:46",
          "union(s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:48",
          "union(s::OrderedSet{T},sets...) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:50",
          "union(vs...) at array.jl:1338"
        ]
      },
      {
        "name": "union!",
        "summary": "Function",
        "help": "Base.union!(s, iterable)\n\n   Union each element of \"iterable\" into set \"s\" in-place.\n",
        "methods": 
        [
          "union!(s::IntSet,s2::IntSet) at intset.jl:192",
          "union!(s::IntSet,ns) at intset.jl:45",
          "union!(s::Set{T},xs) at set.jl:23",
          "union!(s::IntDisjointSets,x::Integer,y::Integer) at /home/samuel/.julia/v0.3/DataStructures/src/disjoint_set.jl:45",
          "union!{T}(s::DisjointSets{T},x::T,y::T) at /home/samuel/.julia/v0.3/DataStructures/src/disjoint_set.jl:115",
          "union!(s::OrderedSet{T},xs) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:31"
        ]
      },
      {
        "name": "unique",
        "summary": "Function",
        "help": "Base.unique(itr[, dim])\n\n   Returns an array containing only the unique elements of the\n   iterable \"itr\", in the order that the first of each set of\n   equivalent elements originally appears. If \"dim\" is specified,\n   returns unique regions of the array \"itr\" along \"dim\".\n",
        "methods": 
        [
          "unique{T}(A::AbstractArray{T,1},dim::Int64) at multidimensional.jl:491",
          "unique{T}(A::AbstractArray{T,2},dim::Int64) at multidimensional.jl:491",
          "unique{T}(A::AbstractArray{T,3},dim::Int64) at multidimensional.jl:491",
          "unique{T}(A::AbstractArray{T,4},dim::Int64) at multidimensional.jl:491",
          "unique{T,N}(A::AbstractArray{T,N},dim::Int64) at cartesian.jl:100",
          "unique(C) at set.jl:99"
        ]
      },
      {
        "name": "unsafe_assign",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "unsafe_assign(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "unsafe_copy!",
        "summary": "Function",
        "help": "Base.unsafe_copy!(dest::Ptr{T}, src::Ptr{T}, N)\n\n   Copy \"N\" elements from a source pointer to a destination, with no\n   checking. The size of an element is determined by the type of the\n   pointers.\n\nBase.unsafe_copy!(dest::Array, do, src::Array, so, N)\n\n   Copy \"N\" elements from a source array to a destination, starting\n   at offset \"so\" in the source and \"do\" in the destination\n   (1-indexed).\n",
        "methods": 
        [
          "unsafe_copy!{T}(dest::Ptr{T},src::Ptr{T},N) at array.jl:34",
          "unsafe_copy!{T}(dest::Array{T,N},dsto,src::Array{T,N},so,N) at array.jl:40"
        ]
      },
      {
        "name": "unsafe_load",
        "summary": "Function",
        "help": "Base.unsafe_load(p::Ptr{T}, i::Integer)\n\n   Load a value of type \"T\" from the address of the ith element\n   (1-indexed) starting at \"p\". This is equivalent to the C\n   expression \"p[i-1]\".\n",
        "methods": 
        [
          "unsafe_load(p::Ptr{T},i::Integer) at pointer.jl:47",
          "unsafe_load(p::Ptr{T}) at pointer.jl:48"
        ]
      },
      {
        "name": "unsafe_pointer_to_objref",
        "summary": "Function",
        "help": "Base.unsafe_pointer_to_objref(p::Ptr)\n\n   Convert a \"Ptr\" to an object reference. Assumes the pointer\n   refers to a valid heap-allocated Julia object. If this is not the\n   case, undefined behavior results, hence this function is considered\n   \"unsafe\" and should be used with care.\n",
        "methods": 
        [
          "unsafe_pointer_to_objref(p::Ptr{T}) at pointer.jl:54"
        ]
      },
      {
        "name": "unsafe_ref",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "unsafe_ref(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "unsafe_store!",
        "summary": "Function",
        "help": "Base.unsafe_store!(p::Ptr{T}, x, i::Integer)\n\n   Store a value of type \"T\" to the address of the ith element\n   (1-indexed) starting at \"p\". This is equivalent to the C\n   expression \"p[i-1] = x\".\n",
        "methods": 
        [
          "unsafe_store!(p::Ptr{Any},x::ANY,i::Integer) at pointer.jl:49",
          "unsafe_store!{T}(p::Ptr{T},x,i::Integer) at pointer.jl:50",
          "unsafe_store!{T}(p::Ptr{T},x) at pointer.jl:51"
        ]
      },
      {
        "name": "unshift!",
        "summary": "Function",
        "help": "Base.unshift!(collection, items...) -> collection\n\n   Insert items at the beginning of a collection.\n",
        "methods": 
        [
          "unshift!{T}(a::Array{T,1},item) at array.jl:521",
          "unshift!(B::BitArray{1},item) at bitarray.jl:550",
          "unshift!{T}(q::Deque{T},x) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:214",
          "unshift!(A) at abstractarray.jl:1382",
          "unshift!(A,a,b) at abstractarray.jl:1383",
          "unshift!(A,a,b,c...) at abstractarray.jl:1384"
        ]
      },
      {
        "name": "unsigned",
        "summary": "Function",
        "help": "Base.unsigned(x) -> Unsigned\n\n   Convert a number to an unsigned integer\n",
        "methods": 
        [
          "unsigned(x::FloatingPoint) at int.jl:514",
          "unsigned(x::Ptr{T}) at pointer.jl:58",
          "unsigned(z::Complex{T<:Real}) at complex.jl:60",
          "unsigned(x::Rational{T<:Integer}) at rational.jl:171",
          "unsigned(r::StepRange{T,S}) at abstractarray.jl:327",
          "unsigned(r::UnitRange{T<:Real}) at abstractarray.jl:328",
          "unsigned{T<:Unsigned}(x::AbstractArray{T<:Unsigned,N}) at abstractarray.jl:285",
          "unsigned(x::AbstractArray{T,N}) at abstractarray.jl:288",
          "unsigned(s::String) at string.jl:1546",
          "unsigned(x) at int.jl:365"
        ]
      },
      {
        "name": "uperm",
        "summary": "Function",
        "help": "Base.uperm(file)\n\n   Gets the permissions of the owner of the file as a bitfield of\n\n   +------+-----------------------+\n   | 01   | Execute Permission    |\n   +------+-----------------------+\n   | 02   | Write Permission      |\n   +------+-----------------------+\n   | 04   | Read Permission       |\n   +------+-----------------------+\n\n   For allowed arguments, see the stat method.\n",
        "methods": 
        [
          "uperm(st::StatStruct) at stat.jl:80",
          "uperm(path...) at stat.jl:105"
        ]
      },
      {
        "name": "uppercase",
        "summary": "Function",
        "help": "Base.uppercase(string)\n\n   Returns \"string\" with all characters converted to uppercase.\n",
        "methods": 
        [
          "uppercase(s::ASCIIString) at ascii.jl:59",
          "uppercase(c::Char) at string.jl:795",
          "uppercase(s::String) at string.jl:798"
        ]
      },
      {
        "name": "user_documentsdir",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "user_documentsdir(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "user_homedir",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "user_homedir(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "user_prefdir",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "user_prefdir(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "usingmodule",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "usingmodule(names::Symbol...) at deprecated.jl:347",
          "usingmodule(names::String) at deprecated.jl:351"
        ]
      },
      {
        "name": "utf16",
        "summary": "Function",
        "help": "Base.utf16(s)\n\n   Create a UTF-16 string from a byte array, array of \"Uint16\", or\n   any other string type.  (Data must be valid UTF-16.  Conversions of\n   byte arrays check for a byte-order marker in the first two bytes,\n   and do not include it in the resulting string.)\n",
        "methods": 
        [
          "utf16(x) at utf16.jl:40"
        ]
      },
      {
        "name": "utf32",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "utf32(x) at string.jl:578"
        ]
      },
      {
        "name": "utf8",
        "summary": "Function",
        "help": "Base.utf8(::Array{Uint8, 1})\n\n   Create a UTF-8 string from a byte array.\n\nBase.utf8(s)\n\n   Convert a string to a contiguous UTF-8 string (all characters must\n   be valid UTF-8 characters).\n",
        "methods": 
        [
          "utf8(x) at utf8.jl:161"
        ]
      },
      {
        "name": "values",
        "summary": "Function",
        "help": "Base.values(collection)\n\n   Return an iterator over all values in a collection.\n   \"collect(values(d))\" returns an array of values.\n",
        "methods": 
        [
          "values(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "values(a::Associative{K,V}) at dict.jl:65"
        ]
      },
      {
        "name": "var",
        "summary": "Function",
        "help": "Base.var(v[, region])\n\n   Compute the sample variance of a vector or array \"v\", optionally\n   along dimensions in \"region\". The algorithm will return an\n   estimator of the generative distribution's variance under the\n   assumption that each entry of \"v\" is an IID drawn from that\n   generative distribution. This computation is equivalent to\n   calculating \"sum((v - mean(v)).^2) / (length(v) - 1)\". Note:\n   Julia does not ignore \"NaN\" values in the computation. For\n   applications requiring the handling of missing data, the\n   \"DataArray\" package is recommended.\n",
        "methods": 
        [
          "var(v::Range{T}) at statistics.jl:156",
          "var(v::AbstractArray{T,N}) at statistics.jl:99",
          "var(v::AbstractArray{T,N},region) at statistics.jl:106",
          "var(iterable) at statistics.jl:113"
        ]
      },
      {
        "name": "varm",
        "summary": "Function",
        "help": "Base.varm(v, m)\n\n   Compute the sample variance of a vector \"v\" with known mean\n   \"m\". Note: Julia does not ignore \"NaN\" values in the\n   computation.\n",
        "methods": 
        [
          "varm(v::Range{T},m::Number) at statistics.jl:153",
          "varm(v::AbstractArray{T,N},m::Number) at statistics.jl:80",
          "varm{S,T,N}(v::AbstractArray{S,N},m::AbstractArray{T,N},region) at statistics.jl:96",
          "varm(iterable,m::Number) at statistics.jl:148"
        ]
      },
      {
        "name": "vcat",
        "summary": "Function",
        "help": "Base.vcat(A...)\n\n   Concatenate along dimension 1\n",
        "methods": 
        [
          "vcat(r::CalendarTimeRange{T<:AbstractCalendarDuration}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:409",
          "vcat{T}(r::Range{T}) at range.jl:463",
          "vcat() at abstractarray.jl:496",
          "vcat{T}(rs::Range{T}...) at range.jl:476",
          "vcat{T<:Number}(X::T<:Number...) at abstractarray.jl:503",
          "vcat(X::Number...) at abstractarray.jl:506",
          "vcat{T}(arrays::Array{T,1}...) at array.jl:988",
          "vcat(V::BitArray{1}...) at bitarray.jl:1592",
          "vcat(A::BitArray{2}...) at bitarray.jl:1630",
          "vcat(X::SparseMatrixCSC{Tv,Ti<:Integer}...) at sparse/sparsematrix.jl:1457",
          "vcat{T}(V::AbstractArray{T,1}...) at abstractarray.jl:530",
          "vcat{T}(A::AbstractArray{T,2}...) at abstractarray.jl:579",
          "vcat(A::AbstractArray{T,N}...) at abstractarray.jl:721",
          "vcat{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32},B::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:828",
          "vcat{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64},B::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:828",
          "vcat{T}(X::T...) at abstractarray.jl:502",
          "vcat(X...) at abstractarray.jl:655"
        ]
      },
      {
        "name": "vec",
        "summary": "Function",
        "help": "Base.vec(Array) -> Vector\n\n   Vectorize an array using column-major convention.\n",
        "methods": 
        [
          "vec(a::AbstractArray{T,1}) at abstractarray.jl:130",
          "vec(a::AbstractArray{T,N}) at abstractarray.jl:129"
        ]
      },
      {
        "name": "vecnorm",
        "summary": "Function",
        "help": "Base.vecnorm(A[, p])\n\n   For any iterable container \"A\" (including arrays of any\n   dimension) of numbers, compute the \"p\"-norm (defaulting to\n   \"p=2\") as if \"A\" were a vector of the corresponding length.\n\n   For example, if \"A\" is a matrix and \"p=2\", then this is\n   equivalent to the Frobenius norm.\n",
        "methods": 
        [
          "vecnorm(x::Number) at linalg/generic.jl:154",
          "vecnorm(x::Number,p::Real) at linalg/generic.jl:154",
          "vecnorm(A::SparseMatrixCSC{Tv,Ti<:Integer}) at linalg/sparse.jl:479",
          "vecnorm(A::SparseMatrixCSC{Tv,Ti<:Integer},p::Real) at linalg/sparse.jl:479",
          "vecnorm(itr) at linalg/generic.jl:145",
          "vecnorm(itr,p::Real) at linalg/generic.jl:145"
        ]
      },
      {
        "name": "versioninfo",
        "summary": "Function",
        "help": "Base.versioninfo([verbose::Bool])\n\n   Print information about the version of Julia in use. If the\n   \"verbose\" argument is true, detailed system information is shown\n   as well.\n",
        "methods": 
        [
          "versioninfo() at interactiveutil.jl:136",
          "versioninfo(io::IO) at interactiveutil.jl:136",
          "versioninfo(io::IO,verbose::Bool) at interactiveutil.jl:136",
          "versioninfo(verbose::Bool) at interactiveutil.jl:185"
        ]
      },
      {
        "name": "wait",
        "summary": "Function",
        "help": "Base.wait([x])\n\n   Block the current task until some event occurs, depending on the\n   type of the argument:\n\n   * \"RemoteRef\": Wait for a value to become available for the\n     specified remote reference.\n\n   * \"Condition\": Wait for \"notify\" on a condition.\n\n   * \"Process\": Wait for a process or process chain to exit. The\n     \"exitcode\" field of a process can be used to determine success\n     or failure.\n\n   * \"Task\": Wait for a \"Task\" to finish, returning its result\n     value.\n\n   * \"RawFD\": Wait for changes on a file descriptor (see *poll_fd*\n     for keyword arguments and return code)\n\n   If no argument is passed, the task blocks for an undefined period.\n   If the task's state is set to \":waiting\", it can only be\n   restarted by an explicit call to \"schedule\" or \"yieldto\". If\n   the task's state is \":runnable\", it might be restarted\n   unpredictably.\n\n   Often \"wait\" is called within a \"while\" loop to ensure a\n   waited-for condition is met before proceeding.\n",
        "methods": 
        [
          "wait(t::Task) at task.jl:42",
          "wait(c::Condition) at task.jl:183",
          "wait() at task.jl:266",
          "wait(x::Process) at process.jl:611",
          "wait(x::ProcessChain) at process.jl:612",
          "wait(r::RemoteRef) at multi.jl:748",
          "wait(fd::RawFD) at poll.jl:182",
          "wait(pfw::PollingFileWatcher) at poll.jl:220",
          "wait(m::FileMonitor) at poll.jl:231"
        ]
      },
      {
        "name": "wait_accept",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "wait_accept(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "warn",
        "summary": "Function",
        "help": "Base.warn(msg)\n\n   Display a warning.\n",
        "methods": 
        [
          "warn(msg::String...) at util.jl:188",
          "warn(err::Exception) at util.jl:205"
        ]
      },
      {
        "name": "watch_file",
        "summary": "Function",
        "help": "Base.watch_file(cb=false, s; poll=false)\n\n   Watch file or directory \"s\" and run callback \"cb\" when \"s\" is\n   modified. The \"poll\" parameter specifies whether to use file\n   system event monitoring or polling. The callback function \"cb\"\n   should accept 3 arguments: \"(filename, events, status)\" where\n   \"filename\" is the name of file that was modified, \"events\" is\n   an object with boolean fields \"changed\" and \"renamed\" when\n   using file system event monitoring, or \"readable\" and\n   \"writable\" when using polling, and \"status\" is always 0. Pass\n   \"false\" for \"cb\" to not use a callback function.\n",
        "methods": 
        [
          "watch_file(s) at poll.jl:322",
          "watch_file(cb,s) at poll.jl:324"
        ]
      },
      {
        "name": "which",
        "summary": "Function",
        "help": "Base.which(f, types)\n\n   Return the method of \"f\" (a \"Method\" object) that will be\n   called for arguments with the given types.\n",
        "methods": 
        [
          "which(f::Union(DataType,Function),t::(Type{T<:Top}...,)) at interactiveutil.jl:190",
          "which(f::Union(DataType,Function),args...) at deprecated.jl:26"
        ]
      },
      {
        "name": "whos",
        "summary": "Function",
        "help": "Base.whos([Module,] [pattern::Regex])\n\n   Print information about global variables in a module, optionally\n   restricted to those matching \"pattern\".\n",
        "methods": 
        [
          "whos(m::Module,pattern::Regex) at show.jl:937",
          "whos() at show.jl:944",
          "whos(m::Module) at show.jl:945",
          "whos(pat::Regex) at show.jl:946"
        ]
      },
      {
        "name": "widemul",
        "summary": "Function",
        "help": "Base.widemul(x, y)\n\n   Multiply \"x\" and \"y\", giving the result as a larger type.\n",
        "methods": 
        [
          "widemul(x::Int128,y::Uint128) at gmp.jl:439",
          "widemul(x::Uint128,y::Int128) at gmp.jl:440",
          "widemul(x::Number,y::Number) at number.jl:34"
        ]
      },
      {
        "name": "widen",
        "summary": "Function",
        "help": "Base.widen(type | x)\n\n   If the argument is a type, return a \"larger\" type (for numeric\n   types, this will be a type with at least as much range and\n   precision as the argument, and usually more). Otherwise the\n   argument \"x\" is converted to \"widen(typeof(x))\".\n\n   **Examples**:\n\n      julia> widen(Int32)\n      Int64\n\n      julia> widen(1.5f0)\n      1.5\n",
        "methods": 
        [
          "widen(::Type{Int8}) at int.jl:493",
          "widen(::Type{Int16}) at int.jl:494",
          "widen(::Type{Int32}) at int.jl:495",
          "widen(::Type{Int64}) at int.jl:496",
          "widen(::Type{Uint8}) at int.jl:497",
          "widen(::Type{Uint16}) at int.jl:498",
          "widen(::Type{Uint32}) at int.jl:499",
          "widen(::Type{Uint64}) at int.jl:500",
          "widen{T<:Number}(x::T<:Number) at operators.jl:160",
          "widen(::Type{Float16}) at float.jl:116",
          "widen(::Type{Float32}) at float.jl:117",
          "widen{T}(::Type{Complex{T}}) at complex.jl:29",
          "widen{T}(::Type{Rational{T}}) at rational.jl:65",
          "widen(::Type{Int128}) at gmp.jl:45",
          "widen(::Type{Uint128}) at gmp.jl:46",
          "widen(::Type{BigInt}) at gmp.jl:47",
          "widen(::Type{Float64}) at mpfr.jl:49",
          "widen(::Type{BigFloat}) at mpfr.jl:50"
        ]
      },
      {
        "name": "with_bigfloat_precision",
        "summary": "Function",
        "help": "Base.with_bigfloat_precision(f::Function, precision::Integer)\n\n   Change the BigFloat arithmetic precision (in bits) for the duration\n   of \"f\". It is logically equivalent to:\n\n      old = get_bigfloat_precision()\n      set_bigfloat_precision(precision)\n      f()\n      set_bigfloat_precision(old)\n",
        "methods": 
        [
          "with_bigfloat_precision(f::Function,precision::Integer) at mpfr.jl:692"
        ]
      },
      {
        "name": "with_bigfloat_rounding",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "with_bigfloat_rounding(f::Function,r::RoundingMode) at deprecated.jl:26"
        ]
      },
      {
        "name": "with_rounding",
        "summary": "Function",
        "help": "Base.with_rounding(f::Function, T, mode)\n\n   Change the rounding mode of floating point type \"T\" for the\n   duration of \"f\". It is logically equivalent to:\n\n      old = get_rounding(T)\n      set_rounding(T, mode)\n      f()\n      set_rounding(T, old)\n\n   See \"get_rounding\" for available rounding modes.\n",
        "methods": 
        [
          "with_rounding{T}(f::Function,::Type{T},rounding::RoundingMode) at rounding.jl:53",
          "with_rounding(f::Function,r::RoundingMode) at deprecated.jl:26"
        ]
      },
      {
        "name": "workers",
        "summary": "Function",
        "help": "Base.workers()\n\n   Returns a list of all worker process identifiers.\n",
        "methods": 
        [
          "workers() at multi.jl:286"
        ]
      },
      {
        "name": "write",
        "summary": "Function",
        "help": "Base.write(stream, x)\n\n   Write the canonical binary representation of a value to the given\n   stream.\n",
        "methods": 
        [
          "write(s::IO,z::Complex{T<:Real}) at complex.jl:89",
          "write(io::IO,s::ASCIIString) at ascii.jl:94",
          "write(io::IO,s::UTF8String) at utf8.jl:157",
          "write(to::IOBuffer,from::IOBuffer) at iobuffer.jl:198",
          "write(to::IOBuffer,p::Ptr{T},nb::Int64) at iobuffer.jl:204",
          "write(to::IOBuffer,p::Ptr{T},nb::Integer) at iobuffer.jl:202",
          "write(to::IOBuffer,a::Array{T,N}) at iobuffer.jl:229",
          "write(to::IOBuffer,a::Uint8) at iobuffer.jl:232",
          "write(to::IOBuffer,p::Ptr{T}) at iobuffer.jl:245",
          "write{T<:Union(UTF8String,ASCIIString)}(to::IOBuffer,s::SubString{T<:Union(UTF8String,ASCIIString)}) at string.jl:620",
          "write(io::IO,s::RopeString) at string.jl:790",
          "write(io::IO,s::String) at string.jl:68",
          "write(b::Base64Pipe,x::AbstractArray{Uint8,1}) at base64.jl:56",
          "write(b::Base64Pipe,x::Uint8) at base64.jl:97",
          "write(s::IOStream,b::Uint8) at io.jl:381",
          "write(s::AsyncStream,b::Uint8) at stream.jl:750",
          "write(f::File,c::Uint8) at fs.jl:163",
          "write(t::UnixTerminal,x::Uint8) at Terminals.jl:176",
          "write(s::IO,x::Uint8) at io.jl:30",
          "write(s::IO,x::Bool) at io.jl:53",
          "write(s::IOStream,c::Char) at io.jl:443",
          "write(s::AsyncStream,c::Char) at stream.jl:758",
          "write(s::IO,c::Char) at io.jl:67",
          "write(s::IO,x::Integer) at io.jl:45",
          "write(s::IO,x::Float16) at io.jl:54",
          "write(s::IO,x::Float32) at io.jl:55",
          "write(s::IO,x::Float64) at io.jl:56",
          "write{T}(s::IOStream,a::Array{T,N}) at io.jl:384",
          "write{T,N,A<:Array{T,N}}(s::IOStream,a::SubArray{T,N,A<:Array{T,N},I<:(Union(Range{Int64},Int64)...,)}) at io.jl:403",
          "write(s::IO,B::BitArray{N}) at io.jl:556",
          "write{T}(s::AsyncStream,a::Array{T,N}) at stream.jl:766",
          "write{T}(f::File,a::Array{T,N}) at fs.jl:172",
          "write{T,N}(t::UnixTerminal,a::Array{T,N}) at Terminals.jl:173",
          "write(io::Session,data::Array{Uint8,1}) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:347",
          "write{T}(s::Session,a::Array{T,N}) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:414",
          "write(s::IO,a::AbstractArray{T,N}) at io.jl:59",
          "write(s::IOStream,p::Ptr{T},nb::Integer) at io.jl:396",
          "write(s::AsyncStream,p::Ptr{T},nb::Integer) at stream.jl:780",
          "write(f::File,buf::Ptr{Uint8},len::Integer) at fs.jl:153",
          "write(f::File,buf::Ptr{Uint8},len::Integer,offset::Integer) at fs.jl:153",
          "write(t::UnixTerminal,p::Ptr{Uint8}) at Terminals.jl:174",
          "write(t::UnixTerminal,p::Ptr{Uint8},x::Integer) at Terminals.jl:175",
          "write(io::Session,data::Ptr{Uint8},size::Integer) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:335",
          "write(s::IO,p::Ptr{T},n::Integer) at io.jl:91",
          "write(io::IO,s::Symbol) at io.jl:98",
          "write(io::IO,x) at io.jl:32",
          "write(io::IO,xs...) at io.jl:33",
          "write(io::ChunkedStream,arg) at /home/samuel/.julia/v0.3/Requests/src/Requests.jl:251",
          "write(x) at io.jl:471"
        ]
      },
      {
        "name": "writecsv",
        "summary": "Function",
        "help": "Base.writecsv(filename, A)\n\n   Equivalent to \"writedlm\" with \"delim\" set to comma.\n",
        "methods": 
        [
          "writecsv(io,a) at datafmt.jl:538"
        ]
      },
      {
        "name": "writedlm",
        "summary": "Function",
        "help": "Base.writedlm(f, A, delim='t')\n\n   Write \"A\" (either an array type or an iterable collection of\n   iterable rows) as text to \"f\" (either a filename string or an\n   \"IO\" stream) using the given delimeter \"delim\" (which defaults\n   to tab, but can be any printable Julia object, typically a \"Char\"\n   or \"String\").\n\n   For example, two vectors \"x\" and \"y\" of the same length can be\n   written as two columns of tab-delimited text to \"f\" by either\n   \"writedlm(f, [x y])\" or by \"writedlm(f, zip(x, y))\".\n",
        "methods": 
        [
          "writedlm(io::IO,a::Union(AbstractArray{T,2},AbstractArray{T,1}),dlm) at datafmt.jl:485",
          "writedlm{T}(io::IO,a::AbstractArray{T,0},dlm) at datafmt.jl:501",
          "writedlm(io::IO,a::AbstractArray{T,N},dlm) at datafmt.jl:504",
          "writedlm(io::IO,itr,dlm) at datafmt.jl:515",
          "writedlm(fname::String,a,dlm) at datafmt.jl:532",
          "writedlm(io,a) at datafmt.jl:537"
        ]
      },
      {
        "name": "writemime",
        "summary": "Function",
        "help": "Base.writemime(stream, mime, x)\n\n   The \"display\" functions ultimately call \"writemime\" in order to\n   write an object \"x\" as a given \"mime\" type to a given I/O\n   \"stream\" (usually a memory buffer), if possible.  In order to\n   provide a rich multimedia representation of a user-defined type\n   \"T\", it is only necessary to define a new \"writemime\" method\n   for \"T\", via: \"writemime(stream, ::MIME\"mime\", x::T) = ...\",\n   where \"mime\" is a MIME-type string and the function body calls\n   \"write\" (or similar) to write that representation of \"x\" to\n   \"stream\". (Note that the \"MIME\"\"\" notation only supports\n   literal strings; to construct \"MIME\" types in a more flexible\n   manner use \"MIME{symbol(\"\")}\".)\n\n   For example, if you define a \"MyImage\" type and know how to write\n   it to a PNG file, you could define a function \"writemime(stream,\n   ::MIME\"image/png\", x::MyImage) = ...`\" to allow your images to\n   be displayed on any PNG-capable \"Display\" (such as IJulia). As\n   usual, be sure to \"import Base.writemime\" in order to add new\n   methods to the built-in Julia function \"writemime\".\n\n   Technically, the \"MIME\"mime\"\" macro defines a singleton type\n   for the given \"mime\" string, which allows us to exploit Julia's\n   dispatch mechanisms in determining how to display objects of any\n   given type.\n",
        "methods": 
        [
          "writemime(io,m::String,x) at multimedia.jl:41",
          "writemime(io::IO,::MIME{:text/html},m::Method) at methodshow.jl:107",
          "writemime(io::IO,mime::MIME{:text/html},mt::MethodTable) at methodshow.jl:130",
          "writemime(io::IO,mime::MIME{:text/html},mt::AbstractArray{Method,1}) at methodshow.jl:146",
          "writemime(io::IO,mime::MIME{:text/plain},mt::AbstractArray{Method,1}) at methodshow.jl:158",
          "writemime(io::IO,::MIME{:text/csv},a::Union(AbstractArray{T,2},AbstractArray{T,1})) at datafmt.jl:540",
          "writemime(io::IO,::MIME{:text/tab-separated-values},a::Union(AbstractArray{T,2},AbstractArray{T,1})) at datafmt.jl:541",
          "writemime(io::IO,::MIME{:text/plain},f::Function) at replutil.jl:5",
          "writemime(io::IO,::MIME{:text/plain},v::AbstractArray{T,1}) at replutil.jl:15",
          "writemime(io::IO,::MIME{:text/plain},v::AbstractArray{T,N}) at replutil.jl:26",
          "writemime(io::IO,::MIME{:text/plain},v::DataType) at replutil.jl:30",
          "writemime(io,::MIME{:text/plain},x) at replutil.jl:2"
        ]
      },
      {
        "name": "writesto",
        "summary": "Function",
        "help": "Base.writesto(command)\n\n   Starts running a command asynchronously, and returns a tuple\n   (stream,process). The first value is a stream writing to the\n   process' standard input.\n",
        "methods": 
        [
          "writesto(cmds::AbstractCmd,stdout::AsyncStream) at process.jl:435",
          "writesto(cmds::AbstractCmd) at process.jl:438"
        ]
      },
      {
        "name": "xcorr",
        "summary": "Function",
        "help": "Base.xcorr(u, v)\n\n   Compute the cross-correlation of two vectors.\n",
        "methods": 
        [
          "xcorr(u,v) at dsp.jl:136"
        ]
      },
      {
        "name": "xdump",
        "summary": "Function",
        "help": "Base.xdump(x)\n\n   Show all structure of a value, including all fields of objects.\n",
        "methods": 
        [
          "xdump(fn::Function,io::IO,x::Module,n::Int64,indent) at show.jl:579",
          "xdump(fn::Function,io::IO,x::Array{Any,N},n::Int64,indent) at show.jl:593",
          "xdump(fn::Function,io::IO,x::Symbol,n::Int64,indent) at show.jl:602",
          "xdump(fn::Function,io::IO,x::Function,n::Int64,indent) at show.jl:603",
          "xdump(fn::Function,io::IO,x::Array{T,N},n::Int64,indent) at show.jl:604",
          "xdump(fn::Function,io::IO,x::UnionType,n::Int64,indent) at show.jl:609",
          "xdump(fn::Function,io::IO,x::DataType,n::Int64,indent) at show.jl:611",
          "xdump(fn::Function,io::IO,x::DataType) at show.jl:673",
          "xdump(fn::Function,io::IO,x::DataType,n::Int64) at show.jl:674",
          "xdump(fn::Function,io::IO,x,n::Int64,indent) at show.jl:558",
          "xdump(fn::Function,io::IO,x) at show.jl:677",
          "xdump(fn::Function,io::IO,x,n::Int64) at show.jl:678",
          "xdump(fn::Function,io::IO,args...) at show.jl:679",
          "xdump(fn::Function,args...) at show.jl:680",
          "xdump(io::IO,args...) at show.jl:681",
          "xdump(args...) at show.jl:682"
        ]
      },
      {
        "name": "yield",
        "summary": "Function",
        "help": "Base.yield()\n\n   Switch to the scheduler to allow another scheduled task to run. A\n   task that calls this function is still runnable, and will be\n   restarted immediately if there are no other runnable tasks.\n",
        "methods": 
        [
          "yield() at task.jl:263"
        ]
      },
      {
        "name": "zero",
        "summary": "Function",
        "help": "Base.zero(x)\n\n   Get the additive identity element for the type of x (x can also\n   specify the type itself).\n",
        "methods": 
        [
          "zero(x::Number) at number.jl:46",
          "zero{T<:Number}(::Type{T<:Number}) at number.jl:47",
          "zero{T}(::Type{Ptr{T}}) at pointer.jl:72",
          "zero{T}(x::Ptr{T}) at pointer.jl:73",
          "zero{T}(x::AbstractArray{T,N}) at abstractarray.jl:241",
          "zero{T}(::Type{UniformScaling{T}}) at linalg/uniformscaling.jl:22",
          "zero{T}(J::UniformScaling{T}) at linalg/uniformscaling.jl:23",
          "zero{T}(::Type{HierarchicalValue{T}}) at pkg/resolve/versionweight.jl:13",
          "zero(::Type{VWPreBuildItem}) at pkg/resolve/versionweight.jl:77",
          "zero(::Type{VWPreBuild}) at pkg/resolve/versionweight.jl:115",
          "zero(::Type{VersionWeight}) at pkg/resolve/versionweight.jl:155",
          "zero(::Type{FieldValue}) at pkg/resolve/fieldvalue.jl:36"
        ]
      },
      {
        "name": "zeros",
        "summary": "Function",
        "help": "Base.zeros(type, dims)\n\n   Create an array of all zeros of specified type\n",
        "methods": 
        [
          "zeros{T}(::Type{T},dims...) at array.jl:169",
          "zeros{T}(x::AbstractArray{T,N}) at array.jl:171",
          "zeros(dims...) at array.jl:170"
        ]
      },
      {
        "name": "zeta",
        "summary": "Function",
        "help": "Base.zeta(x)\n\n   Riemann zeta function \\zeta(s).\n",
        "methods": 
        [
          "zeta(x::BigFloat) at mpfr.jl:397",
          "zeta(z::Number) at math.jl:1229",
          "zeta{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "zeta{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "zeta{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "zip",
        "summary": "Function",
        "help": "Base.zip(iters...)\n\n   For a set of iterable objects, returns an iterable of tuples, where\n   the \"i\"th tuple contains the \"i\"th component of each input\n   iterable.\n\n   Note that \"zip\" is its own inverse: \"[zip(zip(a...)...)...] ==\n   [a...]\".\n",
        "methods": 
        [
          "zip(a,b) at iterator.jl:52",
          "zip(itrs...) at iterator.jl:28"
        ]
      },
      {
        "name": "|",
        "summary": "Function",
        "help": "Base.|(x, y)\n\n   Bitwise or\n",
        "methods": 
        [
          "|(x::Bool,y::Bool) at bool.jl:23",
          "|(x::Int8,y::Int8) at int.jl:134",
          "|(x::Int16,y::Int16) at int.jl:135",
          "|(x::Int32,y::Int32) at int.jl:136",
          "|(x::Int64,y::Int64) at int.jl:137",
          "|(x::Int128,y::Int128) at int.jl:138",
          "|(x::Uint8,y::Uint8) at int.jl:140",
          "|(x::Uint16,y::Uint16) at int.jl:141",
          "|(x::Uint32,y::Uint32) at int.jl:142",
          "|(x::Uint64,y::Uint64) at int.jl:143",
          "|(x::Uint128,y::Uint128) at int.jl:144",
          "|(A::BitArray{N},B::BitArray{N}) at bitarray.jl:963",
          "|(A::DenseArray{Bool,N},B::BitArray{N}) at bitarray.jl:974",
          "|(B::BitArray{N},A::DenseArray{Bool,N}) at bitarray.jl:975",
          "|{S,T}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:724",
          "|(x::Char,y::Char) at char.jl:34",
          "|(x::BigInt,y::BigInt) at gmp.jl:193",
          "|(a::BigInt,b::BigInt,c::BigInt) at gmp.jl:216",
          "|(a::BigInt,b::BigInt,c::BigInt,d::BigInt) at gmp.jl:222",
          "|(a::BigInt,b::BigInt,c::BigInt,d::BigInt,e::BigInt) at gmp.jl:229",
          "|{T<:Integer}(x::T<:Integer,y::T<:Integer) at promotion.jl:195",
          "|(x::Integer,y::Integer) at promotion.jl:165",
          "|(x::Bool,B::BitArray{N}) at bitarray.jl:953",
          "|(x::Integer) at operators.jl:74",
          "|{S,T<:Real}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Range{T<:Real}) at array.jl:732",
          "|{S<:Real,T}(A::Range{S<:Real},B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:741",
          "|(x::Number,B::BitArray{N}) at bitarray.jl:976",
          "|{T}(A::Number,B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:754",
          "|(B::BitArray{N},x::Bool) at bitarray.jl:951",
          "|(B::BitArray{N},x::Number) at bitarray.jl:977",
          "|{T}(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Number) at array.jl:761",
          "|(s::Set{T}...) at deprecated.jl:26",
          "|(s::IntSet,s2::IntSet) at deprecated.jl:26",
          "|(a::AbstractCmd,b::AbstractCmd) at deprecated.jl:26",
          "|(a::SynchronousStepCollection,b::Function) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:282",
          "|(x,f::Function) at deprecated.jl:26",
          "|(a::BuildStep,b::BuildStep) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:273",
          "|(a::SynchronousStepCollection,b::SynchronousStepCollection) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:275",
          "|(a::SynchronousStepCollection,b) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:283",
          "|(b::Function,a::SynchronousStepCollection) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:285",
          "|(b,a::SynchronousStepCollection) at /home/samuel/.julia/v0.3/BinDeps/src/BinDeps.jl:286",
          "|(a,b,c) at operators.jl:82",
          "|(a,b,c,xs...) at operators.jl:83"
        ]
      },
      {
        "name": "~",
        "summary": "Function",
        "help": "Base.~(x)\n\n   Bitwise not\n",
        "methods": 
        [
          "~(x::Bool) at bool.jl:21",
          "~(x::Int8) at int.jl:110",
          "~(x::Int16) at int.jl:111",
          "~(x::Int32) at int.jl:112",
          "~(x::Int64) at int.jl:113",
          "~(x::Int128) at int.jl:114",
          "~(x::Uint8) at int.jl:116",
          "~(x::Uint16) at int.jl:117",
          "~(x::Uint32) at int.jl:118",
          "~(x::Uint64) at int.jl:119",
          "~(x::Uint128) at int.jl:120",
          "~(x::Char) at char.jl:32",
          "~(x::BigInt) at gmp.jl:287",
          "~(n::Integer) at int.jl:77",
          "~(B::BitArray{N}) at bitarray.jl:823",
          "~(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:667",
          "~(s::IntSet) at deprecated.jl:26"
        ]
      },
      {
        "name": "×",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "cross(a::AbstractArray{T,1},b::AbstractArray{T,1}) at linalg/generic.jl:23"
        ]
      },
      {
        "name": "÷",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "div(x::Bool,y::Bool) at bool.jl:57",
          "div(x::Signed,y::Unsigned) at int.jl:79",
          "div(x::Unsigned,y::Signed) at int.jl:80",
          "div(A::BitArray{N},B::BitArray{N}) at bitarray.jl:892",
          "div(A::BitArray{N},B::Array{Bool,N}) at bitarray.jl:896",
          "div(A::Array{Bool,N},B::BitArray{N}) at bitarray.jl:897",
          "div{S,T}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:724",
          "div{T<:Union(Int8,Int64,Int16,Int32)}(x::T<:Union(Int8,Int64,Int16,Int32),y::T<:Union(Int8,Int64,Int16,Int32)) at int.jl:97",
          "div{T<:Union(Uint16,Uint8,Uint32,Uint64)}(x::T<:Union(Uint16,Uint8,Uint32,Uint64),y::T<:Union(Uint16,Uint8,Uint32,Uint64)) at int.jl:98",
          "div(x::Int128,y::Int128) at int.jl:592",
          "div(x::Uint128,y::Uint128) at int.jl:593",
          "div(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:148",
          "div(x::Rational{T<:Integer},y::Real) at rational.jl:149",
          "div(x::Real,y::Rational{T<:Integer}) at rational.jl:150",
          "div(x::BigInt,y::BigInt) at gmp.jl:193",
          "div{T<:Real}(x::T<:Real,y::T<:Real) at operators.jl:118",
          "div(x::Real,y::Real) at promotion.jl:172",
          "div{S,T<:Real}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Range{T<:Real}) at array.jl:732",
          "div{S<:Real,T}(A::Range{S<:Real},B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:741",
          "div(x::Bool,B::BitArray{N}) at bitarray.jl:902",
          "div(x::Number,B::BitArray{N}) at bitarray.jl:906",
          "div{T}(A::Number,B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:754",
          "div(B::BitArray{N},x::Bool) at bitarray.jl:899",
          "div(B::BitArray{N},x::Number) at bitarray.jl:936",
          "div{T}(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N}),B::Number) at array.jl:761"
        ]
      },
      {
        "name": "γ",
        "summary": "MathConst{:γ}",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "π",
        "summary": "MathConst{:π}",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "φ",
        "summary": "MathConst{:φ}",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "∈",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "in{T<:Integer}(x,r::Range{T<:Integer}) at range.jl:522",
          "in(x,r::Range{T}) at range.jl:518",
          "in(x::Number,y::Number) at number.jl:40",
          "in(n::Integer,s::IntSet) at intset.jl:121",
          "in(p::(Any,Any),a::Associative{K,V}) at dict.jl:10",
          "in{T<:Dict{K,V}}(key,v::KeyIterator{T<:Dict{K,V}}) at dict.jl:528",
          "in(k::String,::KeyIterator{EnvHash}) at env.jl:77",
          "in{T<:OrderedDict{K,V}}(key,v::KeyIterator{T<:OrderedDict{K,V}}) at /home/samuel/.julia/v0.3/DataStructures/src/ordereddict.jl:44",
          "in{T<:DefaultDictBase{K,V,F,D<:Associative{K,V}}}(key,v::KeyIterator{T<:DefaultDictBase{K,V,F,D<:Associative{K,V}}}) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:53",
          "in{T<:DefaultDict{K,V,F}}(key,v::KeyIterator{T<:DefaultDict{K,V,F}}) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:122",
          "in{T<:DefaultOrderedDict{K,V,F}}(key,v::KeyIterator{T<:DefaultOrderedDict{K,V,F}}) at /home/samuel/.julia/v0.3/DataStructures/src/defaultdict.jl:122",
          "in(k,v::KeyIterator{T<:Associative{K,V}}) at dict.jl:61",
          "in(x,s::Set{T}) at set.jl:16",
          "in(c::Char,s::String) at string.jl:196",
          "in(::String,::String) at string.jl:466",
          "in(v::VersionNumber,i::VersionInterval) at pkg/types.jl:15",
          "in(v::VersionNumber,s::VersionSet) at pkg/types.jl:38",
          "in(x,s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:24",
          "in(x,itr) at reduce.jl:138"
        ]
      },
      {
        "name": "∉",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "∉(x,itr) at reduce.jl:146"
        ]
      },
      {
        "name": "∋",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "∋(itr,x) at reduce.jl:147"
        ]
      },
      {
        "name": "∌",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "∌(itr,x) at reduce.jl:148"
        ]
      },
      {
        "name": "√",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "sqrt(a::Complex{Float16}) at float16.jl:134",
          "sqrt{T<:FloatingPoint}(z::Complex{T<:FloatingPoint}) at complex.jl:237",
          "sqrt(z::Complex{T<:Real}) at complex.jl:261",
          "sqrt(x::Float64) at math.jl:284",
          "sqrt(x::Float32) at math.jl:285",
          "sqrt(a::Float16) at float16.jl:133",
          "sqrt(x::BigFloat) at mpfr.jl:362",
          "sqrt(x::BigInt) at mpfr.jl:370",
          "sqrt(x::Real) at math.jl:286",
          "sqrt{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "sqrt{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "sqrt{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "∛",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "cbrt(x::Float64) at math.jl:253",
          "cbrt(x::Float32) at math.jl:254",
          "cbrt(x::BigFloat) at mpfr.jl:397",
          "cbrt(x::FloatingPoint) at math.jl:261",
          "cbrt(x::Real) at math.jl:255",
          "cbrt{T<:Number}(::AbstractArray{T<:Number,1}) at operators.jl:354",
          "cbrt{T<:Number}(::AbstractArray{T<:Number,2}) at operators.jl:355",
          "cbrt{T<:Number}(::AbstractArray{T<:Number,N}) at operators.jl:357"
        ]
      },
      {
        "name": "∩",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "intersect{T1<:Integer,T2<:Integer}(r::UnitRange{T1<:Integer},s::UnitRange{T2<:Integer}) at range.jl:294",
          "intersect{T<:Integer}(i::Integer,r::UnitRange{T<:Integer}) at range.jl:296",
          "intersect{T<:Integer}(r::UnitRange{T<:Integer},i::Integer) at range.jl:300",
          "intersect{T1<:Integer,T2<:Integer}(r::UnitRange{T1<:Integer},s::StepRange{T2<:Integer,S}) at range.jl:303",
          "intersect{T1<:Integer,T2<:Integer}(r::StepRange{T1<:Integer,S},s::UnitRange{T2<:Integer}) at range.jl:322",
          "intersect{T1<:Integer,T2<:Integer}(r::StepRange{T1<:Integer,S},s::StepRange{T2<:Integer,S}) at range.jl:330",
          "intersect(r::Range{T},s::Range{T}...) at range.jl:375",
          "intersect(s1::IntSet) at intset.jl:229",
          "intersect(s1::IntSet,s2::IntSet) at intset.jl:230",
          "intersect(s1::IntSet,ss::IntSet...) at intset.jl:232",
          "intersect(s::Set{T}) at set.jl:55",
          "intersect(s::Set{T},sets::Set{T}...) at set.jl:57",
          "intersect(a::VersionInterval,b::VersionInterval) at pkg/types.jl:16",
          "intersect(A::VersionSet,B::VersionSet) at pkg/types.jl:40",
          "intersect(s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:58",
          "intersect(s::OrderedSet{T},sets...) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:60",
          "intersect(v1,vs...) at array.jl:1322"
        ]
      },
      {
        "name": "∪",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "union(s1::IntSet) at intset.jl:208",
          "union(s1::IntSet,s2::IntSet) at intset.jl:209",
          "union(s1::IntSet,ss::IntSet...) at intset.jl:210",
          "union() at set.jl:43",
          "union(s::Set{T}) at set.jl:44",
          "union(s::Set{T},sets::Set{T}...) at set.jl:46",
          "union(s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:48",
          "union(s::OrderedSet{T},sets...) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:50",
          "union(vs...) at array.jl:1338"
        ]
      },
      {
        "name": "≠",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "!=(x::Float32,y::Float32) at float.jl:146",
          "!=(x::Float64,y::Float64) at float.jl:147",
          "!=(A::BitArray{N},B::BitArray{N}) at bitarray.jl:1065",
          "!=(x,y) at operators.jl:26"
        ]
      },
      {
        "name": "≡",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "≢",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "!==(x,y) at operators.jl:29"
        ]
      },
      {
        "name": "≤",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "<=(x::Bool,y::Bool) at bool.jl:32",
          "<=(x::Int8,y::Int8) at int.jl:256",
          "<=(x::Int16,y::Int16) at int.jl:257",
          "<=(x::Int32,y::Int32) at int.jl:258",
          "<=(x::Int64,y::Int64) at int.jl:259",
          "<=(x::Int128,y::Int128) at int.jl:260",
          "<=(x::Uint8,y::Uint8) at int.jl:262",
          "<=(x::Uint16,y::Uint16) at int.jl:263",
          "<=(x::Uint32,y::Uint32) at int.jl:264",
          "<=(x::Uint64,y::Uint64) at int.jl:265",
          "<=(x::Uint128,y::Uint128) at int.jl:266",
          "<=(x::Signed,y::Unsigned) at int.jl:272",
          "<=(x::Unsigned,y::Signed) at int.jl:273",
          "<=(x::Float32,y::Float32) at float.jl:150",
          "<=(x::Float64,y::Float64) at float.jl:151",
          "<=(x::Float64,y::Int64) at float.jl:193",
          "<=(x::Float64,y::Uint64) at float.jl:194",
          "<=(x::Int64,y::Float64) at float.jl:195",
          "<=(x::Uint64,y::Float64) at float.jl:196",
          "<=(x::Float32,y::Int64) at float.jl:198",
          "<=(x::Float32,y::Uint64) at float.jl:199",
          "<=(x::Int64,y::Float32) at float.jl:200",
          "<=(x::Uint64,y::Float32) at float.jl:201",
          "<=(x::Float32,y::Union(Uint32,Int32)) at float.jl:209",
          "<=(x::Union(Uint32,Int32),y::Float32) at float.jl:210",
          "<=(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:141",
          "<=(x::Rational{T<:Integer},y::Integer) at rational.jl:143",
          "<=(x::Rational{T<:Integer},y::Real) at rational.jl:144",
          "<=(x::Integer,y::Rational{T<:Integer}) at rational.jl:145",
          "<=(x::Real,y::Rational{T<:Integer}) at rational.jl:146",
          "<=(x::Char,y::Char) at char.jl:44",
          "<=(a::Float16,b::Float16) at float16.jl:128",
          "<=(x::BigInt,y::BigInt) at gmp.jl:410",
          "<=(x::BigFloat,y::BigFloat) at mpfr.jl:578",
          "<=(x::Real,y::Real) at promotion.jl:170",
          "<=(a::IntSet,b::IntSet) at intset.jl:291",
          "<=(l::Set{T},r::Set{T}) at set.jl:84",
          "<=(l::OrderedSet{T},r::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:84",
          "<=(x,y) at operators.jl:34"
        ]
      },
      {
        "name": "≥",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          ">=(x::BigInt,y::BigInt) at gmp.jl:411",
          ">=(x::BigFloat,y::BigFloat) at mpfr.jl:579",
          ">=(x,y) at operators.jl:36"
        ]
      },
      {
        "name": "⊆",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "issubset(a::IntSet,b::IntSet) at intset.jl:289",
          "issubset(l,r) at set.jl:87"
        ]
      },
      {
        "name": "⊈",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "⊈(l::Set{T},r::Set{T}) at set.jl:96"
        ]
      },
      {
        "name": "⊊",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "⊊(l::Set{T},r::Set{T}) at set.jl:95"
        ]
      },
      {
        "name": "⋅",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "dot{T<:Union(Float64,Float32)}(x::Array{T<:Union(Float64,Float32),1},y::Array{T<:Union(Float64,Float32),1}) at linalg/matmul.jl:32",
          "dot{T<:Union(Complex{Float64},Complex{Float32})}(x::Array{T<:Union(Complex{Float64},Complex{Float32}),1},y::Array{T<:Union(Complex{Float64},Complex{Float32}),1}) at linalg/matmul.jl:33",
          "dot{T<:Union(Float64,Float32),TI<:Integer}(x::Array{T<:Union(Float64,Float32),1},rx::Union(UnitRange{TI<:Integer},Range{TI<:Integer}),y::Array{T<:Union(Float64,Float32),1},ry::Union(UnitRange{TI<:Integer},Range{TI<:Integer})) at linalg/matmul.jl:35",
          "dot{T<:Union(Complex{Float64},Complex{Float32}),TI<:Integer}(x::Array{T<:Union(Complex{Float64},Complex{Float32}),1},rx::Union(UnitRange{TI<:Integer},Range{TI<:Integer}),y::Array{T<:Union(Complex{Float64},Complex{Float32}),1},ry::Union(UnitRange{TI<:Integer},Range{TI<:Integer})) at linalg/matmul.jl:42",
          "dot(x::BitArray{1},y::BitArray{1}) at linalg/bitarray.jl:3",
          "dot(x::AbstractArray{T,1},y::AbstractArray{T,1}) at linalg/matmul.jl:49",
          "dot(x::Number,y::Number) at linalg/matmul.jl:60"
        ]
      }
    ]
  },
  {
    "name": "Gadfly",
    "items": 
    [
      {
        "name": "@plot",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Coord",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "D3",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Gadfly",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Geom",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Guide",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Layer",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PDF",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PNG",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PS",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Plot",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SVG",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Scale",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Stat",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Theme",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "cm",
        "summary": "Measure{MeasureNil,MeasureNil}",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "color",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "color(desc::String) at /home/samuel/.julia/v0.3/Color/src/Color.jl:882",
          "color(c::ColorValue) at /home/samuel/.julia/v0.3/Color/src/Color.jl:921"
        ]
      },
      {
        "name": "draw",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "draw(backend::Backend,t::Transform,unit_box::UnitBox{S,T,U,V},box::AbsoluteBoundingBox,root_form::EmptyForm)",
          "draw(backend::Backend,t::Transform,unit_box::UnitBox{S,T,U,V},box::AbsoluteBoundingBox,root_form::FormTree) at /home/samuel/.julia/v0.3/Compose/src/form.jl:163",
          "draw(backend::Backend,t::Transform,unit_box::UnitBox{S,T,U,V},box::AbsoluteBoundingBox,form::Lines) at /home/samuel/.julia/v0.3/Compose/src/form.jl:251",
          "draw(backend::Backend,t::Transform,unit_box::UnitBox{S,T,U,V},box::AbsoluteBoundingBox,form::Curve) at /home/samuel/.julia/v0.3/Compose/src/form.jl:293",
          "draw(backend::Backend,t::Transform,unit_box::UnitBox{S,T,U,V},box::AbsoluteBoundingBox,form::Polygon) at /home/samuel/.julia/v0.3/Compose/src/form.jl:331",
          "draw(backend::Backend,t::Transform,unit_box::UnitBox{S,T,U,V},box::AbsoluteBoundingBox,form::Ellipse) at /home/samuel/.julia/v0.3/Compose/src/form.jl:417",
          "draw(backend::Backend,t::Transform,unit_box::UnitBox{S,T,U,V},box::AbsoluteBoundingBox,form::Text) at /home/samuel/.julia/v0.3/Compose/src/form.jl:496",
          "draw(backend::Backend,root_canvas::Canvas) at /home/samuel/.julia/v0.3/Compose/src/canvas.jl:261",
          "draw(backend::Backend,form::Form) at /home/samuel/.julia/v0.3/Compose/src/canvas.jl:343",
          "draw(img::Image{B<:ImageBackend},form::Lines) at /home/samuel/.julia/v0.3/Compose/src/cairo_backends.jl:411",
          "draw(img::Image{B<:ImageBackend},form::Curve) at /home/samuel/.julia/v0.3/Compose/src/cairo_backends.jl:425",
          "draw(img::Image{B<:ImageBackend},form::Polygon) at /home/samuel/.julia/v0.3/Compose/src/cairo_backends.jl:431",
          "draw(img::Image{B<:ImageBackend},form::Ellipse) at /home/samuel/.julia/v0.3/Compose/src/cairo_backends.jl:446",
          "draw(img::Image{B<:ImageBackend},form::Text) at /home/samuel/.julia/v0.3/Compose/src/cairo_backends.jl:483",
          "draw(img::SVG,form::Lines) at /home/samuel/.julia/v0.3/Compose/src/svg.jl:287",
          "draw(img::SVG,form::Curve) at /home/samuel/.julia/v0.3/Compose/src/svg.jl:300",
          "draw(img::SVG,form::Polygon) at /home/samuel/.julia/v0.3/Compose/src/svg.jl:314",
          "draw(img::SVG,form::Ellipse) at /home/samuel/.julia/v0.3/Compose/src/svg.jl:328",
          "draw(img::SVG,form::Text) at /home/samuel/.julia/v0.3/Compose/src/svg.jl:365",
          "draw(img::D3,form::Polygon) at /home/samuel/.julia/v0.3/Compose/src/d3.jl:293",
          "draw(img::D3,form::Lines) at /home/samuel/.julia/v0.3/Compose/src/d3.jl:306",
          "draw(img::D3,form::Ellipse) at /home/samuel/.julia/v0.3/Compose/src/d3.jl:319",
          "draw(img::D3,form::Text) at /home/samuel/.julia/v0.3/Compose/src/d3.jl:423",
          "draw(img::D3,form::FormPrimitive)",
          "draw(backend::D3,t::Transform,unit_box::UnitBox{S,T,U,V},box::AbsoluteBoundingBox,form::DataForm{Ellipse}) at /home/samuel/.julia/v0.3/Compose/src/dataform.jl:381",
          "draw{T}(backend::Backend,t::Transform,unit_box::UnitBox{S,T,U,V},box::AbsoluteBoundingBox,form::DataForm{T}) at /home/samuel/.julia/v0.3/Compose/src/dataform.jl:110",
          "draw(backend::Backend,p::Plot) at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:730"
        ]
      },
      {
        "name": "hstack",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "hstack(canvases::Canvas...) at /home/samuel/.julia/v0.3/Compose/src/Compose.jl:213",
          "hstack(ps::Plot...) at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:738",
          "hstack(ps::Array{Plot,1}) at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:739",
          "hstack(x0,y0,height,aligned_canvases::(Canvas,VAlignment)...) at /home/samuel/.julia/v0.3/Compose/src/Compose.jl:153",
          "hstack() at /home/samuel/.julia/v0.3/Compose/src/Compose.jl:202"
        ]
      },
      {
        "name": "inch",
        "summary": "Measure{MeasureNil,MeasureNil}",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "layer",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "layer(data_source::AbstractDataFrame,elements::Union(Function,Theme,Element,DataType)...) at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:146",
          "layer(elements::Union(Function,Theme,Element,DataType)...) at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:157",
          "layer(fs::Array{T,N},a,b) at /home/samuel/.julia/v0.3/Gadfly/src/poetry.jl:115",
          "layer(f::Function,a,b) at /home/samuel/.julia/v0.3/Gadfly/src/poetry.jl:122",
          "layer(f::Expr,a,b) at /home/samuel/.julia/v0.3/Gadfly/src/poetry.jl:128"
        ]
      },
      {
        "name": "mm",
        "summary": "Measure{MeasureNil,MeasureNil}",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "plot",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "plot(data_source::AbstractDataFrame,elements::Union(Function,Theme,Element,DataType)...) at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:345",
          "plot(elements::Union(Function,Theme,Element,DataType)...) at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:361",
          "plot(data_source::AbstractDataFrame,mapping::Dict{K,V},elements::Union(Function,Theme,Element,DataType)...) at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:380",
          "plot(fs::Array{T,N},a,b,elements::Union(Function,Theme,Element,DataType)...) at /home/samuel/.julia/v0.3/Gadfly/src/poetry.jl:78",
          "plot(f::Function,a,b,elements::Union(Function,Theme,Element,DataType)...) at /home/samuel/.julia/v0.3/Gadfly/src/poetry.jl:95",
          "plot(f::Expr,a,b,elements::Union(Function,Theme,Element,DataType)...) at /home/samuel/.julia/v0.3/Gadfly/src/poetry.jl:101"
        ]
      },
      {
        "name": "prepare_display",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "prepare_display(d::Display) at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:88",
          "prepare_display() at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:94"
        ]
      },
      {
        "name": "pt",
        "summary": "Measure{MeasureNil,MeasureNil}",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "px",
        "summary": "Measure{MeasureNil,MeasureNil}",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "render",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "render(plot::Plot) at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:424",
          "render(geom::Nil,theme::Theme,aes::Aesthetics)",
          "render(geom::BarGeometry,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/geom/bar.jl:197",
          "render(geom::BoxplotGeometry,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/geom/boxplot.jl:17",
          "render(geom::ErrorBarGeometry,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/geom/errorbar.jl:41",
          "render(geom::YErrorBarGeometry,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/geom/errorbar.jl:55",
          "render(geom::XErrorBarGeometry,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/geom/errorbar.jl:92",
          "render(geom::HexagonalBinGeometry,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/geom/hexbin.jl:34",
          "render(geom::HLineGeometry,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/geom/hline.jl:23",
          "render(geom::LabelGeometry,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/geom/label.jl:273",
          "render(geom::LineGeometry,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/geom/line.jl:60",
          "render(geom::PointGeometry,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/geom/point.jl:26",
          "render(geom::RectangularBinGeometry,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/geom/rectbin.jl:51",
          "render(geom::SubplotGrid,theme::Theme,superplot_aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/geom/subplot.jl:97",
          "render(geom::VLineGeometry,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/geom/vline.jl:22",
          "render(geom::RibbonGeometry,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/geom/ribbon.jl:25",
          "render(guide::PanelBackground,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/guide.jl:38",
          "render(guide::ZoomSlider,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/guide.jl:58",
          "render(guide::ColorKey,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/guide.jl:301",
          "render(guide::XTicks,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/guide.jl:414",
          "render(guide::YTicks,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/guide.jl:501",
          "render(guide::XLabel,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/guide.jl:578",
          "render(guide::YLabel,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/guide.jl:606",
          "render(guide::Title,theme::Theme,aes::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/guide.jl:634"
        ]
      },
      {
        "name": "set_default_plot_format",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "set_default_plot_format(fmt::Symbol) at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:121"
        ]
      },
      {
        "name": "set_default_plot_size",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "set_default_plot_size(width::Union(Number,Measure{S,T}),height::Union(Number,Measure{S,T})) at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:111"
        ]
      },
      {
        "name": "spy",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "spy(M::AbstractArray{T,2},elements::Union(Function,Theme,Element,DataType)...) at /home/samuel/.julia/v0.3/Gadfly/src/poetry.jl:149"
        ]
      },
      {
        "name": "vstack",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "vstack(canvases::Canvas...) at /home/samuel/.julia/v0.3/Compose/src/Compose.jl:289",
          "vstack(ps::Plot...) at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:735",
          "vstack(ps::Array{Plot,1}) at /home/samuel/.julia/v0.3/Gadfly/src/Gadfly.jl:736",
          "vstack(x0,y0,width,aligned_canvases::(Canvas,HAlignment)...) at /home/samuel/.julia/v0.3/Compose/src/Compose.jl:231",
          "vstack() at /home/samuel/.julia/v0.3/Compose/src/Compose.jl:278"
        ]
      }
    ]
  },
  {
    "name": "DataFrames",
    "items": 
    [
      {
        "name": "+",
        "summary": "Function",
        "help": "Base.+(x, y)\n\n   Binary addition operator.\n\nBase.Graphics.+(bb1::BoundingBox, bb2::BoundingBox) -> BoundingBox\n\n   Returns the smallest box containing both boxes\n",
        "methods": 
        [
          "+(x::Bool) at bool.jl:36",
          "+(x::Bool,y::Bool) at bool.jl:39",
          "+(y::FloatingPoint,x::Bool) at bool.jl:49",
          "+(A::BitArray{N},B::BitArray{N}) at bitarray.jl:852",
          "+(x::Array{CalendarTime,N},y::Array{CalendarDuration,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:340",
          "+(x::Array{CalendarTime,N},y::Array{FixedCalendarDuration,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:341",
          "+(y::Array{CalendarDuration,N},x::Array{CalendarTime,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:342",
          "+(y::Array{FixedCalendarDuration,N},x::Array{CalendarTime,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:343",
          "+(A::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at array.jl:792",
          "+{S,T}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:724",
          "+(x::Union(DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar}),y::Union(DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar})) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:302",
          "+{T<:Union(Int8,Int16,Int32)}(x::T<:Union(Int8,Int16,Int32),y::T<:Union(Int8,Int16,Int32)) at int.jl:16",
          "+{T<:Union(Uint16,Uint8,Uint32)}(x::T<:Union(Uint16,Uint8,Uint32),y::T<:Union(Uint16,Uint8,Uint32)) at int.jl:20",
          "+(x::Int64,y::Int64) at int.jl:33",
          "+(x::Uint64,y::Uint64) at int.jl:34",
          "+(x::Int128,y::Int128) at int.jl:35",
          "+(x::Uint128,y::Uint128) at int.jl:36",
          "+(x::Float32,y::Float32) at float.jl:124",
          "+(x::Float64,y::Float64) at float.jl:125",
          "+(z::Complex{T<:Real},w::Complex{T<:Real}) at complex.jl:110",
          "+(x::Real,z::Complex{T<:Real}) at complex.jl:120",
          "+(z::Complex{T<:Real},x::Real) at complex.jl:121",
          "+(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:113",
          "+(x::Char,y::Char) at char.jl:23",
          "+(x::Char,y::Integer) at char.jl:26",
          "+(x::Integer,y::Char) at char.jl:27",
          "+(a::Float16,b::Float16) at float16.jl:125",
          "+(x::BigInt,y::BigInt) at gmp.jl:193",
          "+(a::BigInt,b::BigInt,c::BigInt) at gmp.jl:216",
          "+(a::BigInt,b::BigInt,c::BigInt,d::BigInt) at gmp.jl:222",
          "+(a::BigInt,b::BigInt,c::BigInt,d::BigInt,e::BigInt) at gmp.jl:229",
          "+(x::BigInt,c::Uint64) at gmp.jl:241",
          "+(c::Uint64,x::BigInt) at gmp.jl:245",
          "+(c::Union(Uint16,Uint8,Uint32,Uint64),x::BigInt) at gmp.jl:246",
          "+(x::BigInt,c::Union(Uint16,Uint8,Uint32,Uint64)) at gmp.jl:247",
          "+(x::BigInt,c::Union(Int8,Int64,Int16,Int32)) at gmp.jl:248",
          "+(c::Union(Int8,Int64,Int16,Int32),x::BigInt) at gmp.jl:249",
          "+(x::BigFloat,c::Uint64) at mpfr.jl:140",
          "+(c::Uint64,x::BigFloat) at mpfr.jl:144",
          "+(c::Union(Uint16,Uint8,Uint32,Uint64),x::BigFloat) at mpfr.jl:145",
          "+(x::BigFloat,c::Union(Uint16,Uint8,Uint32,Uint64)) at mpfr.jl:146",
          "+(x::BigFloat,c::Int64) at mpfr.jl:150",
          "+(c::Int64,x::BigFloat) at mpfr.jl:154",
          "+(x::BigFloat,c::Union(Int8,Int64,Int16,Int32)) at mpfr.jl:155",
          "+(c::Union(Int8,Int64,Int16,Int32),x::BigFloat) at mpfr.jl:156",
          "+(x::BigFloat,c::Float64) at mpfr.jl:160",
          "+(c::Float64,x::BigFloat) at mpfr.jl:164",
          "+(c::Float32,x::BigFloat) at mpfr.jl:165",
          "+(x::BigFloat,c::Float32) at mpfr.jl:166",
          "+(x::BigFloat,c::BigInt) at mpfr.jl:170",
          "+(c::BigInt,x::BigFloat) at mpfr.jl:174",
          "+(x::BigFloat,y::BigFloat) at mpfr.jl:321",
          "+(a::BigFloat,b::BigFloat,c::BigFloat) at mpfr.jl:332",
          "+(a::BigFloat,b::BigFloat,c::BigFloat,d::BigFloat) at mpfr.jl:338",
          "+(a::BigFloat,b::BigFloat,c::BigFloat,d::BigFloat,e::BigFloat) at mpfr.jl:345",
          "+(x::MathConst{sym},y::MathConst{sym}) at constants.jl:23",
          "+{T<:Number}(x::T<:Number,y::T<:Number) at promotion.jl:188",
          "+{T<:FloatingPoint}(x::Bool,y::T<:FloatingPoint) at bool.jl:46",
          "+(x::Number,y::Number) at promotion.jl:158",
          "+(x::Real,r::UnitRange{T<:Real}) at range.jl:419",
          "+(x::Real,r::FloatRange{T<:FloatingPoint}) at range.jl:422",
          "+(x::Real,r::Range{T}) at range.jl:420",
          "+(r::Range{T},x::Real) at range.jl:423",
          "+(x::Integer,y::Ptr{T}) at pointer.jl:70",
          "+(x::Bool,A::Array{Bool,N}) at deprecated.jl:26",
          "+(x::Bool,A::AbstractDataArray{Bool,N}) at deprecated.jl:26",
          "+{P<:Period}(x::Real,y::P<:Period) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:541",
          "+(x::Number) at operators.jl:71",
          "+(r1::OrdinalRange{T,S},r2::OrdinalRange{T,S}) at operators.jl:320",
          "+{T<:FloatingPoint}(r1::FloatRange{T<:FloatingPoint},r2::FloatRange{T<:FloatingPoint}) at operators.jl:326",
          "+(r1::FloatRange{T<:FloatingPoint},r2::FloatRange{T<:FloatingPoint}) at operators.jl:343",
          "+(r1::FloatRange{T<:FloatingPoint},r2::OrdinalRange{T,S}) at operators.jl:344",
          "+(r1::OrdinalRange{T,S},r2::FloatRange{T<:FloatingPoint}) at operators.jl:345",
          "+(x::Ptr{T},y::Integer) at pointer.jl:68",
          "+{S,T<:Real}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Range{T<:Real}) at array.jl:732",
          "+{S<:Real,T}(A::Range{S<:Real},B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:741",
          "+{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti},B::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:514",
          "+{TvA,TiA,TvB,TiB}(A::SparseMatrixCSC{TvA,TiA},B::SparseMatrixCSC{TvB,TiB}) at sparse/sparsematrix.jl:506",
          "+(A::SparseMatrixCSC{Tv,Ti<:Integer},B::Union(Number,Array{T,N})) at sparse/sparsematrix.jl:604",
          "+(A::Union(Number,Array{T,N}),B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:605",
          "+(A::SymTridiagonal{T},B::SymTridiagonal{T}) at linalg/tridiag.jl:44",
          "+(A::Tridiagonal{T},B::Tridiagonal{T}) at linalg/tridiag.jl:205",
          "+(A::Tridiagonal{T},B::SymTridiagonal{T}) at linalg/special.jl:98",
          "+(A::SymTridiagonal{T},B::Tridiagonal{T}) at linalg/special.jl:97",
          "+(Da::Diagonal{T},Db::Diagonal{T}) at linalg/diagonal.jl:38",
          "+(A::Bidiagonal{T},B::Bidiagonal{T}) at linalg/bidiag.jl:91",
          "+{T}(B::BitArray{2},J::UniformScaling{T}) at linalg/uniformscaling.jl:26",
          "+(A::Diagonal{T},B::Bidiagonal{T}) at linalg/special.jl:88",
          "+(A::Bidiagonal{T},B::Diagonal{T}) at linalg/special.jl:89",
          "+(A::Diagonal{T},B::Tridiagonal{T}) at linalg/special.jl:88",
          "+(A::Tridiagonal{T},B::Diagonal{T}) at linalg/special.jl:89",
          "+(A::Diagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:88",
          "+(A::Triangular{T<:Number},B::Diagonal{T}) at linalg/special.jl:89",
          "+(A::Diagonal{T},B::Array{T,2}) at linalg/special.jl:88",
          "+(A::Array{T,2},B::Diagonal{T}) at linalg/special.jl:89",
          "+(A::Bidiagonal{T},B::Tridiagonal{T}) at linalg/special.jl:88",
          "+(A::Tridiagonal{T},B::Bidiagonal{T}) at linalg/special.jl:89",
          "+(A::Bidiagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:88",
          "+(A::Triangular{T<:Number},B::Bidiagonal{T}) at linalg/special.jl:89",
          "+(A::Bidiagonal{T},B::Array{T,2}) at linalg/special.jl:88",
          "+(A::Array{T,2},B::Bidiagonal{T}) at linalg/special.jl:89",
          "+(A::Tridiagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:88",
          "+(A::Triangular{T<:Number},B::Tridiagonal{T}) at linalg/special.jl:89",
          "+(A::Tridiagonal{T},B::Array{T,2}) at linalg/special.jl:88",
          "+(A::Array{T,2},B::Tridiagonal{T}) at linalg/special.jl:89",
          "+(A::Triangular{T<:Number},B::Array{T,2}) at linalg/special.jl:88",
          "+(A::Array{T,2},B::Triangular{T<:Number}) at linalg/special.jl:89",
          "+(A::SymTridiagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:97",
          "+(A::Triangular{T<:Number},B::SymTridiagonal{T}) at linalg/special.jl:98",
          "+(A::SymTridiagonal{T},B::Array{T,2}) at linalg/special.jl:97",
          "+(A::Array{T,2},B::SymTridiagonal{T}) at linalg/special.jl:98",
          "+(A::Diagonal{T},B::SymTridiagonal{T}) at linalg/special.jl:106",
          "+(A::SymTridiagonal{T},B::Diagonal{T}) at linalg/special.jl:107",
          "+(A::Bidiagonal{T},B::SymTridiagonal{T}) at linalg/special.jl:106",
          "+(A::SymTridiagonal{T},B::Bidiagonal{T}) at linalg/special.jl:107",
          "+(A::Array{Bool,N},x::Bool) at deprecated.jl:26",
          "+(A::Array{T,N},x::Number) at deprecated.jl:26",
          "+(A::DataArray{Bool,2},J::UniformScaling{Bool}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:723",
          "+{TA,TJ}(A::DataArray{TA,2},J::UniformScaling{TJ}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:689",
          "+(A::AbstractDataArray{Bool,2},J::UniformScaling{Bool}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:741",
          "+{TA,TJ}(A::AbstractDataArray{TA,2},J::UniformScaling{TJ}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:732",
          "+(A::BitArray{N},B::DataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:778",
          "+(A::BitArray{N},B::AbstractDataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:777",
          "+(B::DataArray{Bool,N},A::BitArray{N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:778",
          "+(B::AbstractDataArray{Bool,N},A::BitArray{N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:777",
          "+(a::DataArray{Bool,N},b::DataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:332",
          "+(a::DataArray{Bool,N},b::AbstractDataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "+(a::DataArray{Bool,N},b::AbstractArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:332",
          "+(a::AbstractDataArray{Bool,N},b::DataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "+(a::AbstractArray{Bool,N},b::DataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:332",
          "+(a::DataArray{T,N},b::DataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:332",
          "+(a::DataArray{T,N},b::AbstractDataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "+(a::DataArray{T,N},b::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:332",
          "+(a::AbstractDataArray{Bool,N},b::AbstractDataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "+(a::AbstractDataArray{Bool,N},b::AbstractArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "+(a::AbstractDataArray{T,N},b::DataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "+(a::AbstractArray{Bool,N},b::AbstractDataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "+(a::AbstractDataArray{T,N},b::AbstractDataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "+(a::AbstractDataArray{T,N},b::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "+(A::AbstractDataArray{Bool,N},x::Bool) at deprecated.jl:26",
          "+(A::AbstractDataArray{T,N},x::Union(Number,NAtype)) at deprecated.jl:26",
          "+{C<:Calendar}(r::DateRange{C<:Calendar},p::DatePeriod) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:402",
          "+{C<:Calendar}(r::DateRange1{C<:Calendar},p::DatePeriod) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:436",
          "+{C<:Calendar,T<:Offsets}(r::DateTimeRange{C<:Calendar,T<:Offsets},p::DatePeriod) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:467",
          "+{P<:Period}(r::PeriodRange{P<:Period},p::P<:Period) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:588",
          "+(a::Array{Float64,2},b::AbstractPDMat) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:462",
          "+{T<:Number}(x::AbstractArray{T<:Number,N}) at abstractarray.jl:346",
          "+(J1::UniformScaling{T<:Number},J2::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:25",
          "+(J::UniformScaling{T<:Number},B::BitArray{2}) at linalg/uniformscaling.jl:27",
          "+(J::UniformScaling{Bool},A::DataArray{Bool,2}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:725",
          "+{TA}(J::UniformScaling{T<:Number},A::DataArray{TA,2}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:699",
          "+(J::UniformScaling{Bool},A::AbstractDataArray{Bool,2}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:743",
          "+{TA}(J::UniformScaling{T<:Number},A::AbstractDataArray{TA,2}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:734",
          "+(J::UniformScaling{T<:Number},A::AbstractArray{T,2}) at linalg/uniformscaling.jl:28",
          "+(J::UniformScaling{T<:Number},x::Number) at linalg/uniformscaling.jl:29",
          "+(x::Number,J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:30",
          "+{TA,TJ}(A::AbstractArray{TA,2},J::UniformScaling{TJ}) at linalg/uniformscaling.jl:33",
          "+(x::Number,A::Array{T,N}) at deprecated.jl:26",
          "+{T}(a::HierarchicalValue{T},b::HierarchicalValue{T}) at pkg/resolve/versionweight.jl:19",
          "+(a::VWPreBuildItem,b::VWPreBuildItem) at pkg/resolve/versionweight.jl:82",
          "+(a::VWPreBuild,b::VWPreBuild) at pkg/resolve/versionweight.jl:120",
          "+(a::VersionWeight,b::VersionWeight) at pkg/resolve/versionweight.jl:164",
          "+(a::FieldValue,b::FieldValue) at pkg/resolve/fieldvalue.jl:41",
          "+(a::Vec2,b::Vec2) at graphics.jl:60",
          "+(bb1::BoundingBox,bb2::BoundingBox) at graphics.jl:123",
          "+(d1::CalendarDuration,d2::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:298",
          "+(d::CalendarDuration,f::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:304",
          "+(f::FixedCalendarDuration,d::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:310",
          "+(d1::FixedCalendarDuration,d2::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:316",
          "+(t::CalendarTime,d::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:320",
          "+(t::CalendarTime,d::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:332",
          "+(d::AbstractCalendarDuration,t::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:335",
          "+(d::NAtype) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:379",
          "+(x::Union(Number,NAtype),A::AbstractDataArray{T,N}) at deprecated.jl:26",
          "+{T1<:Union(CalendarTime,AbstractCalendarDuration),T2<:Union(CalendarTime,AbstractCalendarDuration)}(::T1<:Union(CalendarTime,AbstractCalendarDuration),::AbstractArray{T2<:Union(CalendarTime,AbstractCalendarDuration),N}) at operators.jl:365",
          "+{T1<:Union(CalendarTime,AbstractCalendarDuration),T2<:Union(CalendarTime,AbstractCalendarDuration)}(::AbstractArray{T1<:Union(CalendarTime,AbstractCalendarDuration),N},::T2<:Union(CalendarTime,AbstractCalendarDuration)) at operators.jl:367",
          "+{T1<:Union(CalendarTime,AbstractCalendarDuration),T2<:Union(CalendarTime,AbstractCalendarDuration)}(::AbstractArray{T1<:Union(CalendarTime,AbstractCalendarDuration),N},::AbstractArray{T2<:Union(CalendarTime,AbstractCalendarDuration),N}) at operators.jl:371",
          "+(x::LCHuv,y::LCHuv) at /home/samuel/.julia/v0.3/Color/src/Color.jl:1273",
          "+(a::MeasureNil,b::MeasureNil) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:29",
          "+(a::MeasureNil,b) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:30",
          "+{C<:Calendar}(dt::Date{C<:Calendar},y::Year{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:309",
          "+{C<:Calendar,T<:Offsets}(dt::DateTime{C<:Calendar,T<:Offsets},y::Year{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:317",
          "+{C<:Calendar}(dt::Date{C<:Calendar},z::Month{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:326",
          "+{C<:Calendar,T<:Offsets}(dt::DateTime{C<:Calendar,T<:Offsets},z::Month{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:338",
          "+{C<:Calendar}(x::Date{C<:Calendar},y::Week{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:350",
          "+{C<:Calendar}(x::Date{C<:Calendar},y::Day{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:352",
          "+{C<:Calendar,T<:Offsets}(x::DateTime{C<:Calendar,T<:Offsets},y::Week{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:354",
          "+{C<:Calendar,T<:Offsets}(x::DateTime{C<:Calendar,T<:Offsets},y::Day{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:356",
          "+{C<:Calendar,T<:Offsets}(x::DateTime{C<:Calendar,T<:Offsets},y::Hour{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:358",
          "+{C<:Calendar,T<:Offsets}(x::DateTime{C<:Calendar,T<:Offsets},y::Minute{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:360",
          "+{C<:Calendar,T<:Offsets}(x::DateTime{C<:Calendar,T<:Offsets},y::Second{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:362",
          "+{P<:Period}(x::Period,y::AbstractArray{P<:Period,N}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:544",
          "+{T<:Union(Period,DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar})}(x::Union(Period,DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar}),y::AbstractArray{T<:Union(Period,DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar}),N}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:367",
          "+(x::TimeType) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:298",
          "+(a,b::MeasureNil) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:31",
          "+(a::Measure{S,T},b::Measure{S,T}) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:173",
          "+(::NAtype,::NAtype) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:679",
          "+(d::NAtype,x::Number) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:680",
          "+(x::Number,d::NAtype) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:680",
          "+(a::AbstractArray{T,N},b::DataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:332",
          "+(a::AbstractArray{T,N},b::AbstractDataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "+(y::Period,x::Union(DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar})) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:364",
          "+{P<:Period}(x::AbstractArray{P<:Period,N},y::Period) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:545",
          "+{T<:Union(Period,DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar})}(x::AbstractArray{T<:Union(Period,DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar}),N},y::Union(Period,DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar})) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:368",
          "+{P<:Period}(x::P<:Period,y::P<:Period)",
          "+{P<:Period}(x::P<:Period,y::Real) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:540",
          "+(x::Period,y::Period)",
          "+(a::PDMat,b::Array{Float64,2}) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:458",
          "+(a::PDiagMat,b::Array{Float64,2}) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:459",
          "+(a::ScalMat,b::Array{Float64,2}) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:460",
          "+(a::PDMat,b::PDMat) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:488",
          "+(a::PDMat,b::PDiagMat) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:489",
          "+(a::PDMat,b::ScalMat) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:490",
          "+(a::PDMat,b::AbstractPDMat) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:484",
          "+(a::PDiagMat,b::PDMat) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:492",
          "+(a::PDiagMat,b::PDiagMat) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:493",
          "+(a::PDiagMat,b::ScalMat) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:494",
          "+(a::PDiagMat,b::AbstractPDMat) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:485",
          "+(a::ScalMat,b::PDMat) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:496",
          "+(a::ScalMat,b::PDiagMat) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:497",
          "+(a::ScalMat,b::ScalMat) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:498",
          "+(a::ScalMat,b::AbstractPDMat) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:486",
          "+(a,b,c) at operators.jl:82",
          "+(a,b,c,xs...) at operators.jl:83"
        ]
      },
      {
        "name": "-",
        "summary": "Function",
        "help": "Base.-(x)\n\n   Unary minus operator.\n\nBase.-(x, y)\n\n   Binary subtraction operator.\n",
        "methods": 
        [
          "-(x::Bool) at bool.jl:37",
          "-(x::Bool,y::Bool) at bool.jl:40",
          "-(x::Union(Int8,Int16,Int32)) at int.jl:13",
          "-(x::Union(Uint16,Uint8,Uint32)) at int.jl:14",
          "-(B::BitArray{2},J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:44",
          "-(B::BitArray{N}) at bitarray.jl:793",
          "-(A::BitArray{N},B::BitArray{N}) at bitarray.jl:852",
          "-(x::Int64) at int.jl:26",
          "-(x::Uint64) at int.jl:27",
          "-(x::Int128) at int.jl:28",
          "-(x::Uint128) at int.jl:29",
          "-(x::Float32) at float.jl:121",
          "-(x::Float64) at float.jl:122",
          "-(z::Complex{T<:Real}) at complex.jl:109",
          "-(x::Rational{T<:Integer}) at rational.jl:109",
          "-(x::Float16) at float16.jl:122",
          "-(x::BigInt) at gmp.jl:287",
          "-(x::BigFloat) at mpfr.jl:356",
          "-(x::MathConst{sym}) at constants.jl:21",
          "-(A::Union(Number,Array{T,N}),B::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:608",
          "-(A::Array{T,2},B::Diagonal{T}) at linalg/special.jl:89",
          "-(A::Array{T,2},B::Bidiagonal{T}) at linalg/special.jl:89",
          "-(A::Array{T,2},B::Tridiagonal{T}) at linalg/special.jl:89",
          "-(A::Array{T,2},B::Triangular{T<:Number}) at linalg/special.jl:89",
          "-(A::Array{T,2},B::SymTridiagonal{T}) at linalg/special.jl:98",
          "-(A::Array{Bool,N},x::Bool) at deprecated.jl:26",
          "-(A::Array{T,N},x::Number) at deprecated.jl:26",
          "-(x::Array{CalendarTime,N},y::Array{CalendarDuration,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:340",
          "-(x::Array{CalendarTime,N},y::Array{FixedCalendarDuration,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:341",
          "-(y::Array{CalendarDuration,N},x::Array{CalendarTime,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:342",
          "-(y::Array{FixedCalendarDuration,N},x::Array{CalendarTime,N}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:343",
          "-(A::BitArray{N},B::DataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:778",
          "-(A::BitArray{N},B::AbstractDataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:777",
          "-(A::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at array.jl:676",
          "-(A::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Union(DenseArray{Bool,N},SubArray{Bool,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)})) at array.jl:792",
          "-(A::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:667",
          "-{S,T}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:724",
          "-(x::Date{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:299",
          "-{C<:Calendar,T<:Offsets}(x::DateTime{C<:Calendar,T<:Offsets}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:300",
          "-{C<:Calendar}(x::Date{C<:Calendar},y::Date{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:304",
          "-{C<:Calendar,T<:Offsets}(x::DateTime{C<:Calendar,T<:Offsets},y::DateTime{C<:Calendar,T<:Offsets}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:305",
          "-(x::Union(DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar}),y::Union(DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar})) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:306",
          "-{T<:Union(Int8,Int16,Int32)}(x::T<:Union(Int8,Int16,Int32),y::T<:Union(Int8,Int16,Int32)) at int.jl:17",
          "-{T<:Union(Uint16,Uint8,Uint32)}(x::T<:Union(Uint16,Uint8,Uint32),y::T<:Union(Uint16,Uint8,Uint32)) at int.jl:21",
          "-(x::Int64,y::Int64) at int.jl:40",
          "-(x::Uint64,y::Uint64) at int.jl:41",
          "-(x::Int128,y::Int128) at int.jl:42",
          "-(x::Uint128,y::Uint128) at int.jl:43",
          "-(x::Float32,y::Float32) at float.jl:126",
          "-(x::Float64,y::Float64) at float.jl:127",
          "-(z::Complex{T<:Real},w::Complex{T<:Real}) at complex.jl:111",
          "-(x::Real,z::Complex{T<:Real}) at complex.jl:122",
          "-(z::Complex{T<:Real},x::Real) at complex.jl:123",
          "-(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:113",
          "-(x::Char,y::Char) at char.jl:28",
          "-(x::Char,y::Integer) at char.jl:29",
          "-(a::Float16,b::Float16) at float16.jl:125",
          "-(x::BigInt,y::BigInt) at gmp.jl:193",
          "-(x::BigInt,c::Uint64) at gmp.jl:252",
          "-(c::Uint64,x::BigInt) at gmp.jl:257",
          "-(x::BigInt,c::Union(Uint16,Uint8,Uint32,Uint64)) at gmp.jl:261",
          "-(c::Union(Uint16,Uint8,Uint32,Uint64),x::BigInt) at gmp.jl:262",
          "-(x::BigInt,c::Union(Int8,Int64,Int16,Int32)) at gmp.jl:263",
          "-(c::Union(Int8,Int64,Int16,Int32),x::BigInt) at gmp.jl:264",
          "-(x::BigFloat,c::Uint64) at mpfr.jl:178",
          "-(c::Uint64,x::BigFloat) at mpfr.jl:183",
          "-(x::BigFloat,c::Union(Uint16,Uint8,Uint32,Uint64)) at mpfr.jl:187",
          "-(c::Union(Uint16,Uint8,Uint32,Uint64),x::BigFloat) at mpfr.jl:188",
          "-(x::BigFloat,c::Int64) at mpfr.jl:192",
          "-(c::Int64,x::BigFloat) at mpfr.jl:197",
          "-(x::BigFloat,c::Union(Int8,Int64,Int16,Int32)) at mpfr.jl:201",
          "-(c::Union(Int8,Int64,Int16,Int32),x::BigFloat) at mpfr.jl:202",
          "-(x::BigFloat,c::Float64) at mpfr.jl:206",
          "-(c::Float64,x::BigFloat) at mpfr.jl:211",
          "-(x::BigFloat,c::Float32) at mpfr.jl:215",
          "-(c::Float32,x::BigFloat) at mpfr.jl:216",
          "-(x::BigFloat,c::BigInt) at mpfr.jl:220",
          "-(c::BigInt,x::BigFloat) at mpfr.jl:225",
          "-(x::BigFloat,y::BigFloat) at mpfr.jl:321",
          "-(x::MathConst{sym},y::MathConst{sym}) at constants.jl:23",
          "-{T<:Number}(x::T<:Number,y::T<:Number) at promotion.jl:190",
          "-(x::Number,y::Number) at promotion.jl:160",
          "-(r::UnitRange{T<:Real},x::Real) at range.jl:428",
          "-(r::StepRange{T,S},x::Real) at range.jl:429",
          "-(r::OrdinalRange{T,S}) at range.jl:416",
          "-(r::FloatRange{T<:FloatingPoint}) at range.jl:417",
          "-(x::Real,r::FloatRange{T<:FloatingPoint}) at range.jl:427",
          "-(x::Real,r::Range{T}) at range.jl:426",
          "-(r::FloatRange{T<:FloatingPoint},x::Real) at range.jl:430",
          "-(r1::OrdinalRange{T,S},r2::OrdinalRange{T,S}) at operators.jl:320",
          "-{T<:FloatingPoint}(r1::FloatRange{T<:FloatingPoint},r2::FloatRange{T<:FloatingPoint}) at operators.jl:326",
          "-(r1::FloatRange{T<:FloatingPoint},r2::FloatRange{T<:FloatingPoint}) at operators.jl:343",
          "-(r1::FloatRange{T<:FloatingPoint},r2::OrdinalRange{T,S}) at operators.jl:344",
          "-(r1::OrdinalRange{T,S},r2::FloatRange{T<:FloatingPoint}) at operators.jl:345",
          "-(x::Ptr{T},y::Ptr{T}) at pointer.jl:66",
          "-(x::Ptr{T},y::Integer) at pointer.jl:69",
          "-{S,T<:Real}(A::Union(SubArray{S,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{S,N}),B::Range{T<:Real}) at array.jl:732",
          "-{S<:Real,T}(A::Range{S<:Real},B::Union(SubArray{T,N,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T,N})) at array.jl:741",
          "-(A::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:464",
          "-{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti},B::SparseMatrixCSC{Tv,Ti}) at sparse/sparsematrix.jl:514",
          "-{TvA,TiA,TvB,TiB}(A::SparseMatrixCSC{TvA,TiA},B::SparseMatrixCSC{TvB,TiB}) at sparse/sparsematrix.jl:506",
          "-(A::SparseMatrixCSC{Tv,Ti<:Integer},B::Union(Number,Array{T,N})) at sparse/sparsematrix.jl:607",
          "-(A::SymTridiagonal{T},B::SymTridiagonal{T}) at linalg/tridiag.jl:45",
          "-(A::Tridiagonal{T},B::Tridiagonal{T}) at linalg/tridiag.jl:206",
          "-(A::Tridiagonal{T},B::SymTridiagonal{T}) at linalg/special.jl:98",
          "-(A::SymTridiagonal{T},B::Tridiagonal{T}) at linalg/special.jl:97",
          "-(Da::Diagonal{T},Db::Diagonal{T}) at linalg/diagonal.jl:39",
          "-(A::Bidiagonal{T},B::Bidiagonal{T}) at linalg/bidiag.jl:99",
          "-(A::Bidiagonal{T}) at linalg/bidiag.jl:106",
          "-(J::UniformScaling{Bool},A::DataArray{Bool,2}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:729",
          "-(J::UniformScaling{Bool},A::AbstractDataArray{Bool,2}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:747",
          "-(J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:42",
          "-(J1::UniformScaling{T<:Number},J2::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:43",
          "-(J::UniformScaling{T<:Number},B::BitArray{2}) at linalg/uniformscaling.jl:45",
          "-(J::UniformScaling{T<:Number},x::Number) at linalg/uniformscaling.jl:46",
          "-(x::Number,J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:47",
          "-(A::DataArray{Bool,2},J::UniformScaling{Bool}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:727",
          "-(B::DataArray{Bool,N},A::BitArray{N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:778",
          "-(a::DataArray{Bool,N},b::DataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:332",
          "-(a::DataArray{Bool,N},b::AbstractDataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "-(a::DataArray{Bool,N},b::AbstractArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:332",
          "-{T<:Bool}(d::DataArray{T<:Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:262",
          "-{TA,TJ<:Number}(A::DataArray{TA,2},J::UniformScaling{TJ<:Number}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:702",
          "-{T}(d::DataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:262",
          "-(A::AbstractDataArray{Bool,2},J::UniformScaling{Bool}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:745",
          "-(B::AbstractDataArray{Bool,N},A::BitArray{N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:777",
          "-(a::DataArray{T,N},b::DataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:332",
          "-(a::DataArray{T,N},b::AbstractDataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "-(a::DataArray{T,N},b::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:332",
          "-(a::AbstractDataArray{Bool,N},b::DataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "-(a::AbstractDataArray{Bool,N},b::AbstractDataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "-(a::AbstractDataArray{Bool,N},b::AbstractArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "-(A::AbstractDataArray{Bool,N},x::Bool) at deprecated.jl:26",
          "-{T<:Bool}(adv::AbstractDataArray{T<:Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:272",
          "-{TA,TJ<:Number}(A::AbstractDataArray{TA,2},J::UniformScaling{TJ<:Number}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:736",
          "-{T}(adv::AbstractDataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:272",
          "-(a::AbstractDataArray{T,N},b::DataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "-(a::AbstractDataArray{T,N},b::AbstractDataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "-(a::AbstractDataArray{T,N},b::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "-(A::AbstractDataArray{T,N},x::Union(Number,NAtype)) at deprecated.jl:26",
          "-{C<:Calendar}(r::DateRange{C<:Calendar},p::DatePeriod) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:403",
          "-{C<:Calendar}(r::DateRange1{C<:Calendar},p::DatePeriod) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:437",
          "-{C<:Calendar,T<:Offsets}(r::DateTimeRange{C<:Calendar,T<:Offsets},p::DatePeriod) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:468",
          "-{P<:Period}(r::PeriodRange{P<:Period},p::P<:Period) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:589",
          "-{T<:AbstractCalendarDuration}(::AbstractArray{T<:AbstractCalendarDuration,2}) at operators.jl:355",
          "-{TA,TJ<:Number}(A::AbstractArray{TA,2},J::UniformScaling{TJ<:Number}) at linalg/uniformscaling.jl:50",
          "-{TA,TJ<:Number}(J::UniformScaling{TJ<:Number},A::DataArray{TA,2}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:713",
          "-{TA,TJ<:Number}(J::UniformScaling{TJ<:Number},A::AbstractDataArray{TA,2}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:738",
          "-{TA,TJ<:Number}(J::UniformScaling{TJ<:Number},A::AbstractArray{TA,2}) at linalg/uniformscaling.jl:59",
          "-(A::Diagonal{T},B::Bidiagonal{T}) at linalg/special.jl:88",
          "-(A::Bidiagonal{T},B::Diagonal{T}) at linalg/special.jl:89",
          "-(A::Diagonal{T},B::Tridiagonal{T}) at linalg/special.jl:88",
          "-(A::Tridiagonal{T},B::Diagonal{T}) at linalg/special.jl:89",
          "-(A::Diagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:88",
          "-(A::Triangular{T<:Number},B::Diagonal{T}) at linalg/special.jl:89",
          "-(A::Diagonal{T},B::Array{T,2}) at linalg/special.jl:88",
          "-(A::Bidiagonal{T},B::Tridiagonal{T}) at linalg/special.jl:88",
          "-(A::Tridiagonal{T},B::Bidiagonal{T}) at linalg/special.jl:89",
          "-(A::Bidiagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:88",
          "-(A::Triangular{T<:Number},B::Bidiagonal{T}) at linalg/special.jl:89",
          "-(A::Bidiagonal{T},B::Array{T,2}) at linalg/special.jl:88",
          "-(A::Tridiagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:88",
          "-(A::Triangular{T<:Number},B::Tridiagonal{T}) at linalg/special.jl:89",
          "-(A::Tridiagonal{T},B::Array{T,2}) at linalg/special.jl:88",
          "-(A::Triangular{T<:Number},B::Array{T,2}) at linalg/special.jl:88",
          "-(A::SymTridiagonal{T},B::Triangular{T<:Number}) at linalg/special.jl:97",
          "-(A::Triangular{T<:Number},B::SymTridiagonal{T}) at linalg/special.jl:98",
          "-(A::SymTridiagonal{T},B::Array{T,2}) at linalg/special.jl:97",
          "-(A::Diagonal{T},B::SymTridiagonal{T}) at linalg/special.jl:106",
          "-(A::SymTridiagonal{T},B::Diagonal{T}) at linalg/special.jl:107",
          "-(A::Bidiagonal{T},B::SymTridiagonal{T}) at linalg/special.jl:106",
          "-(A::SymTridiagonal{T},B::Bidiagonal{T}) at linalg/special.jl:107",
          "-(a::Set{T},b::Set{T}) at deprecated.jl:26",
          "-(a::IntSet,b::IntSet) at deprecated.jl:26",
          "-(x::Bool,A::Array{Bool,N}) at deprecated.jl:26",
          "-(x::Number,A::Array{T,N}) at deprecated.jl:26",
          "-{T}(a::HierarchicalValue{T},b::HierarchicalValue{T}) at pkg/resolve/versionweight.jl:19",
          "-{T}(a::HierarchicalValue{T}) at pkg/resolve/versionweight.jl:41",
          "-(a::VWPreBuildItem,b::VWPreBuildItem) at pkg/resolve/versionweight.jl:81",
          "-(a::VWPreBuildItem) at pkg/resolve/versionweight.jl:84",
          "-(a::VWPreBuild,b::VWPreBuild) at pkg/resolve/versionweight.jl:119",
          "-(a::VWPreBuild) at pkg/resolve/versionweight.jl:122",
          "-(a::VersionWeight,b::VersionWeight) at pkg/resolve/versionweight.jl:159",
          "-(a::VersionWeight) at pkg/resolve/versionweight.jl:169",
          "-(a::FieldValue,b::FieldValue) at pkg/resolve/fieldvalue.jl:40",
          "-(a::Vec2,b::Vec2) at graphics.jl:61",
          "-(d1::CalendarDuration,d2::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:298",
          "-(d::CalendarDuration,f::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:304",
          "-(f::FixedCalendarDuration,d::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:310",
          "-(d1::FixedCalendarDuration,d2::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:316",
          "-(t::CalendarTime,d::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:320",
          "-(t::CalendarTime,d::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:332",
          "-(d::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:362",
          "-(d::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:363",
          "-(d::AbstractCalendarDuration,t::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:335",
          "-(d::NAtype) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:379",
          "-(x::Bool,A::AbstractDataArray{Bool,N}) at deprecated.jl:26",
          "-(x::Union(Number,NAtype),A::AbstractDataArray{T,N}) at deprecated.jl:26",
          "-{T1<:CalendarTime,T2<:CalendarTime}(::T1<:CalendarTime,::AbstractArray{T2<:CalendarTime,N}) at operators.jl:365",
          "-{T1<:Union(CalendarTime,AbstractCalendarDuration),T2<:Union(CalendarTime,AbstractCalendarDuration)}(::T1<:Union(CalendarTime,AbstractCalendarDuration),::AbstractArray{T2<:Union(CalendarTime,AbstractCalendarDuration),N}) at operators.jl:365",
          "-{T1<:CalendarTime,T2<:CalendarTime}(::AbstractArray{T1<:CalendarTime,N},::T2<:CalendarTime) at operators.jl:367",
          "-{T<:AbstractCalendarDuration}(::AbstractArray{T<:AbstractCalendarDuration,1}) at operators.jl:354",
          "-{T<:AbstractCalendarDuration}(::AbstractArray{T<:AbstractCalendarDuration,N}) at operators.jl:357",
          "-{T1<:Union(CalendarTime,AbstractCalendarDuration),T2<:Union(CalendarTime,AbstractCalendarDuration)}(::AbstractArray{T1<:Union(CalendarTime,AbstractCalendarDuration),N},::T2<:Union(CalendarTime,AbstractCalendarDuration)) at operators.jl:367",
          "-{T1<:CalendarTime,T2<:CalendarTime}(::AbstractArray{T1<:CalendarTime,N},::AbstractArray{T2<:CalendarTime,N}) at operators.jl:371",
          "-{T1<:Union(CalendarTime,AbstractCalendarDuration),T2<:Union(CalendarTime,AbstractCalendarDuration)}(::AbstractArray{T1<:Union(CalendarTime,AbstractCalendarDuration),N},::AbstractArray{T2<:Union(CalendarTime,AbstractCalendarDuration),N}) at operators.jl:371",
          "-(t1::CalendarTime,t2::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:359",
          "-(a::MeasureNil,b::MeasureNil) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:33",
          "-(a::MeasureNil,b) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:34",
          "-(a::MeasureNil) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:36",
          "-{S,T}(a::Measure{S,T}) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:66",
          "-{P<:Period}(x::P<:Period) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:536",
          "-(a,b::MeasureNil) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:35",
          "-(a::Measure{S,T},b::Measure{S,T}) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:182",
          "-(::NAtype,::NAtype) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:679",
          "-(d::NAtype,x::Number) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:680",
          "-(x::Number,d::NAtype) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:680",
          "-(a::AbstractArray{Bool,N},b::DataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:332",
          "-(a::AbstractArray{T,N},b::DataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:332",
          "-(a::AbstractArray{Bool,N},b::AbstractDataArray{Bool,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "-(a::AbstractArray{T,N},b::AbstractDataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:356",
          "-{C<:Calendar}(dt::Date{C<:Calendar},y::Year{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:313",
          "-{C<:Calendar,T<:Offsets}(dt::DateTime{C<:Calendar,T<:Offsets},y::Year{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:321",
          "-{C<:Calendar}(dt::Date{C<:Calendar},z::Month{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:332",
          "-{C<:Calendar,T<:Offsets}(dt::DateTime{C<:Calendar,T<:Offsets},z::Month{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:344",
          "-{C<:Calendar}(x::Date{C<:Calendar},y::Week{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:351",
          "-{C<:Calendar}(x::Date{C<:Calendar},y::Day{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:353",
          "-{C<:Calendar,T<:Offsets}(x::DateTime{C<:Calendar,T<:Offsets},y::Week{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:355",
          "-{C<:Calendar,T<:Offsets}(x::DateTime{C<:Calendar,T<:Offsets},y::Day{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:357",
          "-{C<:Calendar,T<:Offsets}(x::DateTime{C<:Calendar,T<:Offsets},y::Hour{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:359",
          "-{C<:Calendar,T<:Offsets}(x::DateTime{C<:Calendar,T<:Offsets},y::Minute{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:361",
          "-{C<:Calendar,T<:Offsets}(x::DateTime{C<:Calendar,T<:Offsets},y::Second{C<:Calendar}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:363",
          "-(y::Period,x::Union(DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar})) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:365",
          "-{P<:Period}(x::Period,y::AbstractArray{P<:Period,N}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:544",
          "-{T<:Union(Period,DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar})}(x::Union(Period,DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar}),y::AbstractArray{T<:Union(Period,DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar}),N}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:369",
          "-{P<:Period}(x::AbstractArray{P<:Period,N},y::Period) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:545",
          "-{T<:Union(Period,DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar})}(x::AbstractArray{T<:Union(Period,DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar}),N},y::Union(Period,DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar})) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:370",
          "-{P<:Period}(x::P<:Period,y::P<:Period)",
          "-{P<:Period}(x::P<:Period,y::Real) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:540",
          "-{P<:Period}(x::Real,y::P<:Period) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:541",
          "-(x::Period,y::Period)"
        ]
      },
      {
        "name": "/",
        "summary": "Function",
        "help": "Base./(x, y)\n\n   Binary left-division operator.\n",
        "methods": 
        [
          "/(x::Integer,y::Integer) at int.jl:50",
          "/(x::Float32,y::Float32) at float.jl:130",
          "/(x::Float64,y::Float64) at float.jl:131",
          "/(x::Rational{T<:Integer},z::Complex{T<:Real}) at rational.jl:120",
          "/(a::Real,w::Complex{T<:Real}) at complex.jl:126",
          "/(z::Complex{Float64},w::Complex{Float64}) at complex.jl:162",
          "/(a::Complex{T<:Real},b::Complex{T<:Real}) at complex.jl:130",
          "/(z::Number,w::Complex{T<:Real}) at complex.jl:125",
          "/(z::Complex{T<:Real},x::Real) at complex.jl:127",
          "/(x::Rational{T<:Integer},y::Rational{T<:Integer}) at rational.jl:119",
          "/(a::Float16,b::Float16) at float16.jl:125",
          "/(x::BigFloat,c::Uint64) at mpfr.jl:270",
          "/(c::Uint64,x::BigFloat) at mpfr.jl:275",
          "/(x::BigFloat,c::Union(Uint16,Uint8,Uint32,Uint64)) at mpfr.jl:279",
          "/(c::Union(Uint16,Uint8,Uint32,Uint64),x::BigFloat) at mpfr.jl:280",
          "/(x::BigFloat,c::Int64) at mpfr.jl:284",
          "/(c::Int64,x::BigFloat) at mpfr.jl:289",
          "/(x::BigFloat,c::Union(Int8,Int64,Int16,Int32)) at mpfr.jl:293",
          "/(c::Union(Int8,Int64,Int16,Int32),x::BigFloat) at mpfr.jl:294",
          "/(x::BigFloat,c::Float64) at mpfr.jl:298",
          "/(c::Float64,x::BigFloat) at mpfr.jl:303",
          "/(x::BigFloat,c::Float32) at mpfr.jl:307",
          "/(c::Float32,x::BigFloat) at mpfr.jl:308",
          "/(x::BigFloat,c::BigInt) at mpfr.jl:312",
          "/(x::BigFloat,y::BigFloat) at mpfr.jl:321",
          "/{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::Union(DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),1,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)},DenseArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2},SubArray{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),2,A<:DenseArray{T,N},I<:(Union(Range{Int64},Int64)...,)}),B::Triangular{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/triangular.jl:50",
          "/(A::Triangular{T<:Number},B::Triangular{T<:Number}) at linalg/triangular.jl:111",
          "/(A::Triangular{T<:Number},B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/triangular.jl:112",
          "/(A::AbstractArray{T,2},B::Triangular{T<:Number}) at linalg/triangular.jl:113",
          "/(Da::Diagonal{T},Db::Diagonal{T}) at linalg/diagonal.jl:53",
          "/{T}(A::Bidiagonal{T},B::AbstractArray{T,1}) at linalg/bidiag.jl:118",
          "/(A::BitArray{N},B::BitArray{N}) at bitarray.jl:885",
          "/(A::Union(AbstractArray{T,2},AbstractArray{T,1}),B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/generic.jl:237",
          "/(x::MathConst{sym},y::MathConst{sym}) at constants.jl:23",
          "/(x::Union(DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar}),y::Union(DateTime{C<:Calendar,T<:Offsets},Date{C<:Calendar})) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:302",
          "/{T<:Number}(x::T<:Number,y::T<:Number) at promotion.jl:191",
          "/(x::Number,y::Number) at promotion.jl:161",
          "/(B::BitArray{N},x::Number) at bitarray.jl:888",
          "/(A::SymTridiagonal{T},B::Number) at linalg/tridiag.jl:48",
          "/(A::Tridiagonal{T},B::Number) at linalg/tridiag.jl:209",
          "/{T<:Number}(D::Diagonal{T},x::T<:Number) at linalg/diagonal.jl:43",
          "/(A::Bidiagonal{T},B::Number) at linalg/bidiag.jl:109",
          "/(a::DataArray{T,N},b::Number) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:296",
          "/(a::AbstractDataArray{T,N},b::Number) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:306",
          "/(A::AbstractArray{T,N},B::Number) at abstractarray.jl:354",
          "/(x::Number,B::BitArray{N}) at bitarray.jl:889",
          "/(B::AbstractArray{T,2},A::LU{T,S<:AbstractArray{T,2}}) at linalg/lu.jl:314",
          "/(J1::UniformScaling{T<:Number},J2::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:78",
          "/(J::UniformScaling{T<:Number},A::AbstractArray{T,2}) at linalg/uniformscaling.jl:79",
          "/(A::AbstractArray{T,2},J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:80",
          "/(J::UniformScaling{T<:Number},x::Number) at linalg/uniformscaling.jl:82",
          "/(x::Number,A::Array{T,N}) at deprecated.jl:26",
          "/(p::Vec2,s::Real) at graphics.jl:63",
          "/(a::MeasureNil,b::MeasureNil) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:42",
          "/(a,b::MeasureNil) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:43",
          "/(a::MeasureNil,b) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:44",
          "/{T,S}(a::Measure{T,T},b::Measure{S,T}) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:196",
          "/{T}(a::Measure{T,T},b::Number) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:282",
          "/(::NAtype,::NAtype) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:790",
          "/(d::NAtype,x::Number) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:791",
          "/(x::Number,d::NAtype) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:791",
          "/{T,N}(b::AbstractArray{T,N},::NAtype) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:795",
          "/(a::DataArray{T,N},b::String) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:296",
          "/(a::AbstractDataArray{T,N},b::String) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:306",
          "/(x::Union(Number,NAtype),A::AbstractDataArray{T,N}) at deprecated.jl:26",
          "/{P<:Period}(x::P<:Period,y::P<:Period) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:561",
          "/{P<:Period}(x::P<:Period,y::Real) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:553",
          "/{P<:Period}(x::Real,y::P<:Period) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:554",
          "/(x::Period,y::Period) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:555",
          "/{P<:Period}(x::Period,y::AbstractArray{P<:Period,N}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:556",
          "/{P<:Period}(x::AbstractArray{P<:Period,N},y::Period) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:557",
          "/(a::ScalMat,c::Float64) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:336",
          "/(a::AbstractPDMat,c::Float64) at /home/samuel/.julia/v0.3/PDMats/src/PDMats.jl:433"
        ]
      },
      {
        "name": "@data",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@pdata",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@~",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "AbstractDataArray",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "AbstractDataFrame",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "AbstractDataMatrix",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "AbstractDataVector",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "CoefTable",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DataArray",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DataArrays",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DataFrame",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DataFrameRow",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DataFrames",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DataMatrix",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DataVector",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "EachCol",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "EachCol(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "EachDropNA",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "EachFailNA",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "EachReplaceNA",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "EachRow",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "EachRow(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "FastPerm",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Formula",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "GroupApplied",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "GroupedDataFrame",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Histogram",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "ModelFrame",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "ModelMatrix",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "NA",
        "summary": "NAtype",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "NAException",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "NAtype",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Perm",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PooledDataArray",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PooledDataMatrix",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PooledDataVecs",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "PooledDataVecs{S,Q<:Integer,R<:Integer,N}(v1::PooledDataArray{S,Q<:Integer,N},v2::PooledDataArray{S,R<:Integer,N}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:738",
          "PooledDataVecs{S,R<:Integer,N}(v1::PooledDataArray{S,R<:Integer,N},v2::AbstractArray{S,N}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:771",
          "PooledDataVecs{S,R<:Integer,N}(v1::AbstractArray{S,N},v2::PooledDataArray{S,R<:Integer,N}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:778",
          "PooledDataVecs(v1::AbstractArray{T,N},v2::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:788",
          "PooledDataVecs(df1::AbstractDataFrame,df2::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/join.jl:81"
        ]
      },
      {
        "name": "PooledDataVector",
        "summary": "TypeConstructor",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "RegressionModel",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "StatisticalModel",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "StatsBase",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SubDataFrame",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "WeightVec",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "acf",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "acf(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "addcounts!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "addcounts!(r::AbstractArray{T,N},x::AbstractArray{T<:Integer,N},levels::UnitRange{T<:Integer}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:16",
          "addcounts!(r::AbstractArray{T,N},x::AbstractArray{T<:Integer,N},levels::UnitRange{T<:Integer},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:33",
          "addcounts!(r::AbstractArray{T,N},x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},levels::(UnitRange{T<:Integer},UnitRange{T<:Integer})) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:65",
          "addcounts!(r::AbstractArray{T,N},x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},levels::(UnitRange{T<:Integer},UnitRange{T<:Integer}),wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:95",
          "addcounts!{T,U}(cm::Dict{U,Int64},x::AbstractDataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/extras.jl:2",
          "addcounts!{T,U,W}(cm::Dict{U,W},x::AbstractDataArray{T,N},wv::WeightVec{W,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/DataArrays/src/extras.jl:9",
          "addcounts!{T}(cm::Dict{T,V},x::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:172",
          "addcounts!{T,W}(cm::Dict{T,V},x::AbstractArray{T,N},wv::WeightVec{W,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:179"
        ]
      },
      {
        "name": "allna",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "allna(d::AbstractDataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/abstractdataarray.jl:100",
          "allna(a::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/abstractdataarray.jl:85"
        ]
      },
      {
        "name": "anyna",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "anyna(d::AbstractDataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/abstractdataarray.jl:70",
          "anyna(a::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/abstractdataarray.jl:55"
        ]
      },
      {
        "name": "array",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "array{T}(da::DataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:324",
          "array{T}(da::DataArray{T,N},replacement::T) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:353",
          "array{T}(da::DataArray{T,N},replacement) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:383",
          "array{T,R}(da::PooledDataArray{T,R,N}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:888",
          "array{T,R}(da::PooledDataArray{T,R,N},replacement::T) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:901",
          "array(adf::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:881",
          "array(r::DataFrameRow{T<:AbstractDataFrame}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframerow/dataframerow.jl:37"
        ]
      },
      {
        "name": "autocor",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "autocor{T}(dv::DataArray{T,1},lag::Int64) at /home/samuel/.julia/v0.3/DataArrays/src/statistics.jl:21",
          "autocor{T}(dv::DataArray{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/statistics.jl:22"
        ]
      },
      {
        "name": "autocor!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "autocor!{T<:Union(Float64,Float32)}(r::AbstractArray{T<:Real,1},x::Array{T<:Union(Float64,Float32),1},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:93",
          "autocor!{T<:Union(Float64,Float32)}(r::AbstractArray{T<:Real,2},x::Array{T<:Union(Float64,Float32),2},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:107"
        ]
      },
      {
        "name": "autocov",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "autocov{T<:Real}(x::Array{T<:Real,1},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:81",
          "autocov{T<:Real}(x::Array{T<:Real,2},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:85",
          "autocov{T<:Real}(x::Union(Array{T<:Real,2},Array{T<:Real,1})) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:88"
        ]
      },
      {
        "name": "autocov!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "autocov!{T<:Union(Float64,Float32)}(r::AbstractArray{T<:Real,1},x::Array{T<:Union(Float64,Float32),1},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:51",
          "autocov!{T<:Union(Float64,Float32)}(r::AbstractArray{T<:Real,2},x::Array{T<:Union(Float64,Float32),2},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:64"
        ]
      },
      {
        "name": "by",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "by(d::AbstractDataFrame,cols,f::Function) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:202",
          "by(d::AbstractDataFrame,cols,s::Array{Symbol,1}) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:203",
          "by(d::AbstractDataFrame,cols,s::Symbol) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:204"
        ]
      },
      {
        "name": "cbind",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "cbind(args...) at /home/samuel/.julia/v0.3/DataFrames/src/deprecated.jl:262"
        ]
      },
      {
        "name": "ccf",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "ccf(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "coef",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "coef(::Union(DataFrameRegressionModel{M,T},DataFrameStatisticalModel{M,T}),...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:27",
          "coef(obj::StatisticalModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:5"
        ]
      },
      {
        "name": "coefnames",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "coefnames(fr::ModelFrame) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/formula.jl:249"
        ]
      },
      {
        "name": "coeftable",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "coeftable(model::Union(DataFrameRegressionModel{M,T},DataFrameStatisticalModel{M,T})) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:70",
          "coeftable(obj::StatisticalModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:6"
        ]
      },
      {
        "name": "colnames",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "colnames(adf::AbstractDataFrame) at deprecated.jl:26"
        ]
      },
      {
        "name": "colnames!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "colnames!(adf::AbstractDataFrame,vals) at deprecated.jl:26"
        ]
      },
      {
        "name": "coltypes",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "coltypes(adf::AbstractDataFrame) at deprecated.jl:26"
        ]
      },
      {
        "name": "colwise",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "colwise(f::Function,d::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:156",
          "colwise(f::Function,d::GroupedDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:157",
          "colwise(f::Function) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:158",
          "colwise(fns::Array{Function,1},d::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:161",
          "colwise(fns::Array{Function,1},d::GroupedDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:162",
          "colwise(fns::Array{Function,1},d::GroupedDataFrame,cn::Array{String,1}) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:163",
          "colwise(fns::Array{Function,1}) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:164",
          "colwise(d::AbstractDataFrame,s::Array{Symbol,1},cn::Array{T,1}) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:167",
          "colwise(d::AbstractDataFrame,s::Symbol,x) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:182",
          "colwise(d::AbstractDataFrame,s::Array{Symbol,1},x::String) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:183",
          "colwise(d::AbstractDataFrame,s::Symbol) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:184",
          "colwise(d::AbstractDataFrame,s::Array{Symbol,1}) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:185",
          "colwise(gd::GroupedDataFrame,s::Array{Symbol,1}) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:191",
          "colwise(d::GroupedDataFrame,s::Symbol,x) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:194",
          "colwise(d::GroupedDataFrame,s::Array{Symbol,1},x::String) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:195",
          "colwise(d::GroupedDataFrame,s::Symbol) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:196",
          "colwise(f) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:159"
        ]
      },
      {
        "name": "combine",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "combine(x) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:131"
        ]
      },
      {
        "name": "compact",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "compact{T,R<:Integer,N}(d::PooledDataArray{T,R<:Integer,N}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:268"
        ]
      },
      {
        "name": "competerank",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "competerank(x::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/ranking.jl:62"
        ]
      },
      {
        "name": "complete_cases",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "complete_cases(df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:871"
        ]
      },
      {
        "name": "complete_cases!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "complete_cases!(df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:878"
        ]
      },
      {
        "name": "confint",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "confint(::Union(DataFrameRegressionModel{M,T},DataFrameStatisticalModel{M,T}),...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:27",
          "confint(obj::StatisticalModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:7"
        ]
      },
      {
        "name": "corkendall",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "corkendall(x::AbstractArray{T<:Real,1},y::AbstractArray{T<:Real,1}) at /home/samuel/.julia/v0.3/StatsBase/src/rankcorr.jl:89",
          "corkendall(X::AbstractArray{T<:Real,2},y::AbstractArray{T<:Real,1}) at /home/samuel/.julia/v0.3/StatsBase/src/rankcorr.jl:91",
          "corkendall(x::AbstractArray{T<:Real,1},Y::AbstractArray{T<:Real,2}) at /home/samuel/.julia/v0.3/StatsBase/src/rankcorr.jl:93",
          "corkendall(X::AbstractArray{T<:Real,2},Y::AbstractArray{T<:Real,2}) at /home/samuel/.julia/v0.3/StatsBase/src/rankcorr.jl:95",
          "corkendall(X::AbstractArray{T<:Real,2}) at /home/samuel/.julia/v0.3/StatsBase/src/rankcorr.jl:98"
        ]
      },
      {
        "name": "corspearman",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "corspearman(dv1::DataArray{T,1},dv2::DataArray{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:850",
          "corspearman(x::AbstractArray{T<:Real,1},y::AbstractArray{T<:Real,1}) at /home/samuel/.julia/v0.3/StatsBase/src/rankcorr.jl:13",
          "corspearman(X::AbstractArray{T<:Real,2},Y::AbstractArray{T<:Real,2}) at /home/samuel/.julia/v0.3/StatsBase/src/rankcorr.jl:15",
          "corspearman(X::AbstractArray{T<:Real,2},y::AbstractArray{T<:Real,1}) at /home/samuel/.julia/v0.3/StatsBase/src/rankcorr.jl:16",
          "corspearman(x::AbstractArray{T<:Real,1},Y::AbstractArray{T<:Real,2}) at /home/samuel/.julia/v0.3/StatsBase/src/rankcorr.jl:17",
          "corspearman(X::AbstractArray{T<:Real,2}) at /home/samuel/.julia/v0.3/StatsBase/src/rankcorr.jl:19"
        ]
      },
      {
        "name": "countmap",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "countmap{T}(x::AbstractDataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/extras.jl:23",
          "countmap{T,W}(x::AbstractDataArray{T,N},wv::WeightVec{W,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/DataArrays/src/extras.jl:27",
          "countmap{T}(x::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:192",
          "countmap{T,W}(x::AbstractArray{T,N},wv::WeightVec{W,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:193"
        ]
      },
      {
        "name": "counts",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "counts(x::AbstractArray{T<:Integer,N},levels::UnitRange{T<:Integer}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:50",
          "counts(x::AbstractArray{T<:Integer,N},levels::UnitRange{T<:Integer},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:51",
          "counts(x::AbstractArray{T<:Integer,N},k::Integer) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:52",
          "counts(x::AbstractArray{T<:Integer,N},k::Integer,wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:53",
          "counts(x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},levels::(UnitRange{T<:Integer},UnitRange{T<:Integer})) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:126",
          "counts(x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},levels::(UnitRange{T<:Integer},UnitRange{T<:Integer}),wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:130",
          "counts(x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},levels::UnitRange{T<:Integer}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:133",
          "counts(x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},levels::UnitRange{T<:Integer},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:134",
          "counts(x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},ks::(Integer,Integer)) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:136",
          "counts(x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},ks::(Integer,Integer),wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:137",
          "counts(x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},k::Integer) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:138",
          "counts(x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},k::Integer,wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:139"
        ]
      },
      {
        "name": "crosscor",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "crosscor{T<:Real}(x::Array{T<:Real,1},y::Array{T<:Real,1},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:351",
          "crosscor{T<:Real}(x::Array{T<:Real,2},y::Array{T<:Real,1},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:355",
          "crosscor{T<:Real}(x::Array{T<:Real,1},y::Array{T<:Real,2},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:359",
          "crosscor{T<:Real}(x::Array{T<:Real,2},y::Array{T<:Real,2},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:363",
          "crosscor{T<:Real}(x::Union(Array{T<:Real,2},Array{T<:Real,1}),y::Union(Array{T<:Real,2},Array{T<:Real,1})) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:366"
        ]
      },
      {
        "name": "crosscor!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "crosscor!{T<:Union(Float64,Float32)}(r::AbstractArray{T<:Real,1},x::Array{T<:Union(Float64,Float32),1},y::Array{T<:Union(Float64,Float32),1},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:255",
          "crosscor!{T<:Union(Float64,Float32)}(r::AbstractArray{T<:Real,2},x::Array{T<:Union(Float64,Float32),2},y::Array{T<:Union(Float64,Float32),1},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:270",
          "crosscor!{T<:Union(Float64,Float32)}(r::AbstractArray{T<:Real,2},x::Array{T<:Union(Float64,Float32),1},y::Array{T<:Union(Float64,Float32),2},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:290",
          "crosscor!{T<:Union(Float64,Float32)}(r::AbstractArray{T<:Union(Float64,Float32),3},x::Array{T<:Union(Float64,Float32),2},y::Array{T<:Union(Float64,Float32),2},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:310"
        ]
      },
      {
        "name": "crosscov",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "crosscov{T<:Real}(x::Array{T<:Real,1},y::Array{T<:Real,1},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:234",
          "crosscov{T<:Real}(x::Array{T<:Real,2},y::Array{T<:Real,1},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:238",
          "crosscov{T<:Real}(x::Array{T<:Real,1},y::Array{T<:Real,2},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:242",
          "crosscov{T<:Real}(x::Array{T<:Real,2},y::Array{T<:Real,2},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:246",
          "crosscov{T<:Real}(x::Union(Array{T<:Real,2},Array{T<:Real,1}),y::Union(Array{T<:Real,2},Array{T<:Real,1})) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:249"
        ]
      },
      {
        "name": "crosscov!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "crosscov!{T<:Union(Float64,Float32)}(r::AbstractArray{T<:Real,1},x::Array{T<:Union(Float64,Float32),1},y::Array{T<:Union(Float64,Float32),1},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:148",
          "crosscov!{T<:Union(Float64,Float32)}(r::AbstractArray{T<:Real,2},x::Array{T<:Union(Float64,Float32),2},y::Array{T<:Union(Float64,Float32),1},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:162",
          "crosscov!{T<:Union(Float64,Float32)}(r::AbstractArray{T<:Real,2},x::Array{T<:Union(Float64,Float32),1},y::Array{T<:Union(Float64,Float32),2},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:180",
          "crosscov!{T<:Union(Float64,Float32)}(r::AbstractArray{T<:Union(Float64,Float32),3},x::Array{T<:Union(Float64,Float32),2},y::Array{T<:Union(Float64,Float32),2},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:198"
        ]
      },
      {
        "name": "crossentropy",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "crossentropy{T<:Real}(p::AbstractArray{T<:Real,N},q::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:153"
        ]
      },
      {
        "name": "cut",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "cut{S,T}(x::AbstractArray{S,1},breaks::Array{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/extras.jl:31",
          "cut(x::AbstractArray{T,1},ngroups::Integer) at /home/samuel/.julia/v0.3/DataArrays/src/extras.jl:64"
        ]
      },
      {
        "name": "data",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "data(a::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:1038",
          "data(rl::RLogical) at /home/samuel/.julia/v0.3/DataFrames/src/RDA.jl:286",
          "data(rn::RNumeric) at /home/samuel/.julia/v0.3/DataFrames/src/RDA.jl:287",
          "data(ri::RInteger) at /home/samuel/.julia/v0.3/DataFrames/src/RDA.jl:289",
          "data(rs::RString) at /home/samuel/.julia/v0.3/DataFrames/src/RDA.jl:303",
          "data(rc::RComplex) at /home/samuel/.julia/v0.3/DataFrames/src/RDA.jl:305"
        ]
      },
      {
        "name": "denserank",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "denserank(x::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/ranking.jl:91"
        ]
      },
      {
        "name": "describe",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "describe(dv::AbstractDataArray{T,1}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:721",
          "describe(df::DataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:722",
          "describe{T<:Number}(io,dv::AbstractDataArray{T<:Number,1}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:724",
          "describe{T}(io,dv::AbstractDataArray{T,1}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:741",
          "describe(io,df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:754"
        ]
      },
      {
        "name": "deviance",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "deviance(::Union(DataFrameRegressionModel{M,T},DataFrameStatisticalModel{M,T}),...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:27",
          "deviance(obj::StatisticalModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:8"
        ]
      },
      {
        "name": "drop_duplicates!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "drop_duplicates!(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "dropna",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "dropna(dv::DataArray{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:417",
          "dropna{T}(pdv::PooledDataArray{T,R,1}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:914",
          "dropna(v::AbstractArray{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:399"
        ]
      },
      {
        "name": "duplicated",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "duplicated(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "each_dropna",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "each_dropna{T}(da::AbstractDataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:442"
        ]
      },
      {
        "name": "each_failNA",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "each_failNA{T}(da::AbstractDataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:426"
        ]
      },
      {
        "name": "each_replaceNA",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "each_replaceNA(da::AbstractDataArray{T,N},val) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:459",
          "each_replaceNA(val) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:462"
        ]
      },
      {
        "name": "eachcol",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "eachcol(df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/iteration.jl:25"
        ]
      },
      {
        "name": "eachrow",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "eachrow(df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/iteration.jl:11"
        ]
      },
      {
        "name": "ecdf",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "ecdf{T<:Real}(X::AbstractArray{T<:Real,1}) at /home/samuel/.julia/v0.3/StatsBase/src/empirical.jl:7"
        ]
      },
      {
        "name": "eltypes",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "eltypes(adf::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:209"
        ]
      },
      {
        "name": "entropy",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "entropy{T<:Real}(p::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:141",
          "entropy(d::Arcsine) at /home/samuel/.julia/v0.3/Distributions/src/univariate/arcsine.jl:14",
          "entropy(d::Bernoulli) at /home/samuel/.julia/v0.3/Distributions/src/univariate/bernoulli.jl:24",
          "entropy(d::Beta) at /home/samuel/.julia/v0.3/Distributions/src/univariate/beta.jl:16",
          "entropy(d::Binomial) at /home/samuel/.julia/v0.3/Distributions/src/univariate/binomial.jl:20",
          "entropy(d::Categorical) at /home/samuel/.julia/v0.3/Distributions/src/univariate/categorical.jl:117",
          "entropy(d::Cauchy) at /home/samuel/.julia/v0.3/Distributions/src/univariate/cauchy.jl:25",
          "entropy(d::Chi) at /home/samuel/.julia/v0.3/Distributions/src/univariate/chi.jl:46",
          "entropy(d::Chisq) at /home/samuel/.julia/v0.3/Distributions/src/univariate/chisq.jl:14",
          "entropy(d::Cosine) at /home/samuel/.julia/v0.3/Distributions/src/univariate/cosine.jl:15",
          "entropy(d::DiscreteUniform) at /home/samuel/.julia/v0.3/Distributions/src/univariate/discreteuniform.jl:18",
          "entropy(d::EmpiricalUnivariateDistribution) at /home/samuel/.julia/v0.3/Distributions/src/univariate/empirical.jl:36",
          "entropy(d::Exponential) at /home/samuel/.julia/v0.3/Distributions/src/univariate/exponential.jl:28",
          "entropy(d::FDist) at /home/samuel/.julia/v0.3/Distributions/src/univariate/fdist.jl:37",
          "entropy(d::Gamma) at /home/samuel/.julia/v0.3/Distributions/src/univariate/gamma.jl:23",
          "entropy(d::Erlang) at /home/samuel/.julia/v0.3/Distributions/src/univariate/erlang.jl:25",
          "entropy(d::Geometric) at /home/samuel/.julia/v0.3/Distributions/src/univariate/geometric.jl:33",
          "entropy(d::Gumbel) at /home/samuel/.julia/v0.3/Distributions/src/univariate/gumbel.jl:20",
          "entropy(d::InverseGamma) at /home/samuel/.julia/v0.3/Distributions/src/univariate/inversegamma.jl:37",
          "entropy(d::Laplace) at /home/samuel/.julia/v0.3/Distributions/src/univariate/laplace.jl:22",
          "entropy(d::Levy) at /home/samuel/.julia/v0.3/Distributions/src/univariate/levy.jl:16",
          "entropy(d::Logistic) at /home/samuel/.julia/v0.3/Distributions/src/univariate/logistic.jl:26",
          "entropy(d::LogNormal) at /home/samuel/.julia/v0.3/Distributions/src/univariate/lognormal.jl:37",
          "entropy(d::Normal) at /home/samuel/.julia/v0.3/Distributions/src/univariate/normal.jl:29",
          "entropy(cf::NormalCanon) at /home/samuel/.julia/v0.3/Distributions/src/univariate/normalcanon.jl:37",
          "entropy(d::Pareto) at /home/samuel/.julia/v0.3/Distributions/src/univariate/pareto.jl:43",
          "entropy(d::Poisson) at /home/samuel/.julia/v0.3/Distributions/src/univariate/poisson.jl:13",
          "entropy(d::Rayleigh) at /home/samuel/.julia/v0.3/Distributions/src/univariate/rayleigh.jl:20",
          "entropy(d::TDist) at /home/samuel/.julia/v0.3/Distributions/src/univariate/tdist.jl:14",
          "entropy(d::SymTriangularDist) at /home/samuel/.julia/v0.3/Distributions/src/univariate/symtriangular.jl:32",
          "entropy(d::Uniform) at /home/samuel/.julia/v0.3/Distributions/src/univariate/uniform.jl:38",
          "entropy(d::Weibull) at /home/samuel/.julia/v0.3/Distributions/src/univariate/weibull.jl:43",
          "entropy(d::Dirichlet) at /home/samuel/.julia/v0.3/Distributions/src/multivariate/dirichlet.jl:79",
          "entropy(d::GenericMvNormal{Cov<:AbstractPDMat}) at /home/samuel/.julia/v0.3/Distributions/src/multivariate/mvnormal.jl:77",
          "entropy(d::GenericMvNormalCanon{Prec<:AbstractPDMat}) at /home/samuel/.julia/v0.3/Distributions/src/multivariate/mvnormalcanon.jl:91",
          "entropy(d::GenericMvTDist{Cov<:AbstractPDMat}) at /home/samuel/.julia/v0.3/Distributions/src/multivariate/mvtdist.jl:85",
          "entropy(W::Wishart) at /home/samuel/.julia/v0.3/Distributions/src/matrix/wishart.jl:91",
          "entropy(d::Truncated{Normal,S<:ValueSupport}) at /home/samuel/.julia/v0.3/Distributions/src/univariate/truncated/normal.jl:3"
        ]
      },
      {
        "name": "findat",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "findat(a::AbstractArray{T,N},b::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/StatsBase/src/misc.jl:87"
        ]
      },
      {
        "name": "fit",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "fit(::Type{Histogram{T<:Real,N,E}},v::AbstractArray{T,1},edg::AbstractArray{T,1}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:137",
          "fit(::Type{Histogram{T<:Real,N,E}},v::AbstractArray{T,1}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:139",
          "fit(::Type{Histogram{T<:Real,N,E}},v::AbstractArray{T,1},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:144",
          "fit{W}(::Type{Histogram{T<:Real,N,E}},v::AbstractArray{T,1},wv::WeightVec{W,Vec<:AbstractArray{T<:Real,1}},edg::AbstractArray{T,1}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:142",
          "fit{N}(::Type{Histogram{T<:Real,N,E}},vs::NTuple{N,AbstractArray{T,1}},edges::NTuple{N,AbstractArray{T,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:176",
          "fit{N}(::Type{Histogram{T<:Real,N,E}},vs::NTuple{N,AbstractArray{T,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:178",
          "fit{N}(::Type{Histogram{T<:Real,N,E}},vs::NTuple{N,AbstractArray{T,1}},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:183",
          "fit{N,W}(::Type{Histogram{T<:Real,N,E}},vs::NTuple{N,AbstractArray{T,1}},wv::WeightVec{W,Vec<:AbstractArray{T<:Real,1}},edges::NTuple{N,AbstractArray{T,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:181",
          "fit(obj::StatisticalModel,data...) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:13",
          "fit{T<:RegressionModel}(::Type{T<:RegressionModel},f::Formula,df::AbstractDataFrame,args...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:52",
          "fit{T<:StatisticalModel}(::Type{T<:StatisticalModel},f::Formula,df::AbstractDataFrame,args...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:52",
          "fit(::Type{Beta},x::Array{T,N}) at /home/samuel/.julia/v0.3/Distributions/src/univariate/beta.jl:119",
          "fit{T<:Real}(::Type{Cauchy},x::Array{T<:Real,N}) at /home/samuel/.julia/v0.3/Distributions/src/univariate/cauchy.jl:47",
          "fit{D<:Distribution{F<:VariateForm,S<:ValueSupport}}(dt::Type{D<:Distribution{F<:VariateForm,S<:ValueSupport}},x) at /home/samuel/.julia/v0.3/Distributions/src/fallbacks.jl:286",
          "fit{D<:Distribution{F<:VariateForm,S<:ValueSupport}}(dt::Type{D<:Distribution{F<:VariateForm,S<:ValueSupport}},args...) at /home/samuel/.julia/v0.3/Distributions/src/fallbacks.jl:287"
        ]
      },
      {
        "name": "fitted",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "fitted(obj::RegressionModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:17"
        ]
      },
      {
        "name": "flipud",
        "summary": "Function",
        "help": "Base.flipud(A)\n\n   Equivalent to \"flipdim(A,1)\".\n",
        "methods": 
        [
          "flipud(A::AbstractArray{T,N}) at abstractarray.jl:407",
          "flipud(df::DataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/deprecated.jl:240"
        ]
      },
      {
        "name": "flipud!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "flipud!(df::DataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/deprecated.jl:245"
        ]
      },
      {
        "name": "geomean",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "geomean(a::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/means.jl:5"
        ]
      },
      {
        "name": "getpoolidx",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "getpoolidx{T,R<:Union(Uint16,Int16,Int8,Uint8)}(pda::PooledDataArray{T,R<:Union(Uint16,Int16,Int8,Uint8),N},val) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:535",
          "getpoolidx{T,R}(pda::PooledDataArray{T,R,N},val) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:550"
        ]
      },
      {
        "name": "gl",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "gl(n::Integer,k::Integer,l::Integer) at /home/samuel/.julia/v0.3/DataArrays/src/statistics.jl:26",
          "gl(n::Integer,k::Integer) at /home/samuel/.julia/v0.3/DataArrays/src/statistics.jl:35"
        ]
      },
      {
        "name": "gmean",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "gmean(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "groupby",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "groupby{T}(df::AbstractDataFrame,cols::Array{T,1}) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:26",
          "groupby(d::AbstractDataFrame,cols) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:50",
          "groupby{T}(cols::Array{T,1}) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:53",
          "groupby(cols) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:54"
        ]
      },
      {
        "name": "harmmean",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "harmmean(a::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/means.jl:16"
        ]
      },
      {
        "name": "head",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "head(dv::AbstractDataArray{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/datavector.jl:15",
          "head(df::AbstractDataFrame,r::Int64) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:693",
          "head(df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:694"
        ]
      },
      {
        "name": "hist",
        "summary": "Function",
        "help": "Base.hist(v[, n]) -> e, counts\n\n   Compute the histogram of \"v\", optionally using approximately\n   \"n\" bins. The return values are a range \"e\", which correspond\n   to the edges of the bins, and \"counts\" containing the number of\n   elements of \"v\" in each bin. Note: Julia does not ignore \"NaN\"\n   values in the computation.\n\nBase.hist(v, e) -> e, counts\n\n   Compute the histogram of \"v\" using a vector/range \"e\" as the\n   edges for the bins. The result will be a vector of length\n   \"length(e) - 1\", such that the element at location \"i\"\n   satisfies \"sum(e[i] .< v .<= e[i+1])\". Note: Julia does not\n   ignore \"NaN\" values in the computation.\n",
        "methods": 
        [
          "hist(v::AbstractArray{T,1},edg::AbstractArray{T,1}) at statistics.jl:494",
          "hist(v::AbstractArray{T,1},n::Integer) at statistics.jl:495",
          "hist(v::AbstractArray{T,1}) at statistics.jl:496",
          "hist(A::AbstractArray{T,2},edg::AbstractArray{T,1}) at statistics.jl:510",
          "hist(A::AbstractArray{T,2},n::Integer) at statistics.jl:511",
          "hist(A::AbstractArray{T,2}) at statistics.jl:512"
        ]
      },
      {
        "name": "histrange",
        "summary": "Function",
        "help": "Base.histrange(v, n)\n\n   Compute *nice* bin ranges for the edges of a histogram of \"v\",\n   using approximately \"n\" bins. The resulting step sizes will be 1,\n   2 or 5 multiplied by a power of 10. Note: Julia does not ignore\n   \"NaN\" values in the computation.\n",
        "methods": 
        [
          "histrange{T<:FloatingPoint}(v::AbstractArray{T<:FloatingPoint,N},n::Integer,closed::Symbol) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:5",
          "histrange{T<:Integer}(v::AbstractArray{T<:Integer,N},n::Integer,closed::Symbol) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:34",
          "histrange{N}(vs::NTuple{N,AbstractArray{T,1}},nbins::NTuple{N,Integer},closed::Symbol) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:64",
          "histrange{N}(vs::NTuple{N,AbstractArray{T,1}},nbins::Integer,closed::Symbol) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:65"
        ]
      },
      {
        "name": "hmean",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "hmean(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "indexmap",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "indexmap{T}(a::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/StatsBase/src/misc.jl:55"
        ]
      },
      {
        "name": "indicatormat",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "indicatormat(x::AbstractArray{T<:Integer,N},k::Integer) at /home/samuel/.julia/v0.3/StatsBase/src/misc.jl:97",
          "indicatormat{T<:Union(Real,String)}(x::AbstractArray{T<:Union(Real,String),N}) at /home/samuel/.julia/v0.3/StatsBase/src/misc.jl:104",
          "indicatormat(x::AbstractArray{T,N},c::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/StatsBase/src/misc.jl:101",
          "indicatormat(x::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/StatsBase/src/misc.jl:105"
        ]
      },
      {
        "name": "indicators",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "indicators(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "inverse_rle",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "inverse_rle{T}(vals::AbstractArray{T,1},lens::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/misc.jl:35"
        ]
      },
      {
        "name": "invsoftplus",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "invsoftplus(x::FloatingPoint) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:21",
          "invsoftplus(x::Real) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:22",
          "invsoftplus{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "invsoftplus{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "invsoftplus{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "iqr",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "iqr{T<:Real}(v::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:189"
        ]
      },
      {
        "name": "isna",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "isna(x::NAtype) at /home/samuel/.julia/v0.3/DataArrays/src/natype.jl:33",
          "isna(da::DataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:828",
          "isna(da::DataArray{T,N},inds...) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:846",
          "isna(pda::PooledDataArray{T,R<:Integer,N}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:235",
          "isna(pda::PooledDataArray{T,R<:Integer,N},i::Real) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:252",
          "isna(a::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/abstractdataarray.jl:115",
          "isna(a::AbstractArray{T,N},i::Real) at /home/samuel/.julia/v0.3/DataArrays/src/abstractdataarray.jl:132",
          "isna(x) at /home/samuel/.julia/v0.3/DataArrays/src/natype.jl:34"
        ]
      },
      {
        "name": "kde",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "kde(data::AbstractArray{T<:Real,1}) at /home/samuel/.julia/v0.3/StatsBase/src/deprecates.jl:60",
          "kde(x::AbstractArray{T<:Real,1},y::AbstractArray{T<:Real,1}) at /home/samuel/.julia/v0.3/StatsBase/src/deprecates.jl:121"
        ]
      },
      {
        "name": "kldivergence",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "kldivergence{T<:Real}(p::AbstractArray{T<:Real,N},q::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:167"
        ]
      },
      {
        "name": "kurtosis",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "kurtosis(dv::DataArray{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:846",
          "kurtosis(v::AbstractArray{T<:Real,N},m::Real) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:55",
          "kurtosis(v::AbstractArray{T<:Real,N},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}},m::Real) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:70",
          "kurtosis(v::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:91",
          "kurtosis(v::AbstractArray{T<:Real,N},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:92",
          "kurtosis(d::Arcsine) at /home/samuel/.julia/v0.3/Distributions/src/univariate/arcsine.jl:16",
          "kurtosis(d::Bernoulli) at /home/samuel/.julia/v0.3/Distributions/src/univariate/bernoulli.jl:35",
          "kurtosis(d::Beta) at /home/samuel/.julia/v0.3/Distributions/src/univariate/beta.jl:24",
          "kurtosis(d::Binomial) at /home/samuel/.julia/v0.3/Distributions/src/univariate/binomial.jl:40",
          "kurtosis(d::Categorical) at /home/samuel/.julia/v0.3/Distributions/src/univariate/categorical.jl:107",
          "kurtosis(d::Cauchy) at /home/samuel/.julia/v0.3/Distributions/src/univariate/cauchy.jl:23",
          "kurtosis(d::Chi) at /home/samuel/.julia/v0.3/Distributions/src/univariate/chi.jl:36",
          "kurtosis(d::Chisq) at /home/samuel/.julia/v0.3/Distributions/src/univariate/chisq.jl:18",
          "kurtosis(d::Cosine) at /home/samuel/.julia/v0.3/Distributions/src/univariate/cosine.jl:17",
          "kurtosis(d::DiscreteUniform) at /home/samuel/.julia/v0.3/Distributions/src/univariate/discreteuniform.jl:21",
          "kurtosis(d::EmpiricalUnivariateDistribution) at /home/samuel/.julia/v0.3/Distributions/src/univariate/empirical.jl:38",
          "kurtosis(d::Exponential) at /home/samuel/.julia/v0.3/Distributions/src/univariate/exponential.jl:30",
          "kurtosis(d::FDist) at /home/samuel/.julia/v0.3/Distributions/src/univariate/fdist.jl:30",
          "kurtosis(d::Gamma) at /home/samuel/.julia/v0.3/Distributions/src/univariate/gamma.jl:27",
          "kurtosis(d::EdgeworthAbstract) at /home/samuel/.julia/v0.3/Distributions/src/univariate/edgeworth.jl:10",
          "kurtosis(d::Erlang) at /home/samuel/.julia/v0.3/Distributions/src/univariate/erlang.jl:27",
          "kurtosis(d::Geometric) at /home/samuel/.julia/v0.3/Distributions/src/univariate/geometric.jl:31",
          "kurtosis(d::Gumbel) at /home/samuel/.julia/v0.3/Distributions/src/univariate/gumbel.jl:22",
          "kurtosis(d::InverseGamma) at /home/samuel/.julia/v0.3/Distributions/src/univariate/inversegamma.jl:22",
          "kurtosis(d::InverseGaussian) at /home/samuel/.julia/v0.3/Distributions/src/univariate/inversegaussian.jl:19",
          "kurtosis(d::Laplace) at /home/samuel/.julia/v0.3/Distributions/src/univariate/laplace.jl:24",
          "kurtosis(d::Levy) at /home/samuel/.julia/v0.3/Distributions/src/univariate/levy.jl:31",
          "kurtosis(d::Logistic) at /home/samuel/.julia/v0.3/Distributions/src/univariate/logistic.jl:24",
          "kurtosis(d::LogNormal) at /home/samuel/.julia/v0.3/Distributions/src/univariate/lognormal.jl:33",
          "kurtosis(d::NegativeBinomial) at /home/samuel/.julia/v0.3/Distributions/src/univariate/negativebinomial.jl:63",
          "kurtosis(d::NoncentralChisq) at /home/samuel/.julia/v0.3/Distributions/src/univariate/noncentralchisq.jl:13",
          "kurtosis(d::Normal) at /home/samuel/.julia/v0.3/Distributions/src/univariate/normal.jl:27",
          "kurtosis(cf::NormalCanon) at /home/samuel/.julia/v0.3/Distributions/src/univariate/normalcanon.jl:32",
          "kurtosis(d::Pareto) at /home/samuel/.julia/v0.3/Distributions/src/univariate/pareto.jl:39",
          "kurtosis(d::Poisson) at /home/samuel/.julia/v0.3/Distributions/src/univariate/poisson.jl:38",
          "kurtosis(d::Rayleigh) at /home/samuel/.julia/v0.3/Distributions/src/univariate/rayleigh.jl:22",
          "kurtosis(d::Skellam) at /home/samuel/.julia/v0.3/Distributions/src/univariate/skellam.jl:17",
          "kurtosis(d::SymTriangularDist) at /home/samuel/.julia/v0.3/Distributions/src/univariate/symtriangular.jl:30",
          "kurtosis(d::Uniform) at /home/samuel/.julia/v0.3/Distributions/src/univariate/uniform.jl:36",
          "kurtosis(d::Weibull) at /home/samuel/.julia/v0.3/Distributions/src/univariate/weibull.jl:31",
          "kurtosis(d::Distribution{F<:VariateForm,S<:ValueSupport},correction::Bool) at /home/samuel/.julia/v0.3/Distributions/src/fallbacks.jl:95"
        ]
      },
      {
        "name": "levels",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "levels(da::DataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:1170",
          "levels{T}(pda::PooledDataArray{T,R<:Integer,N}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:298"
        ]
      },
      {
        "name": "levelsmap",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "levelsmap{T}(a::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/StatsBase/src/misc.jl:66"
        ]
      },
      {
        "name": "load_df",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "load_df(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "loaddf",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "loaddf(filename::String) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/io.jl:1113"
        ]
      },
      {
        "name": "logistic",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "logistic(x::FloatingPoint) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:12",
          "logistic(x::Real) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:13",
          "logistic{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "logistic{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "logistic{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "logit",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "logit(x::FloatingPoint) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:15",
          "logit(x::Real) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:16",
          "logit{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "logit{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "logit{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "loglikelihood",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "loglikelihood(::Union(DataFrameRegressionModel{M,T},DataFrameStatisticalModel{M,T}),...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:27",
          "loglikelihood(obj::StatisticalModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:9"
        ]
      },
      {
        "name": "logsumexp",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "logsumexp{T<:FloatingPoint}(x::T<:FloatingPoint,y::T<:FloatingPoint) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:33",
          "logsumexp{T<:Real}(x::T<:Real,y::T<:Real) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:34",
          "logsumexp(x::Real,y::Real) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:35",
          "logsumexp{T<:Real}(x::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:38"
        ]
      },
      {
        "name": "mad",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "mad{T<:Real}(v::UnitRange{T<:Real}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:120",
          "mad(dv::DataArray{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:846",
          "mad{T<:Real}(v::AbstractArray{T<:Real,N},center::Real) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:108",
          "mad{T<:Real}(v::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:119"
        ]
      },
      {
        "name": "melt",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "melt(df::DataFrame,id_vars) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:26",
          "melt(df::DataFrame,id_vars,measure_vars) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:27"
        ]
      },
      {
        "name": "melt_df",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "melt_df(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "meltdf",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "meltdf(df::AbstractDataFrame,id_vars) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:275",
          "meltdf(df::AbstractDataFrame,id_vars,measure_vars) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:276"
        ]
      },
      {
        "name": "merge",
        "summary": "Function",
        "help": "Base.merge(collection, others...)\n\n   Construct a merged collection from the given collections.\n",
        "methods": 
        [
          "merge(d::Associative{K,V},others::Associative{K,V}...) at dict.jl:83",
          "merge{T,V<:Number}(ct1::Accumulator{T,V<:Number},ct2::Accumulator{T,V<:Number}) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:59",
          "merge(df1::AbstractDataFrame,df2::AbstractDataFrame) at deprecated.jl:26"
        ]
      },
      {
        "name": "middle",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "middle{T<:FloatingPoint}(a1::T<:FloatingPoint,a2::T<:FloatingPoint) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:130",
          "middle{T<:Integer}(a1::T<:Integer,a2::T<:Integer) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:131"
        ]
      },
      {
        "name": "midpoints",
        "summary": "Function",
        "help": "Base.midpoints(e)\n\n   Compute the midpoints of the bins with edges \"e\". The result is a\n   vector/range of length \"length(e) - 1\". Note: Julia does not\n   ignore \"NaN\" values in the computation.\n",
        "methods": 
        [
          "midpoints(r::Range{T}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:70",
          "midpoints(v::AbstractArray{T,1}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:71"
        ]
      },
      {
        "name": "mode",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "mode{T<:Integer}(a::AbstractArray{T<:Integer,N},rgn::UnitRange{T<:Integer}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:203",
          "mode{T}(a::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:254",
          "mode(d::Arcsine) at /home/samuel/.julia/v0.3/Distributions/src/univariate/arcsine.jl:36",
          "mode(d::Bernoulli) at /home/samuel/.julia/v0.3/Distributions/src/univariate/bernoulli.jl:43",
          "mode(d::Beta) at /home/samuel/.julia/v0.3/Distributions/src/univariate/beta.jl:35",
          "mode(d::BetaPrime) at /home/samuel/.julia/v0.3/Distributions/src/univariate/betaprime.jl:24",
          "mode(d::Binomial) at /home/samuel/.julia/v0.3/Distributions/src/univariate/binomial.jl:52",
          "mode(d::Categorical) at /home/samuel/.julia/v0.3/Distributions/src/univariate/categorical.jl:139",
          "mode(d::Cauchy) at /home/samuel/.julia/v0.3/Distributions/src/univariate/cauchy.jl:19",
          "mode(d::Chi) at /home/samuel/.julia/v0.3/Distributions/src/univariate/chi.jl:24",
          "mode(d::Chisq) at /home/samuel/.julia/v0.3/Distributions/src/univariate/chisq.jl:35",
          "mode(d::Cosine) at /home/samuel/.julia/v0.3/Distributions/src/univariate/cosine.jl:26",
          "mode(d::DiscreteUniform) at /home/samuel/.julia/v0.3/Distributions/src/univariate/discreteuniform.jl:39",
          "mode(d::Exponential) at /home/samuel/.julia/v0.3/Distributions/src/univariate/exponential.jl:40",
          "mode(d::FDist) at /home/samuel/.julia/v0.3/Distributions/src/univariate/fdist.jl:20",
          "mode(d::Gamma) at /home/samuel/.julia/v0.3/Distributions/src/univariate/gamma.jl:38",
          "mode(d::Erlang) at /home/samuel/.julia/v0.3/Distributions/src/univariate/erlang.jl:36",
          "mode(d::Geometric) at /home/samuel/.julia/v0.3/Distributions/src/univariate/geometric.jl:27",
          "mode(d::Gumbel) at /home/samuel/.julia/v0.3/Distributions/src/univariate/gumbel.jl:28",
          "mode(d::InverseGamma) at /home/samuel/.julia/v0.3/Distributions/src/univariate/inversegamma.jl:24",
          "mode(d::InverseGaussian) at /home/samuel/.julia/v0.3/Distributions/src/univariate/inversegaussian.jl:16",
          "mode(d::Laplace) at /home/samuel/.julia/v0.3/Distributions/src/univariate/laplace.jl:40",
          "mode(d::Levy) at /home/samuel/.julia/v0.3/Distributions/src/univariate/levy.jl:33",
          "mode(d::Logistic) at /home/samuel/.julia/v0.3/Distributions/src/univariate/logistic.jl:18",
          "mode(d::LogNormal) at /home/samuel/.julia/v0.3/Distributions/src/univariate/lognormal.jl:21",
          "mode(d::NegativeBinomial) at /home/samuel/.julia/v0.3/Distributions/src/univariate/negativebinomial.jl:68",
          "mode(d::Normal) at /home/samuel/.julia/v0.3/Distributions/src/univariate/normal.jl:22",
          "mode(cf::NormalCanon) at /home/samuel/.julia/v0.3/Distributions/src/univariate/normalcanon.jl:29",
          "mode(d::Pareto) at /home/samuel/.julia/v0.3/Distributions/src/univariate/pareto.jl:25",
          "mode(d::Poisson) at /home/samuel/.julia/v0.3/Distributions/src/univariate/poisson.jl:54",
          "mode(d::Rayleigh) at /home/samuel/.julia/v0.3/Distributions/src/univariate/rayleigh.jl:28",
          "mode(d::TDist) at /home/samuel/.julia/v0.3/Distributions/src/univariate/tdist.jl:24",
          "mode(d::SymTriangularDist) at /home/samuel/.julia/v0.3/Distributions/src/univariate/symtriangular.jl:26",
          "mode(d::Uniform) at /home/samuel/.julia/v0.3/Distributions/src/univariate/uniform.jl:27",
          "mode(d::Weibull) at /home/samuel/.julia/v0.3/Distributions/src/univariate/weibull.jl:19",
          "mode(d::Dirichlet) at /home/samuel/.julia/v0.3/Distributions/src/multivariate/dirichlet.jl:107",
          "mode(d::DirichletCanon) at /home/samuel/.julia/v0.3/Distributions/src/multivariate/dirichlet.jl:108",
          "mode(d::GenericMvNormal{Cov<:AbstractPDMat}) at /home/samuel/.julia/v0.3/Distributions/src/multivariate/mvnormal.jl:69",
          "mode(d::GenericMvNormalCanon{Prec<:AbstractPDMat}) at /home/samuel/.julia/v0.3/Distributions/src/multivariate/mvnormalcanon.jl:83",
          "mode(d::GenericMvTDist{Cov<:AbstractPDMat}) at /home/samuel/.julia/v0.3/Distributions/src/multivariate/mvtdist.jl:73",
          "mode(d::NormalInverseGamma) at /home/samuel/.julia/v0.3/Distributions/src/conjugates/normalinversegamma.jl:40"
        ]
      },
      {
        "name": "model_response",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "model_response(mf::ModelFrame) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/formula.jl:183"
        ]
      },
      {
        "name": "modes",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "modes{T<:Integer}(a::AbstractArray{T<:Integer,N},rgn::UnitRange{T<:Integer}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:226",
          "modes{T}(a::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:282",
          "modes(d::Arcsine) at /home/samuel/.julia/v0.3/Distributions/src/univariate/arcsine.jl:37",
          "modes(d::Bernoulli) at /home/samuel/.julia/v0.3/Distributions/src/univariate/bernoulli.jl:46",
          "modes(d::Beta) at /home/samuel/.julia/v0.3/Distributions/src/univariate/beta.jl:56",
          "modes(d::Binomial) at /home/samuel/.julia/v0.3/Distributions/src/univariate/binomial.jl:64",
          "modes(d::Categorical) at /home/samuel/.julia/v0.3/Distributions/src/univariate/categorical.jl:142",
          "modes(d::DiscreteUniform) at /home/samuel/.julia/v0.3/Distributions/src/univariate/discreteuniform.jl:40",
          "modes(d::EmpiricalUnivariateDistribution) at /home/samuel/.julia/v0.3/Distributions/src/univariate/empirical.jl:44",
          "modes(d::Erlang) at /home/samuel/.julia/v0.3/Distributions/src/univariate/erlang.jl:37",
          "modes(d::Poisson) at /home/samuel/.julia/v0.3/Distributions/src/univariate/poisson.jl:55",
          "modes(d::Uniform) at /home/samuel/.julia/v0.3/Distributions/src/univariate/uniform.jl:28",
          "modes(d::Dirichlet) at /home/samuel/.julia/v0.3/Distributions/src/multivariate/dirichlet.jl:110",
          "modes(d::GenericMvNormal{Cov<:AbstractPDMat}) at /home/samuel/.julia/v0.3/Distributions/src/multivariate/mvnormal.jl:70",
          "modes(d::GenericMvNormalCanon{Prec<:AbstractPDMat}) at /home/samuel/.julia/v0.3/Distributions/src/multivariate/mvnormalcanon.jl:84",
          "modes(d::GenericMvTDist{Cov<:AbstractPDMat}) at /home/samuel/.julia/v0.3/Distributions/src/multivariate/mvtdist.jl:74",
          "modes(d::Truncated{Normal,S<:ValueSupport}) at /home/samuel/.julia/v0.3/Distributions/src/univariate/truncated/normal.jl:21",
          "modes(d::Distribution{F<:VariateForm,S<:ValueSupport}) at /home/samuel/.julia/v0.3/Distributions/src/fallbacks.jl:112"
        ]
      },
      {
        "name": "names!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "names!(x::Index,nm::Array{Symbol,1}) at /home/samuel/.julia/v0.3/DataFrames/src/other/index.jl:32",
          "names!(df::DataFrame,vals) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:206"
        ]
      },
      {
        "name": "ncol",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "ncol(df::DataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:226"
        ]
      },
      {
        "name": "nobs",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "nobs(::Union(DataFrameRegressionModel{M,T},DataFrameStatisticalModel{M,T}),...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:27",
          "nobs(obj::StatisticalModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:10"
        ]
      },
      {
        "name": "nonunique",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "nonunique(df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:909"
        ]
      },
      {
        "name": "nquantile",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "nquantile{T<:Real}(v::AbstractArray{T<:Real,N},n::Integer) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:192"
        ]
      },
      {
        "name": "nrow",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "nrow(df::DataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:225"
        ]
      },
      {
        "name": "nullable!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "nullable!(colnames::Array{Symbol,1},df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:1000",
          "nullable!(colnums::Array{Int64,1},df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:1001"
        ]
      },
      {
        "name": "order",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "order{T<:Union(Real,Symbol)}(col::T<:Union(Real,Symbol)) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/sort.jl:23"
        ]
      },
      {
        "name": "ordinalrank",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "ordinalrank(x::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/ranking.jl:33"
        ]
      },
      {
        "name": "pacf",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pacf{T<:Real}(X::Array{T<:Real,2},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:424",
          "pacf{T<:Real}(x::Array{T<:Real,1},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:428"
        ]
      },
      {
        "name": "pacf!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pacf!{T<:Union(Float64,Float32)}(r::AbstractArray{T<:Real,2},X::Array{T<:Union(Float64,Float32),2},lags::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/StatsBase/src/signalcorr.jl:407"
        ]
      },
      {
        "name": "padNA",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "padNA(dv::AbstractDataArray{T,1},front::Integer,back::Integer) at /home/samuel/.julia/v0.3/DataArrays/src/datavector.jl:107"
        ]
      },
      {
        "name": "pdata",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pdata(a::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:884"
        ]
      },
      {
        "name": "percent_change",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "percent_change{T}(v::Array{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/statistics.jl:13"
        ]
      },
      {
        "name": "percentile",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "percentile{T<:Real}(v::AbstractArray{T<:Real,N},p) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:188"
        ]
      },
      {
        "name": "pivot_table",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pivot_table(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "pivottable",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pivottable(df::AbstractDataFrame,rows::Array{Int64,1},cols::Array{Int64,1},value::Int64,fun::Function) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:83",
          "pivottable(df::AbstractDataFrame,rows,cols,value) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:102",
          "pivottable(df::AbstractDataFrame,rows,cols,value,fun) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:103"
        ]
      },
      {
        "name": "pool",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pool(a::AbstractArray{T,1}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:957"
        ]
      },
      {
        "name": "pool!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pool!(df::AbstractDataFrame,cname::Union(Integer,Symbol)) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:960",
          "pool!{T<:Union(Integer,Symbol)}(df::AbstractDataFrame,cnames::Array{T<:Union(Integer,Symbol),1}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:965",
          "pool!(df::AbstractDataFrame,cname::String) at /home/samuel/.julia/v0.3/DataFrames/src/deprecated.jl:160",
          "pool!{T<:String}(df::AbstractDataFrame,cname::Array{T<:String,1}) at /home/samuel/.julia/v0.3/DataFrames/src/deprecated.jl:165",
          "pool!(df) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:972"
        ]
      },
      {
        "name": "predict",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "predict(::DataFrameRegressionModel{M,T},...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:27",
          "predict(obj::RegressionModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:20"
        ]
      },
      {
        "name": "predict!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "predict!(::DataFrameRegressionModel{M,T},...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:27",
          "predict!(obj::RegressionModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:21"
        ]
      },
      {
        "name": "print_table",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "print_table(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "printtable",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "printtable(io::IO,df::DataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/io.jl:987",
          "printtable(df::DataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/io.jl:1025"
        ]
      },
      {
        "name": "proportionmap",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "proportionmap(x::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:195",
          "proportionmap(x::AbstractArray{T,N},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:196"
        ]
      },
      {
        "name": "proportions",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "proportions(x::AbstractArray{T<:Integer,N},levels::UnitRange{T<:Integer}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:55",
          "proportions(x::AbstractArray{T<:Integer,N},levels::UnitRange{T<:Integer},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:56",
          "proportions(x::AbstractArray{T<:Integer,N},k::Integer) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:57",
          "proportions(x::AbstractArray{T<:Integer,N},k::Integer,wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:58",
          "proportions(x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},levels::(UnitRange{T<:Integer},UnitRange{T<:Integer})) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:141",
          "proportions(x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},levels::(UnitRange{T<:Integer},UnitRange{T<:Integer}),wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:142",
          "proportions(x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},ks::(Integer,Integer)) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:144",
          "proportions(x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},ks::(Integer,Integer),wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:145",
          "proportions(x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},k::Integer) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:146",
          "proportions(x::AbstractArray{T<:Integer,N},y::AbstractArray{T<:Integer,N},k::Integer,wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/counts.jl:147"
        ]
      },
      {
        "name": "rbind",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "rbind(args...) at /home/samuel/.julia/v0.3/DataFrames/src/deprecated.jl:260"
        ]
      },
      {
        "name": "read_rda",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "read_rda(io::IO) at /home/samuel/.julia/v0.3/DataFrames/src/RDA.jl:258",
          "read_rda(fnm::ASCIIString) at /home/samuel/.julia/v0.3/DataFrames/src/RDA.jl:272"
        ]
      },
      {
        "name": "read_table",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "read_table(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "readtable",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "readtable(io::IO) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/io.jl:765",
          "readtable(io::IO,nbytes::Integer) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/io.jl:765",
          "readtable(pathname::String) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/io.jl:844"
        ]
      },
      {
        "name": "reldiff",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "reldiff{T}(v::Array{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/statistics.jl:3"
        ]
      },
      {
        "name": "removeNA",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "removeNA(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "rename",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "rename(x::Index,args...) at /home/samuel/.julia/v0.3/DataFrames/src/other/index.jl:70",
          "rename(df::DataFrame,from,to) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:218"
        ]
      },
      {
        "name": "rename!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "rename!(x::Index,from::Symbol,to::Symbol) at /home/samuel/.julia/v0.3/DataFrames/src/other/index.jl:67",
          "rename!(x::Index,f::Function) at /home/samuel/.julia/v0.3/DataFrames/src/other/index.jl:68",
          "rename!(x::Index,nms) at /home/samuel/.julia/v0.3/DataFrames/src/other/index.jl:49",
          "rename!(x::Index,from,to) at /home/samuel/.julia/v0.3/DataFrames/src/other/index.jl:66",
          "rename!(df::DataFrame,from,to) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:221"
        ]
      },
      {
        "name": "reorder",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "reorder(x::PooledDataArray{T,R<:Integer,N}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:380",
          "reorder(x::PooledDataArray{T,R<:Integer,N},y::AbstractArray{T,1}...) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:382",
          "reorder(fun::Function,x::PooledDataArray{T,R<:Integer,N},df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/deprecated.jl:222",
          "reorder(x::PooledDataArray{T,R<:Integer,N},df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/deprecated.jl:230",
          "reorder(fun::Function,x::PooledDataArray{T,R<:Integer,N},y::AbstractArray{T,1}...) at /home/samuel/.julia/v0.3/DataFrames/src/deprecated.jl:235"
        ]
      },
      {
        "name": "rep",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "rep{T<:Integer}(x::AbstractArray{T,1},lengths::AbstractArray{T<:Integer,1}) at /home/samuel/.julia/v0.3/DataArrays/src/extras.jl:67",
          "rep(x::AbstractArray{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/extras.jl:98",
          "rep(x::AbstractArray{T,1},times::Integer) at /home/samuel/.julia/v0.3/DataArrays/src/extras.jl:83",
          "rep(x::AbstractArray{T,1},times::Integer,each::Integer) at /home/samuel/.julia/v0.3/DataArrays/src/extras.jl:83",
          "rep(x,times::Integer) at /home/samuel/.julia/v0.3/DataArrays/src/extras.jl:101"
        ]
      },
      {
        "name": "replace!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "replace!(x::PooledDataArray{NAtype,R<:Integer,N},fromval::NAtype,toval::NAtype) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:651",
          "replace!(x::PooledDataArray{T,R<:Integer,N},fromval::NAtype,toval::NAtype) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:654",
          "replace!{S,T}(x::PooledDataArray{S,R<:Integer,N},fromval::T,toval::NAtype) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:657",
          "replace!{S,T}(x::PooledDataArray{S,R<:Integer,N},fromval::NAtype,toval::T) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:667",
          "replace!{R,S,T}(x::PooledDataArray{R,R<:Integer,N},fromval::S,toval::T) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:681"
        ]
      },
      {
        "name": "residuals",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "residuals(::DataFrameRegressionModel{M,T},...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:27",
          "residuals(obj::RegressionModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:19"
        ]
      },
      {
        "name": "rle",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "rle{T}(v::Array{T,1}) at /home/samuel/.julia/v0.3/StatsBase/src/misc.jl:5"
        ]
      },
      {
        "name": "sample",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "sample(a::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/StatsBase/src/sampling.jl:108",
          "sample{T}(a::AbstractArray{T,N},n::Integer) at /home/samuel/.julia/v0.3/StatsBase/src/sampling.jl:152",
          "sample{T}(a::AbstractArray{T,N},dims::(Int64...,)) at /home/samuel/.julia/v0.3/StatsBase/src/sampling.jl:156",
          "sample(wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/sampling.jl:167",
          "sample(a::AbstractArray{T,N},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/sampling.jl:179",
          "sample{T}(a::AbstractArray{T,N},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}},n::Integer) at /home/samuel/.julia/v0.3/StatsBase/src/sampling.jl:231",
          "sample{T}(a::AbstractArray{T,N},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}},dims::(Int64...,)) at /home/samuel/.julia/v0.3/StatsBase/src/sampling.jl:234"
        ]
      },
      {
        "name": "samplepair",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "samplepair(n::Int64) at /home/samuel/.julia/v0.3/StatsBase/src/sampling.jl:6",
          "samplepair(a::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/StatsBase/src/sampling.jl:12"
        ]
      },
      {
        "name": "save",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "save(filename::String,df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/io.jl:1106"
        ]
      },
      {
        "name": "sem",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "sem{T<:Real}(a::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:105"
        ]
      },
      {
        "name": "set_levels",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "set_levels(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "set_levels!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "set_levels!(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "setlevels",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setlevels{T,R}(x::PooledDataArray{T,R,N},newpool::AbstractArray{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:317",
          "setlevels(x::PooledDataArray{T,R<:Integer,N},d::Dict{K,V}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:347"
        ]
      },
      {
        "name": "setlevels!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setlevels!{T,R}(x::PooledDataArray{T,R,N},newpool::AbstractArray{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:330",
          "setlevels!{T,R}(x::PooledDataArray{T,R,N},d::Dict{T,Any}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:369",
          "setlevels!{T,R}(x::PooledDataArray{T,R,N},d::Dict{T,T}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:359"
        ]
      },
      {
        "name": "showcols",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "showcols(io::IO,adf::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/show.jl:611",
          "showcols(adf::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/show.jl:619"
        ]
      },
      {
        "name": "skewness",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "skewness(dv::DataArray{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/operators.jl:846",
          "skewness(v::AbstractArray{T<:Real,N},m::Real) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:13",
          "skewness(v::AbstractArray{T<:Real,N},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}},m::Real) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:29",
          "skewness(v::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:49",
          "skewness(v::AbstractArray{T<:Real,N},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:50",
          "skewness(d::Arcsine) at /home/samuel/.julia/v0.3/Distributions/src/univariate/arcsine.jl:47",
          "skewness(d::Bernoulli) at /home/samuel/.julia/v0.3/Distributions/src/univariate/bernoulli.jl:33",
          "skewness(d::Beta) at /home/samuel/.julia/v0.3/Distributions/src/univariate/beta.jl:94",
          "skewness(d::BetaPrime) at /home/samuel/.julia/v0.3/Distributions/src/univariate/betaprime.jl:49",
          "skewness(d::Binomial) at /home/samuel/.julia/v0.3/Distributions/src/univariate/binomial.jl:46",
          "skewness(d::Categorical) at /home/samuel/.julia/v0.3/Distributions/src/univariate/categorical.jl:95",
          "skewness(d::Cauchy) at /home/samuel/.julia/v0.3/Distributions/src/univariate/cauchy.jl:22",
          "skewness(d::Chi) at /home/samuel/.julia/v0.3/Distributions/src/univariate/chi.jl:31",
          "skewness(d::Chisq) at /home/samuel/.julia/v0.3/Distributions/src/univariate/chisq.jl:61",
          "skewness(d::Cosine) at /home/samuel/.julia/v0.3/Distributions/src/univariate/cosine.jl:34",
          "skewness(d::DiscreteUniform) at /home/samuel/.julia/v0.3/Distributions/src/univariate/discreteuniform.jl:52",
          "skewness(d::EmpiricalUnivariateDistribution) at /home/samuel/.julia/v0.3/Distributions/src/univariate/empirical.jl:61",
          "skewness(d::Exponential) at /home/samuel/.julia/v0.3/Distributions/src/univariate/exponential.jl:52",
          "skewness(d::FDist) at /home/samuel/.julia/v0.3/Distributions/src/univariate/fdist.jl:26",
          "skewness(d::Gamma) at /home/samuel/.julia/v0.3/Distributions/src/univariate/gamma.jl:57",
          "skewness(d::EdgeworthAbstract) at /home/samuel/.julia/v0.3/Distributions/src/univariate/edgeworth.jl:9",
          "skewness(d::Erlang) at /home/samuel/.julia/v0.3/Distributions/src/univariate/erlang.jl:55",
          "skewness(d::Geometric) at /home/samuel/.julia/v0.3/Distributions/src/univariate/geometric.jl:30",
          "skewness(d::Gumbel) at /home/samuel/.julia/v0.3/Distributions/src/univariate/gumbel.jl:44",
          "skewness(d::InverseGamma) at /home/samuel/.julia/v0.3/Distributions/src/univariate/inversegamma.jl:21",
          "skewness(d::InverseGaussian) at /home/samuel/.julia/v0.3/Distributions/src/univariate/inversegaussian.jl:18",
          "skewness(d::Laplace) at /home/samuel/.julia/v0.3/Distributions/src/univariate/laplace.jl:62",
          "skewness(d::Levy) at /home/samuel/.julia/v0.3/Distributions/src/univariate/levy.jl:30",
          "skewness(d::Logistic) at /home/samuel/.julia/v0.3/Distributions/src/univariate/logistic.jl:23",
          "skewness(d::LogNormal) at /home/samuel/.julia/v0.3/Distributions/src/univariate/lognormal.jl:29",
          "skewness(d::NegativeBinomial) at /home/samuel/.julia/v0.3/Distributions/src/univariate/negativebinomial.jl:58",
          "skewness(d::NoncentralChisq) at /home/samuel/.julia/v0.3/Distributions/src/univariate/noncentralchisq.jl:12",
          "skewness(d::Normal) at /home/samuel/.julia/v0.3/Distributions/src/univariate/normal.jl:26",
          "skewness(cf::NormalCanon) at /home/samuel/.julia/v0.3/Distributions/src/univariate/normalcanon.jl:31",
          "skewness(d::Pareto) at /home/samuel/.julia/v0.3/Distributions/src/univariate/pareto.jl:33",
          "skewness(d::Poisson) at /home/samuel/.julia/v0.3/Distributions/src/univariate/poisson.jl:57",
          "skewness(d::Rayleigh) at /home/samuel/.julia/v0.3/Distributions/src/univariate/rayleigh.jl:38",
          "skewness(d::Skellam) at /home/samuel/.julia/v0.3/Distributions/src/univariate/skellam.jl:43",
          "skewness(d::SymTriangularDist) at /home/samuel/.julia/v0.3/Distributions/src/univariate/symtriangular.jl:29",
          "skewness(d::Uniform) at /home/samuel/.julia/v0.3/Distributions/src/univariate/uniform.jl:35",
          "skewness(d::Weibull) at /home/samuel/.julia/v0.3/Distributions/src/univariate/weibull.jl:24"
        ]
      },
      {
        "name": "softmax",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "softmax{T<:Real}(x::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:64"
        ]
      },
      {
        "name": "softmax!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "softmax!{T<:FloatingPoint}(x::AbstractArray{T<:FloatingPoint,N}) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:63",
          "softmax!{T<:Real}(r::AbstractArray{T,N},x::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:50"
        ]
      },
      {
        "name": "softplus",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "softplus(x::FloatingPoint) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:18",
          "softplus(x::Real) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:19",
          "softplus{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "softplus{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "softplus{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "sort",
        "summary": "Function",
        "help": "Base.sort(v, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Variant of \"sort!\" that returns a sorted copy of \"v\" leaving\n   \"v\" itself unmodified.\n\nBase.sort(A, dim, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Sort a multidimensional array \"A\" along the given dimension.\n",
        "methods": 
        [
          "sort(r::UnitRange{T<:Real}) at range.jl:496",
          "sort{T<:Real}(r::Range{T<:Real}) at range.jl:499",
          "sort(pda::PooledDataArray{T,R<:Integer,N}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:716",
          "sort(pda::PooledDataArray{T,R<:Integer,N},::ReverseOrdering{Fwd<:Ordering}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:717",
          "sort(v::AbstractArray{T,1}) at sort.jl:334",
          "sort(v::AbstractArray{T,1},d::Integer,o::Ordering) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},d::Integer,a::Algorithm) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},d::Integer,a::Algorithm,o::Ordering) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},d::Integer,o::Ordering,a::Algorithm) at deprecated.jl:26",
          "sort(A::AbstractArray{T,N},dim::Integer) at sort.jl:344",
          "sort(v::AbstractArray{T,1},o::Ordering) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},a::Algorithm,o::Ordering) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},o::Ordering,a::Algorithm) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},f::Function) at deprecated.jl:26",
          "sort(f::Function,v::AbstractArray{T,1}) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},a::Algorithm,f::Function) at deprecated.jl:26",
          "sort(v::AbstractArray{T,1},f::Function,a::Algorithm) at deprecated.jl:26",
          "sort(f::Function,v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26",
          "sort(df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/sort.jl:294",
          "sort(df::AbstractDataFrame,a::Algorithm,o::Ordering) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/sort.jl:311",
          "sort(df::AbstractDataFrame,o::Ordering) at deprecated.jl:26"
        ]
      },
      {
        "name": "sort!",
        "summary": "Function",
        "help": "Base.sort!(v, [dim,] [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Sort the vector \"v\" in place. \"QuickSort\" is used by default\n   for numeric arrays while \"MergeSort\" is used for other arrays.\n   You can specify an algorithm to use via the \"alg\" keyword (see\n   Sorting Algorithms for available algorithms). The \"by\" keyword\n   lets you provide a function that will be applied to each element\n   before comparison; the \"lt\" keyword allows providing a custom\n   \"less than\" function; use \"rev=true\" to reverse the sorting\n   order. These options are independent and can be used together in\n   all possible combinations: if both \"by\" and \"lt\" are specified,\n   the \"lt\" function is applied to the result of the \"by\"\n   function; \"rev=true\" reverses whatever ordering specified via the\n   \"by\" and \"lt\" keywords.\n",
        "methods": 
        [
          "sort!(r::UnitRange{T<:Real}) at range.jl:497",
          "sort!(v::AbstractArray{T,1},lo::Int64,hi::Int64,::InsertionSortAlg,o::Ordering) at sort.jl:242",
          "sort!(v::AbstractArray{T,1},lo::Int64,hi::Int64,a::QuickSortAlg,o::Ordering) at sort.jl:259",
          "sort!(v::AbstractArray{T,1},lo::Int64,hi::Int64,a::MergeSortAlg,o::Ordering) at sort.jl:289",
          "sort!(v::AbstractArray{T,1},lo::Int64,hi::Int64,a::MergeSortAlg,o::Ordering,t) at sort.jl:289",
          "sort!{T<:Union(Float64,Float32)}(v::AbstractArray{T<:Union(Float64,Float32),1},a::Algorithm,o::Union(ForwardOrdering,ReverseOrdering{ForwardOrdering})) at sort.jl:441",
          "sort!{O<:Union(ForwardOrdering,ReverseOrdering{ForwardOrdering}),T<:Union(Float64,Float32)}(v::Array{Int64,1},a::Algorithm,o::Perm{O<:Union(ForwardOrdering,ReverseOrdering{ForwardOrdering}),Array{T<:Union(Float64,Float32),1}}) at sort.jl:442",
          "sort!(v::AbstractArray{T,1},alg::Algorithm,order::Ordering) at sort.jl:329",
          "sort!(v::AbstractArray{T,1}) at sort.jl:330",
          "sort!{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:809",
          "sort!{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:809",
          "sort!(v::AbstractArray{T,1},o::Ordering) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},o::Ordering,a::Algorithm) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},f::Function) at deprecated.jl:26",
          "sort!(f::Function,v::AbstractArray{T,1}) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},a::Algorithm,f::Function) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},f::Function,a::Algorithm) at deprecated.jl:26",
          "sort!(f::Function,v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},d::Integer,o::Ordering) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},d::Integer,a::Algorithm) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},d::Integer,a::Algorithm,o::Ordering) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},d::Integer,o::Ordering,a::Algorithm) at deprecated.jl:26",
          "sort!(v::AbstractArray{T,1},lo::Int64,hi::Int64,a::HeapSortAlg,o::Ordering) at /home/samuel/.julia/v0.3/SortingAlgorithms/src/SortingAlgorithms.jl:25",
          "sort!(vs::AbstractArray{T,1},lo::Int64,hi::Int64,::RadixSortAlg,o::Ordering) at /home/samuel/.julia/v0.3/SortingAlgorithms/src/SortingAlgorithms.jl:49",
          "sort!(vs::AbstractArray{T,1},lo::Int64,hi::Int64,::RadixSortAlg,o::Ordering,ts) at /home/samuel/.julia/v0.3/SortingAlgorithms/src/SortingAlgorithms.jl:49",
          "sort!(v::AbstractArray{T,1},lo::Int64,hi::Int64,::TimSortAlg,o::Ordering) at /home/samuel/.julia/v0.3/SortingAlgorithms/src/SortingAlgorithms.jl:518",
          "sort!(df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/sort.jl:294",
          "sort!(df::AbstractDataFrame,a::Algorithm,o::Ordering) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/sort.jl:302",
          "sort!(df::AbstractDataFrame,o::Ordering) at deprecated.jl:26"
        ]
      },
      {
        "name": "sortby",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "sortby(v::AbstractArray{T,1},f::Function) at deprecated.jl:26",
          "sortby(f::Function,v::AbstractArray{T,1}) at deprecated.jl:26",
          "sortby(v::AbstractArray{T,1},a::Algorithm,f::Function) at deprecated.jl:26",
          "sortby(v::AbstractArray{T,1},f::Function,a::Algorithm) at deprecated.jl:26",
          "sortby(f::Function,v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26",
          "sortby(df::AbstractDataFrame,col::Union(Real,Symbol),o::Ordering) at deprecated.jl:26",
          "sortby(df::AbstractDataFrame,col::Union(Real,Symbol)) at deprecated.jl:26",
          "sortby(df::AbstractDataFrame,cols::Union(AbstractArray{Symbol,1},AbstractArray{Integer,1},AbstractArray{ASCIIString,1},AbstractArray{UTF8String,1}),o::Ordering) at deprecated.jl:26",
          "sortby(df::AbstractDataFrame,cols::Union(AbstractArray{Symbol,1},AbstractArray{Integer,1},AbstractArray{ASCIIString,1},AbstractArray{UTF8String,1})) at deprecated.jl:26"
        ]
      },
      {
        "name": "sortby!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "sortby!(v::AbstractArray{T,1},f::Function) at deprecated.jl:26",
          "sortby!(f::Function,v::AbstractArray{T,1}) at deprecated.jl:26",
          "sortby!(v::AbstractArray{T,1},a::Algorithm,f::Function) at deprecated.jl:26",
          "sortby!(v::AbstractArray{T,1},f::Function,a::Algorithm) at deprecated.jl:26",
          "sortby!(f::Function,v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26",
          "sortby!(df::AbstractDataFrame,by::Function) at deprecated.jl:26",
          "sortby!(df::AbstractDataFrame,col::Union(Real,Symbol),o::Ordering) at deprecated.jl:26",
          "sortby!(df::AbstractDataFrame,col::Union(Real,Symbol)) at deprecated.jl:26",
          "sortby!(df::AbstractDataFrame,cols::Union(AbstractArray{Symbol,1},AbstractArray{Integer,1},AbstractArray{ASCIIString,1},AbstractArray{UTF8String,1}),o::Ordering) at deprecated.jl:26",
          "sortby!(df::AbstractDataFrame,cols::Union(AbstractArray{Symbol,1},AbstractArray{Integer,1},AbstractArray{ASCIIString,1},AbstractArray{UTF8String,1})) at deprecated.jl:26"
        ]
      },
      {
        "name": "sortperm",
        "summary": "Function",
        "help": "Base.sortperm(v, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\n   Return a permutation vector of indices of \"v\" that puts it in\n   sorted order. Specify \"alg\" to choose a particular sorting\n   algorithm (see Sorting Algorithms). \"MergeSort\" is used by\n   default, and since it is stable, the resulting permutation will be\n   the lexicographically first one that puts the input array into\n   sorted order – i.e. indices of equal elements appear in ascending\n   order. If you choose a non-stable sorting algorithm such as\n   \"QuickSort\", a different permutation that puts the array into\n   order may be returned. The order is specified using the same\n   keywords as \"sort!\".\n",
        "methods": 
        [
          "sortperm(r::UnitRange{T<:Real}) at range.jl:501",
          "sortperm{T<:Real}(r::Range{T<:Real}) at range.jl:502",
          "sortperm(pda::PooledDataArray{T,R<:Integer,N}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:708",
          "sortperm(pda::PooledDataArray{T,R<:Integer,N},::ReverseOrdering{Fwd<:Ordering}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:715",
          "sortperm(v::AbstractArray{T,1}) at sort.jl:338",
          "sortperm(v::AbstractArray{T,1},o::Ordering) at deprecated.jl:26",
          "sortperm(v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26",
          "sortperm{V}(x::AbstractArray{T,1},a::Algorithm,o::FastPerm{ForwardOrdering,V}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:723",
          "sortperm{V}(x::AbstractArray{T,1},a::Algorithm,o::FastPerm{ReverseOrdering{Fwd<:Ordering},V}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:724",
          "sortperm(v::AbstractArray{T,1},a::Algorithm,o::Ordering) at deprecated.jl:26",
          "sortperm(v::AbstractArray{T,1},o::Ordering,a::Algorithm) at deprecated.jl:26",
          "sortperm(v::AbstractArray{T,1},f::Function) at deprecated.jl:26",
          "sortperm(f::Function,v::AbstractArray{T,1}) at deprecated.jl:26",
          "sortperm(v::AbstractArray{T,1},a::Algorithm,f::Function) at deprecated.jl:26",
          "sortperm(v::AbstractArray{T,1},f::Function,a::Algorithm) at deprecated.jl:26",
          "sortperm(f::Function,v::AbstractArray{T,1},a::Algorithm) at deprecated.jl:26",
          "sortperm(df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/sort.jl:294",
          "sortperm(df::AbstractDataFrame,a::Algorithm,o::Union(DFPerm{O<:Union(Ordering,AbstractArray{T,1}),DF<:AbstractDataFrame},Perm{O<:Ordering,V<:AbstractArray{T,1}})) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/sort.jl:312",
          "sortperm{V}(d::AbstractDataFrame,a::Algorithm,o::FastPerm{ForwardOrdering,V}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/sort.jl:316",
          "sortperm{V}(d::AbstractDataFrame,a::Algorithm,o::FastPerm{ReverseOrdering{Fwd<:Ordering},V}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/sort.jl:317",
          "sortperm(df::AbstractDataFrame,a::Algorithm,o::Ordering) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/sort.jl:313",
          "sortperm(df::AbstractDataFrame,o::Ordering) at deprecated.jl:26"
        ]
      },
      {
        "name": "stack",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "stack(df::DataFrame,measure_vars::Array{Int64,1},id_vars::Array{Int64,1}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:17",
          "stack(df::DataFrame,measure_vars,id_vars) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:23",
          "stack(df::DataFrame,measure_vars) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:24"
        ]
      },
      {
        "name": "stack_df",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "stack_df(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "stackdf",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "stackdf(df::AbstractDataFrame,measure_vars::Array{Int64,1},id_vars::Array{Int64,1}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:259",
          "stackdf(df::AbstractDataFrame,measure_vars) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:273",
          "stackdf(df::AbstractDataFrame,measure_vars,id_vars) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:272"
        ]
      },
      {
        "name": "stderr",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "stderr(::Union(DataFrameRegressionModel{M,T},DataFrameStatisticalModel{M,T}),...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:27",
          "stderr(obj::StatisticalModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:11"
        ]
      },
      {
        "name": "subset",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "subset(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "summarystats",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "summarystats{T<:Real}(a::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:333"
        ]
      },
      {
        "name": "tail",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "tail(dv::AbstractDataArray{T,1}) at /home/samuel/.julia/v0.3/DataArrays/src/datavector.jl:16",
          "tail(df::AbstractDataFrame,r::Int64) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:695",
          "tail(df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:696"
        ]
      },
      {
        "name": "tiedrank",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "tiedrank(x::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/ranking.jl:129"
        ]
      },
      {
        "name": "trimmean",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "trimmean(x::AbstractArray{T<:Real,N},p::FloatingPoint) at /home/samuel/.julia/v0.3/StatsBase/src/means.jl:28"
        ]
      },
      {
        "name": "types",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "types(adf::AbstractDataFrame) at deprecated.jl:26"
        ]
      },
      {
        "name": "unique",
        "summary": "Function",
        "help": "Base.unique(itr[, dim])\n\n   Returns an array containing only the unique elements of the\n   iterable \"itr\", in the order that the first of each set of\n   equivalent elements originally appears. If \"dim\" is specified,\n   returns unique regions of the array \"itr\" along \"dim\".\n",
        "methods": 
        [
          "unique{T}(da::DataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:1139",
          "unique{T}(x::PooledDataArray{T,R<:Integer,N}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:284",
          "unique(v::RepeatedVector{T}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:187",
          "unique(v::EachRepeatedVector{T}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:215",
          "unique{T}(A::AbstractArray{T,1},dim::Int64) at multidimensional.jl:491",
          "unique{T}(A::AbstractArray{T,2},dim::Int64) at multidimensional.jl:491",
          "unique{T}(A::AbstractArray{T,3},dim::Int64) at multidimensional.jl:491",
          "unique{T}(A::AbstractArray{T,4},dim::Int64) at multidimensional.jl:491",
          "unique{T,N}(A::AbstractArray{T,N},dim::Int64) at cartesian.jl:100",
          "unique(df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:926",
          "unique(C) at set.jl:99"
        ]
      },
      {
        "name": "unique!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "unique!(df::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:922"
        ]
      },
      {
        "name": "unstack",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "unstack(df::AbstractDataFrame,rowkey::Int64,colkey::Int64,value::Int64) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:39",
          "unstack(df::AbstractDataFrame,rowkey,value,colkey) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:62"
        ]
      },
      {
        "name": "variation",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "variation{T<:Real}(x::AbstractArray{T<:Real,N},m::Real) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:101",
          "variation{T<:Real}(x::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:102"
        ]
      },
      {
        "name": "vcov",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "vcov(::Union(DataFrameRegressionModel{M,T},DataFrameStatisticalModel{M,T}),...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:27",
          "vcov(obj::StatisticalModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:12"
        ]
      },
      {
        "name": "vecbind",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "vecbind(xs::PooledDataArray{T,R,1}...) at /home/samuel/.julia/v0.3/DataFrames/src/deprecated.jl:318",
          "vecbind(xs::AbstractArray{T,1}...) at /home/samuel/.julia/v0.3/DataFrames/src/deprecated.jl:304",
          "vecbind(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "weights",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "weights(vs::AbstractArray{T<:Real,1}) at /home/samuel/.julia/v0.3/StatsBase/src/common.jl:58",
          "weights(vs::AbstractArray{T<:Real,N}) at /home/samuel/.julia/v0.3/StatsBase/src/common.jl:59"
        ]
      },
      {
        "name": "wmean",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "wmean{T<:Number}(v::AbstractArray{T<:Number,N},w::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/StatsBase/src/means.jl:50"
        ]
      },
      {
        "name": "write_table",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "write_table(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "writetable",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "writetable(filename::String,df::DataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/io.jl:1039"
        ]
      },
      {
        "name": "wsample",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "wsample(w::AbstractArray{T<:Real,1}) at /home/samuel/.julia/v0.3/StatsBase/src/sampling.jl:239",
          "wsample(a::AbstractArray{T,N},w::AbstractArray{T<:Real,1}) at /home/samuel/.julia/v0.3/StatsBase/src/sampling.jl:240",
          "wsample{T}(a::AbstractArray{T,N},w::AbstractArray{T<:Real,1},n::Integer) at /home/samuel/.julia/v0.3/StatsBase/src/sampling.jl:245",
          "wsample{T}(a::AbstractArray{T,N},w::AbstractArray{T<:Real,1},dims::(Int64...,)) at /home/samuel/.julia/v0.3/StatsBase/src/sampling.jl:248"
        ]
      },
      {
        "name": "xlogx",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "xlogx(x::FloatingPoint) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:5",
          "xlogx(x::Real) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:6",
          "xlogx{T<:Real}(::AbstractArray{T<:Real,1}) at operators.jl:354",
          "xlogx{T<:Real}(::AbstractArray{T<:Real,2}) at operators.jl:355",
          "xlogx{T<:Real}(::AbstractArray{T<:Real,N}) at operators.jl:357"
        ]
      },
      {
        "name": "xlogy",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "xlogy{T<:FloatingPoint}(x::T<:FloatingPoint,y::T<:FloatingPoint) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:8",
          "xlogy{T<:Real}(x::T<:Real,y::T<:Real) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:9",
          "xlogy(x::Real,y::Real) at /home/samuel/.julia/v0.3/StatsBase/src/mathfuns.jl:10",
          "xlogy{T1<:Real,T2<:Real}(::T1<:Real,::AbstractArray{T2<:Real,N}) at operators.jl:365",
          "xlogy{T1<:Real,T2<:Real}(::AbstractArray{T1<:Real,N},::T2<:Real) at operators.jl:367",
          "xlogy{T1<:Real,T2<:Real}(::AbstractArray{T1<:Real,N},::AbstractArray{T2<:Real,N}) at operators.jl:371"
        ]
      },
      {
        "name": "xtab",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "xtabs",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "xtabs{T}(x::AbstractArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/statistics.jl:59"
        ]
      }
    ]
  },
  {
    "name": "PyCall",
    "items": 
    [
      {
        "name": "@pyimport",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PyAny",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PyArray",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PyArray_Info",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PyCall",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PyDict",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PyObject",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PyPtr",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PyTextIO",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "PyTextIO(io::IO) at /home/samuel/.julia/v0.3/PyCall/src/io.jl:388"
        ]
      },
      {
        "name": "PyVector",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "pybuiltin",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pybuiltin(name) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:757"
        ]
      },
      {
        "name": "pycall",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pycall(o::PyObject,returntype::Union(Type{T<:Top},NTuple{Type{T<:Top},T}),args...) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:773"
        ]
      },
      {
        "name": "pydecref",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pydecref(o::PyObject) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:94"
        ]
      },
      {
        "name": "pyerr_check",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pyerr_check(msg::String,val) at /home/samuel/.julia/v0.3/PyCall/src/exception.jl:57",
          "pyerr_check(msg::String) at /home/samuel/.julia/v0.3/PyCall/src/exception.jl:63",
          "pyerr_check() at /home/samuel/.julia/v0.3/PyCall/src/exception.jl:64"
        ]
      },
      {
        "name": "pyerr_clear",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pyerr_clear() at /home/samuel/.julia/v0.3/PyCall/src/exception.jl:52"
        ]
      },
      {
        "name": "pyeval",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pyeval(s::String) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:885",
          "pyeval(s::String,returntype::Union(Type{T<:Top},NTuple{Type{T<:Top},T})) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:885"
        ]
      },
      {
        "name": "pyfinalize",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pyfinalize() at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:457"
        ]
      },
      {
        "name": "pygui",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pygui() at /home/samuel/.julia/v0.3/PyCall/src/gui.jl:24",
          "pygui(g::Symbol) at /home/samuel/.julia/v0.3/PyCall/src/gui.jl:38"
        ]
      },
      {
        "name": "pygui_start",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pygui_start() at /home/samuel/.julia/v0.3/PyCall/src/gui.jl:118",
          "pygui_start(gui::Symbol) at /home/samuel/.julia/v0.3/PyCall/src/gui.jl:118",
          "pygui_start(gui::Symbol,sec::Real) at /home/samuel/.julia/v0.3/PyCall/src/gui.jl:118"
        ]
      },
      {
        "name": "pygui_stop",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pygui_stop() at /home/samuel/.julia/v0.3/PyCall/src/gui.jl:138",
          "pygui_stop(gui::Symbol) at /home/samuel/.julia/v0.3/PyCall/src/gui.jl:138"
        ]
      },
      {
        "name": "pygui_stop_all",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pygui_stop_all() at /home/samuel/.julia/v0.3/PyCall/src/gui.jl:146"
        ]
      },
      {
        "name": "pyhassym",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pyhassym(func::Symbol) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:48"
        ]
      },
      {
        "name": "pyimport",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pyimport(name::String) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:706",
          "pyimport(name::Symbol) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:710"
        ]
      },
      {
        "name": "pyincref",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pyincref(o::PyObject) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:102",
          "pyincref(o::Ptr{PyObject_struct}) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:110"
        ]
      },
      {
        "name": "pyinitialize",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pyinitialize(libpy::Ptr{None}) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:204",
          "pyinitialize(python::String) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:435",
          "pyinitialize() at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:452"
        ]
      },
      {
        "name": "pyisinstance",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pyisinstance(o::PyObject,t::PyObject) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:114",
          "pyisinstance(o::PyObject,t::Ptr{None}) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:117"
        ]
      },
      {
        "name": "pyraise",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pyraise(e::PyError) at /home/samuel/.julia/v0.3/PyCall/src/exception.jl:166",
          "pyraise(e) at /home/samuel/.julia/v0.3/PyCall/src/exception.jl:158"
        ]
      },
      {
        "name": "pystring",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pystring(o::PyObject) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:530"
        ]
      },
      {
        "name": "pysym",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pysym(func::Symbol) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:46"
        ]
      },
      {
        "name": "pytype_mapping",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pytype_mapping(py::PyObject,jl::Type{T<:Top}) at /home/samuel/.julia/v0.3/PyCall/src/conversions.jl:768"
        ]
      },
      {
        "name": "pytype_query",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pytype_query(o::PyObject,default::Type{T<:Top}) at /home/samuel/.julia/v0.3/PyCall/src/conversions.jl:779",
          "pytype_query(o::PyObject) at /home/samuel/.julia/v0.3/PyCall/src/conversions.jl:799"
        ]
      },
      {
        "name": "pytypeof",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pytypeof(o::PyObject) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:123"
        ]
      },
      {
        "name": "pyversion",
        "summary": "VersionNumber",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "pywrap",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "pywrap(o::PyObject) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:688",
          "pywrap(o::PyObject,mname::Symbol) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:688"
        ]
      },
      {
        "name": "set!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "set!(o::PyObject,k,v) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:829"
        ]
      }
    ]
  },
  {
    "name": "GeneticAlgorithms",
    "items": 
    [
      {
        "name": "Entity",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "GAmodel",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "GeneticAlgorithms",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "defrost",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "defrost(model::GAmodel,generation::Int64) at /home/samuel/.julia/v0.3/GeneticAlgorithms/src/GeneticAlgorithms.jl:70",
          "defrost(generation::Int64) at /home/samuel/.julia/v0.3/GeneticAlgorithms/src/GeneticAlgorithms.jl:75"
        ]
      },
      {
        "name": "freeze",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "freeze(model::GAmodel,entity::EntityData) at /home/samuel/.julia/v0.3/GeneticAlgorithms/src/GeneticAlgorithms.jl:57",
          "freeze(model::GAmodel,entity) at /home/samuel/.julia/v0.3/GeneticAlgorithms/src/GeneticAlgorithms.jl:62",
          "freeze(entity) at /home/samuel/.julia/v0.3/GeneticAlgorithms/src/GeneticAlgorithms.jl:66"
        ]
      },
      {
        "name": "generation_num",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "generation_num() at /home/samuel/.julia/v0.3/GeneticAlgorithms/src/GeneticAlgorithms.jl:78",
          "generation_num(model::GAmodel) at /home/samuel/.julia/v0.3/GeneticAlgorithms/src/GeneticAlgorithms.jl:78"
        ]
      },
      {
        "name": "population",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "population() at /home/samuel/.julia/v0.3/GeneticAlgorithms/src/GeneticAlgorithms.jl:81",
          "population(model::GAmodel) at /home/samuel/.julia/v0.3/GeneticAlgorithms/src/GeneticAlgorithms.jl:81"
        ]
      },
      {
        "name": "runga",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "runga(mdl::Module) at /home/samuel/.julia/v0.3/GeneticAlgorithms/src/GeneticAlgorithms.jl:85",
          "runga(model::GAmodel) at /home/samuel/.julia/v0.3/GeneticAlgorithms/src/GeneticAlgorithms.jl:93"
        ]
      }
    ]
  },
  {
    "name": "Optim",
    "items": 
    [
      {
        "name": "DifferentiableFunction",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Optim",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "TwiceDifferentiableFunction",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "cgdescent",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "cgdescent{T}(func::Function,x::Array{T,N},ops::Options{T<:OptionsChecking}) at /home/samuel/.julia/v0.3/Optim/src/cgdescent.jl:75",
          "cgdescent(func::Function,x) at /home/samuel/.julia/v0.3/Optim/src/cgdescent.jl:71"
        ]
      },
      {
        "name": "curve_fit",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "curve_fit(model::Function,xpts,ydata,p0) at /home/samuel/.julia/v0.3/Optim/src/curve_fit.jl:10"
        ]
      },
      {
        "name": "estimate_errors",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "estimate_errors(p,residuals,J) at /home/samuel/.julia/v0.3/Optim/src/curve_fit.jl:20",
          "estimate_errors(p,residuals,J,alpha) at /home/samuel/.julia/v0.3/Optim/src/curve_fit.jl:30"
        ]
      },
      {
        "name": "fminbox",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "fminbox{T}(func::Function,x::Array{T,N},l::Array{T,N},u::Array{T,N},ops::Options{T<:OptionsChecking}) at /home/samuel/.julia/v0.3/Optim/src/fminbox.jl:113",
          "fminbox{T}(func::Function,x::Array{T,N},l::Array{T,N},u::Array{T,N}) at /home/samuel/.julia/v0.3/Optim/src/fminbox.jl:190"
        ]
      },
      {
        "name": "nnls",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "nnls(A::AbstractArray{T,2},b::AbstractArray{T,1},ops::Options{T<:OptionsChecking}) at /home/samuel/.julia/v0.3/Optim/src/nnls.jl:3",
          "nnls(A::AbstractArray{T,2},b::AbstractArray{T,1}) at /home/samuel/.julia/v0.3/Optim/src/nnls.jl:17"
        ]
      },
      {
        "name": "optimize",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "optimize(d::TwiceDifferentiableFunction,initial_x::Array{T,1}) at /home/samuel/.julia/v0.3/Optim/src/optimize.jl:12",
          "optimize(d::DifferentiableFunction,initial_x::Array{T,1}) at /home/samuel/.julia/v0.3/Optim/src/optimize.jl:100",
          "optimize(f::Function,g!::Function,h!::Function,initial_x::Array{T,1}) at /home/samuel/.julia/v0.3/Optim/src/optimize.jl:179",
          "optimize(f::Function,g!::Function,initial_x::Array{T,1}) at /home/samuel/.julia/v0.3/Optim/src/optimize.jl:289",
          "optimize(f::Function,initial_x::Array{T,1}) at /home/samuel/.julia/v0.3/Optim/src/optimize.jl:387"
        ]
      }
    ]
  },
  {
    "name": "JuMP",
    "items": 
    [
      {
        "name": "@addConstraint",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@addLazyConstraint",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@addNLConstraint",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@addUserCut",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@defConstrRef",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@defVar",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@gendict",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@setNLObjective",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "@setObjective",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "AffExpr",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "CONTINUOUS",
        "summary": "Int64",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "ConstraintRef",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "INTEGER",
        "summary": "Int64",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "JuMP",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "LinearConstraint",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Model",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "QuadConstraint",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "QuadExpr",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Variable",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "addConstraint",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "addConstraint(m::Model,c::GenericRangeConstraint{GenericAffExpr{Float64,Variable}}) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:370",
          "addConstraint(m::Model,c::GenericQuadConstraint{GenericQuadExpr{Float64,Variable}}) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:460"
        ]
      },
      {
        "name": "addLazyConstraint",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "addLazyConstraint(cbdata::MathProgCallbackData,constr::GenericRangeConstraint{GenericAffExpr{Float64,Variable}}) at /home/samuel/.julia/v0.3/JuMP/src/callbacks.jl:87"
        ]
      },
      {
        "name": "addSOS1",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "addSOS1(m::Model,coll::Array{GenericAffExpr{Float64,Variable},1}) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:417",
          "addSOS1(m::Model,coll) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:414"
        ]
      },
      {
        "name": "addSOS2",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "addSOS2(m::Model,coll::Array{GenericAffExpr{Float64,Variable},1}) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:433",
          "addSOS2(m::Model,coll) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:430"
        ]
      },
      {
        "name": "addSolution",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "addSolution(cbdata::MathProgCallbackData) at /home/samuel/.julia/v0.3/JuMP/src/callbacks.jl:130"
        ]
      },
      {
        "name": "addToExpression",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "addToExpression(aff::GenericAffExpr{Float64,Variable},c::Number,x::Variable) at /home/samuel/.julia/v0.3/JuMP/src/macros.jl:24",
          "addToExpression(aff::GenericAffExpr{Float64,Variable},c::Number,x::Number) at /home/samuel/.julia/v0.3/JuMP/src/macros.jl:29",
          "addToExpression(aff::GenericAffExpr{Float64,Variable},c::Number,x::GenericAffExpr{Float64,Variable}) at /home/samuel/.julia/v0.3/JuMP/src/macros.jl:33",
          "addToExpression(aff,c,x) at /home/samuel/.julia/v0.3/JuMP/src/macros.jl:38"
        ]
      },
      {
        "name": "addUserCut",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "addUserCut(cbdata::MathProgCallbackData,constr::GenericRangeConstraint{GenericAffExpr{Float64,Variable}}) at /home/samuel/.julia/v0.3/JuMP/src/callbacks.jl:118"
        ]
      },
      {
        "name": "affToStr",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "affToStr(a::GenericAffExpr{Float64,Variable}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:321",
          "affToStr(a::GenericAffExpr{Float64,Variable},showConstant) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:321"
        ]
      },
      {
        "name": "chgConstrRHS",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "chgConstrRHS(c::ConstraintRef{GenericRangeConstraint{GenericAffExpr{Float64,Variable}}},rhs::Number) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:490"
        ]
      },
      {
        "name": "conToStr",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "conToStr(c::GenericRangeConstraint{TermsType}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:578",
          "conToStr(c::GenericQuadConstraint{GenericQuadExpr{Float64,Variable}}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:591",
          "conToStr(c::SOSConstraint) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:596"
        ]
      },
      {
        "name": "copy",
        "summary": "Function",
        "help": "Base.copy(x)\n\n   Create a shallow copy of \"x\": the outer structure is copied, but\n   not all internal values. For example, copying an array produces a\n   new array with identically-same elements as the original.\n",
        "methods": 
        [
          "copy(r::Range{T}) at range.jl:210",
          "copy(e::Expr) at expr.jl:30",
          "copy(s::SymbolNode) at expr.jl:34",
          "copy(n::GetfieldNode) at expr.jl:35",
          "copy(x::Union(DataType,(Any...,),LambdaStaticData,Symbol,String,Function,QuoteNode,Number,UnionType,TopNode)) at operators.jl:169",
          "copy(d::Union(DArray{T,N,A},SubArray{T,N,D<:DArray{T,N,A},I<:(Union(Range{Int64},Int64)...,)})) at darray.jl:248",
          "copy(s::SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Range{Int64},Int64)...,)}) at subarray.jl:188",
          "copy(S::SparseMatrixCSC{Tv,Ti<:Integer}) at sparse/sparsematrix.jl:127",
          "copy(M::SymTridiagonal{T}) at linalg/tridiag.jl:32",
          "copy(M::Tridiagonal{T}) at linalg/tridiag.jl:188",
          "copy(A::Symmetric{T}) at linalg/symmetric.jl:24",
          "copy(A::Hermitian{T}) at linalg/symmetric.jl:25",
          "copy(W::Woodbury{T}) at linalg/woodbury.jl:66",
          "iround(M::Bidiagonal{T}) at linalg/bidiag.jl:67",
          "copy(A::SymmetricRFP{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/rectfullpacked.jl:33",
          "copy(d::DataArray{T,N}) at /home/samuel/.julia/v0.3/DataArrays/src/dataarray.jl:134",
          "copy(pda::PooledDataArray{T,R<:Integer,N}) at /home/samuel/.julia/v0.3/DataArrays/src/pooleddataarray.jl:157",
          "copy{T,N}(a::PyArray{T,N}) at /home/samuel/.julia/v0.3/PyCall/src/numpy.jl:302",
          "copy(a::AbstractArray{None,N}) at abstractarray.jl:203",
          "copy(a::AbstractArray{T,N}) at abstractarray.jl:202",
          "copy(s::IntSet) at intset.jl:13",
          "copy(o::ObjectIdDict) at dict.jl:204",
          "copy(a::Associative{K,V}) at dict.jl:68",
          "copy(s::Set{T}) at set.jl:27",
          "copy(b::IOBuffer) at iobuffer.jl:18",
          "copy(r::Regex) at regex.jl:53",
          "copy(::DevNullStream) at process.jl:103",
          "copy(J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:15",
          "copy{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(B::CholmodDense{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/cholmod.jl:385",
          "copy{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:747",
          "copy{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:752",
          "copy{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(T::CholmodTriplet{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int32}) at linalg/cholmod.jl:757",
          "copy{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:747",
          "copy{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:752",
          "copy{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}(T::CholmodTriplet{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Int64}) at linalg/cholmod.jl:757",
          "copy{T,V<:Number}(ct::Accumulator{T,V<:Number}) at /home/samuel/.julia/v0.3/DataStructures/src/accumulator.jl:23",
          "copy{K,C}(cc::ClassifiedCollections{K,C}) at /home/samuel/.julia/v0.3/DataStructures/src/classifiedcollections.jl:23",
          "copy(s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:36",
          "copy(l::Nil{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:94",
          "copy(l::Cons{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:97",
          "copy{T}(l::ListNil{T}) at /home/samuel/.julia/v0.3/Compose/src/list.jl:9",
          "copy{T}(l::ListNode{T}) at /home/samuel/.julia/v0.3/Compose/src/list.jl:18",
          "copy{S,T}(a::Measure{S,T}) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:116",
          "copy(point::Point) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:367",
          "copy(box::BoundingBox) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:423",
          "copy(rot::Rotation) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:558",
          "copy(p::EmptyProperty) at /home/samuel/.julia/v0.3/Compose/src/property.jl:44",
          "copy(ps::PropertySeq) at /home/samuel/.julia/v0.3/Compose/src/property.jl:68",
          "copy(a::FormTree) at /home/samuel/.julia/v0.3/Compose/src/form.jl:69",
          "copy(c::CanvasTree) at /home/samuel/.julia/v0.3/Compose/src/canvas.jl:117",
          "copy(ctx::CairoContext) at /home/samuel/.julia/v0.3/Cairo/src/Cairo.jl:355",
          "copy(df::DataForm{T<:FormPrimitive}) at /home/samuel/.julia/v0.3/Compose/src/dataform.jl:55",
          "copy(x::Index) at /home/samuel/.julia/v0.3/DataFrames/src/other/index.jl:26",
          "copy(df::DataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:681",
          "copy(a::Theme) at /home/samuel/.julia/v0.3/Gadfly/src/varset.jl:67",
          "copy(a::Aesthetics) at /home/samuel/.julia/v0.3/Gadfly/src/aesthetics.jl:165",
          "copy(a::Data) at /home/samuel/.julia/v0.3/Gadfly/src/varset.jl:67",
          "copy{T<:OptionsChecking}(o::Options{T<:OptionsChecking}) at /home/samuel/.julia/v0.3/Options/src/Options.jl:72",
          "copy(source::Model) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:137",
          "copy(a::GenericAffExpr{Float64,Variable},new_model::Model) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:268",
          "copy(q::GenericQuadExpr{Float64,Variable},new_model::Model) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:309",
          "copy(c::GenericRangeConstraint{GenericAffExpr{Float64,Variable}},new_model::Model) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:385",
          "copy(c::GenericQuadConstraint{GenericQuadExpr{Float64,Variable}},new_model::Model) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:471",
          "copy(::NLPData) at /home/samuel/.julia/v0.3/JuMP/src/nlp.jl:11"
        ]
      },
      {
        "name": "getDual",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "getDual(x::JuMPDict{T}) at /home/samuel/.julia/v0.3/JuMP/src/JuMPDict.jl:90",
          "getDual(v::Variable) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:233",
          "getDual(c::ConstraintRef{GenericRangeConstraint{GenericAffExpr{Float64,Variable}}}) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:483"
        ]
      },
      {
        "name": "getInternalModel",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "getInternalModel(m::Model) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:169"
        ]
      },
      {
        "name": "getLower",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "getLower(x::JuMPDict{T}) at /home/samuel/.julia/v0.3/JuMP/src/JuMPDict.jl:90",
          "getLower(v::Variable) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:214"
        ]
      },
      {
        "name": "getName",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "getName(v::Variable) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:199",
          "getName(m::Model,col) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:207"
        ]
      },
      {
        "name": "getNumConstraints",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "getNumConstraints(m::Model) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:124"
        ]
      },
      {
        "name": "getNumVars",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "getNumVars(m::Model) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:123"
        ]
      },
      {
        "name": "getObjectiveSense",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "getObjectiveSense(m::Model) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:126"
        ]
      },
      {
        "name": "getObjectiveValue",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "getObjectiveValue(m::Model) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:125"
        ]
      },
      {
        "name": "getUpper",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "getUpper(x::JuMPDict{T}) at /home/samuel/.julia/v0.3/JuMP/src/JuMPDict.jl:90",
          "getUpper(v::Variable) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:215"
        ]
      },
      {
        "name": "getValue",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "getValue(x::JuMPDict{T}) at /home/samuel/.julia/v0.3/JuMP/src/JuMPDict.jl:90",
          "getValue(v::Variable) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:223",
          "getValue(arr::Array{Variable,N}) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:229",
          "getValue(a::GenericAffExpr{Float64,Variable}) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:285",
          "getValue(q::GenericQuadExpr{Float64,Variable}) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:317"
        ]
      },
      {
        "name": "print",
        "summary": "Function",
        "help": "Base.print(x)\n\n   Write (to the default output stream) a canonical (un-decorated)\n   text representation of a value if there is one, otherwise call\n   \"show\". The representation used by \"print\" includes minimal\n   formatting and tries to avoid Julia-specific details.\n\nBase.Profile.print([io::IO = STDOUT], [data::Vector]; format = :tree, C = false, combine = true, cols = tty_cols())\n\n   Prints profiling results to \"io\" (by default, \"STDOUT\"). If you\n   do not supply a \"data\" vector, the internal buffer of accumulated\n   backtraces will be used.  \"format\" can be \":tree\" or \":flat\".\n   If \"C==true\", backtraces from C and Fortran code are shown.\n   \"combine==true\" merges instruction pointers that correspond to\n   the same line of code.  \"cols\" controls the width of the display.\n\nBase.Profile.print([io::IO = STDOUT], data::Vector, lidict::Dict; format = :tree, combine = true, cols = tty_cols())\n\n   Prints profiling results to \"io\". This variant is used to examine\n   results exported by a previous call to \"Profile.retrieve()\".\n   Supply the vector \"data\" of backtraces and a dictionary\n   \"lidict\" of line information.\n",
        "methods": 
        [
          "print(io::IO,c::Char) at char.jl:52",
          "print(io::IO,s::ASCIIString) at ascii.jl:93",
          "print(io::IO,s::UTF8String) at utf8.jl:156",
          "print(io::IOBuffer,s::SubString{T<:String}) at string.jl:622",
          "print(io::IO,s::RopeString) at string.jl:789",
          "print(io::IO,s::String) at string.jl:67",
          "print(io::IO,s::Symbol) at show.jl:4",
          "print(io::IO,n::Unsigned) at show.jl:183",
          "print(io::IO,ex::Union(Expr,LabelNode,QuoteNode,GotoNode,SymbolNode,LineNumberNode,TopNode)) at show.jl:211",
          "print(io::IO,ip::IPv4) at socket.jl:30",
          "print(io::IO,ip::IPv6) at socket.jl:85",
          "print{mime}(io::IO,::MIME{mime}) at multimedia.jl:17",
          "print(io::IO,x::Float32) at grisu.jl:118",
          "print(io::IO,x::Float16) at grisu.jl:119",
          "print(io::IO,b::BigFloat) at mpfr.jl:712",
          "print(io::IO,v::VersionNumber) at version.jl:42",
          "print(io::IO,uri::URI) at /home/samuel/.julia/v0.3/URIParser/src/parser.jl:299",
          "print(io::IO,adf::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/show.jl:637",
          "print(io::IO,x::TimeType) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:262",
          "print(io::IO,x::Period) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:515",
          "print(io::IO,m::Model) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:56",
          "print(io::IO,v::Variable) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:312",
          "print(io::IO,a::GenericAffExpr{CoefType,VarType}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:317",
          "print(io::IO,q::GenericQuadExpr{CoefType,VarType}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:404",
          "print(io::IO,dict::JuMPDict{Variable}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:480",
          "print(io::IO,dict::JuMPDict{Float64}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:521",
          "print(io::IO,c::GenericRangeConstraint{TermsType}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:574",
          "print(io::IO,c::GenericQuadConstraint{GenericQuadExpr{Float64,Variable}}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:588",
          "print(io::IO,c::SOSConstraint) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:613",
          "print(io::IO,c::ConstraintRef{GenericRangeConstraint{GenericAffExpr{Float64,Variable}}}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:620",
          "print(io::IO,c::ConstraintRef{GenericQuadConstraint{GenericQuadExpr{Float64,Variable}}}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:621",
          "print(io::IO,c::ConstraintRef{SOSConstraint}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:622",
          "print(io::IO,x) at string.jl:3",
          "print(io::IO,xs...) at string.jl:4",
          "print(xs...) at string.jl:7"
        ]
      },
      {
        "name": "quadToStr",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "quadToStr(q::GenericQuadExpr{Float64,Variable}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:408"
        ]
      },
      {
        "name": "setCutCallback",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setCutCallback(m::Model,f::Function) at /home/samuel/.julia/v0.3/JuMP/src/callbacks.jl:5"
        ]
      },
      {
        "name": "setHeuristicCallback",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setHeuristicCallback(m::Model,f::Function) at /home/samuel/.julia/v0.3/JuMP/src/callbacks.jl:6"
        ]
      },
      {
        "name": "setLazyCallback",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setLazyCallback(m::Model,f::Function) at /home/samuel/.julia/v0.3/JuMP/src/callbacks.jl:4"
        ]
      },
      {
        "name": "setLower",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setLower(v::Variable,lower::Number) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:212"
        ]
      },
      {
        "name": "setName",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setName(v::Variable,n::String) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:196"
        ]
      },
      {
        "name": "setObjective",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setObjective(m::Model,sense::Symbol,a::GenericAffExpr{Float64,Variable}) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:261",
          "setObjective(m::Model,sense::Symbol,q::GenericQuadExpr{Float64,Variable}) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:303"
        ]
      },
      {
        "name": "setObjectiveSense",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setObjectiveSense(m::Model,newSense::Symbol) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:128"
        ]
      },
      {
        "name": "setSolutionValue!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setSolutionValue!(cbdata::MathProgCallbackData,v::Variable,x) at /home/samuel/.julia/v0.3/JuMP/src/callbacks.jl:132"
        ]
      },
      {
        "name": "setUpper",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setUpper(v::Variable,upper::Number) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:213"
        ]
      },
      {
        "name": "setValue",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setValue(v::Variable,val::Number) at /home/samuel/.julia/v0.3/JuMP/src/JuMP.jl:219"
        ]
      },
      {
        "name": "setlazycallback",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setlazycallback(...) at deprecated.jl:8"
        ]
      },
      {
        "name": "show",
        "summary": "Function",
        "help": "Base.show(x)\n\n   Write an informative text representation of a value to the current\n   output stream. New types should overload \"show(io, x)\" where the\n   first argument is a stream. The representation used by \"show\"\n   generally includes Julia-specific formatting and type information.\n",
        "methods": 
        [
          "show(io::IO,r::UnitRange{T<:Real}) at range.jl:274",
          "show{T}(io::IO,r::CalendarTimeRange{T}) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:380",
          "show(io::IO,r::Union(DateRange1{C<:Calendar},DateRange{C<:Calendar})) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:395",
          "show{C<:Calendar}(io::IO,r::DateTimeRange{C<:Calendar,T<:Offsets}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:458",
          "show(io::IO,r::PeriodRange{P<:Period}) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:584",
          "show(io::IO,r::Range{T}) at range.jl:272",
          "show(io::IO,tv::TypeVar) at expr.jl:46",
          "show(io::IO,z::Complex{T<:Real}) at complex.jl:80",
          "show(io::IO,x::Rational{T<:Integer}) at rational.jl:31",
          "show(io::IO,s::IntSet) at intset.jl:170",
          "show(io::IO,::EnvHash) at env.jl:141",
          "show{K,V}(io::IO,t::Associative{K,V}) at dict.jl:15",
          "show(io::IO,s::Set{T}) at set.jl:10",
          "show(io::IO,c::Char) at char.jl:53",
          "show(io::IO,s::String) at string.jl:69",
          "show(io::IO,re::Regex) at regex.jl:56",
          "show(io::IO,m::RegexMatch) at regex.jl:84",
          "show(io::IO,t::Task) at task.jl:3",
          "show(io::IO,s::IOStream) at io.jl:263",
          "show(io::IO,f::Function) at show.jl:35",
          "show(io::IO,x::IntrinsicFunction) at show.jl:45",
          "show(io::IO,x::UnionType) at show.jl:49",
          "show(io::IO,x::TypeConstructor) at show.jl:58",
          "show(io::IO,x::DataType) at show.jl:61",
          "show(io::IO,tn::TypeName) at show.jl:178",
          "show(io::IO,::Nothing) at show.jl:179",
          "show(io::IO,b::Bool) at show.jl:180",
          "show(io::IO,n::Signed) at show.jl:181",
          "show(io::IO,n::Unsigned) at show.jl:182",
          "show{T}(io::IO,p::Ptr{T}) at show.jl:94",
          "show(io::IO,m::Module) at show.jl:98",
          "show(io::IO,l::LambdaStaticData) at show.jl:106",
          "show(io::IO,t::(Any...,)) at show.jl:175",
          "show(io::IO,s::Symbol) at show.jl:177",
          "show(io::IO,ex::Union(Expr,LabelNode,QuoteNode,GotoNode,SymbolNode,LineNumberNode,TopNode)) at show.jl:212",
          "show(io::IO,W::Woodbury{T}) at linalg/woodbury.jl:42",
          "show(io::IO,M::Bidiagonal{T}) at linalg/bidiag.jl:55",
          "show(io::IO,v::StackedVector) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:162",
          "show(io::IO,v::RepeatedVector{T}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:184",
          "show(io::IO,v::EachRepeatedVector{T}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/reshape.jl:212",
          "show(io::IO,v::AbstractArray{Any,1}) at show.jl:1079",
          "show(io::IO,v::AbstractArray{T,1}) at show.jl:1080",
          "show(io::IO,X::AbstractArray{T,N}) at show.jl:1015",
          "show(io::IO,stream::Pipe) at stream.jl:166",
          "show(io::IO,stream::PipeServer) at stream.jl:168",
          "show(io::IO,stream::TTY) at stream.jl:210",
          "show(io::IO,e::UVError) at stream.jl:814",
          "show(io::IO,ip::IPv4) at socket.jl:29",
          "show(io::IO,ip::IPv6) at socket.jl:81",
          "show(io::IO,sock::TcpSocket) at socket.jl:324",
          "show(io::IO,sock::TcpServer) at socket.jl:327",
          "show(io::IO,st::StatStruct) at stat.jl:31",
          "show(io::IO,cmd::Cmd) at process.jl:33",
          "show(io::IO,cmds::OrCmds) at process.jl:51",
          "show(io::IO,cmds::AndCmds) at process.jl:69",
          "show(io::IO,cr::CmdRedirect) at process.jl:123",
          "show(io::IO,p::Process) at process.jl:614",
          "show{mime}(io::IO,::MIME{mime}) at multimedia.jl:16",
          "show(io::IO,x::Float64) at grisu.jl:114",
          "show(io::IO,x::Float32) at grisu.jl:115",
          "show(io::IO,x::Float16) at grisu.jl:116",
          "show(io::IO,m::Method) at methodshow.jl:35",
          "show(io::IO,mt::MethodTable) at methodshow.jl:74",
          "show(io::IO,cman::LocalManager) at multi.jl:1109",
          "show(io::IO,cman::SSHManager) at multi.jl:1144",
          "show(io::IO,x::BigInt) at gmp.jl:416",
          "show(io::IO,b::BigFloat) at mpfr.jl:713",
          "show(io::IO,u::UUID) at random.jl:279",
          "show(io::IO,v::VersionNumber) at version.jl:57",
          "show(io::IO,x::Prompt) at LineEdit.jl:45",
          "show(io::IO,C::Cholesky{T}) at linalg/factorization.jl:83",
          "show(io::IO,J::UniformScaling{T<:Number}) at linalg/uniformscaling.jl:14",
          "show(io::IO,f::UmfpackLU{Tv<:Union(Float64,Complex{Float64}),Ti<:Union(Int64,Int32)}) at linalg/umfpack.jl:134",
          "show(io::IO,cd::CholmodDense{T<:Union(Float64,Complex{Float64},Float32,Complex{Float32})}) at linalg/cholmod.jl:382",
          "show(io::IO,L::CholmodFactor{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:914",
          "show(io::IO,A::CholmodSparse{Tv<:Union(Float64,Complex{Float64},Float32,Complex{Float32}),Ti<:Union(Int64,Int32)}) at linalg/cholmod.jl:915",
          "show(io::IO,info::CPUinfo) at sysinfo.jl:58",
          "show(io::IO,info::CPUinfo,header::Bool) at sysinfo.jl:58",
          "show(io::IO,info::CPUinfo,header::Bool,prefix::String) at sysinfo.jl:58",
          "show{sym}(io::IO,x::MathConst{sym}) at constants.jl:5",
          "show(io::IO,i::VersionInterval) at pkg/types.jl:13",
          "show(io::IO,s::VersionSet) at pkg/types.jl:36",
          "show(io::IO,a::Available) at pkg/types.jl:69",
          "show(io::IO,f::Fixed) at pkg/types.jl:81",
          "show(io::IO,blk::DequeBlock{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:46",
          "show(io::IO,q::Deque{T}) at /home/samuel/.julia/v0.3/DataStructures/src/deque.jl:143",
          "show(io::IO,h::MutableBinaryHeap{VT,Comp}) at /home/samuel/.julia/v0.3/DataStructures/src/heaps/mutable_binary_heap.jl:177",
          "show(io::IO,s::OrderedSet{T}) at /home/samuel/.julia/v0.3/DataStructures/src/orderedset.jl:18",
          "show{T}(io::IO,l::LinkedList{T}) at /home/samuel/.julia/v0.3/DataStructures/src/list.jl:20",
          "show(io::IO,t::CalendarTime) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:207",
          "show(io::IO,d::CalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:270",
          "show(io::IO,d::FixedCalendarDuration) at /home/samuel/.julia/v0.3/Calendar/src/Calendar.jl:293",
          "show(io::IO,r::Response) at /home/samuel/.julia/v0.3/HttpCommon/src/HttpCommon.jl:190",
          "show(io::IO,p::Parser) at /home/samuel/.julia/v0.3/HttpParser/src/HttpParser.jl:81",
          "show(io::IO,r::Request) at /home/samuel/.julia/v0.3/HttpParser/src/HttpParser.jl:86",
          "show(io::IO,err::HttpParserError) at /home/samuel/.julia/v0.3/HttpParser/src/HttpParser.jl:134",
          "show(io::IO,uri::URI) at /home/samuel/.julia/v0.3/URIParser/src/parser.jl:296",
          "show(io::IO,dep::LibraryDependency) at /home/samuel/.julia/v0.3/BinDeps/src/dependencies.jl:30",
          "show(io::IO,x::PackageManager) at /home/samuel/.julia/v0.3/BinDeps/src/show.jl:6",
          "show(io::IO,x::SimpleBuild) at /home/samuel/.julia/v0.3/BinDeps/src/show.jl:7",
          "show(io::IO,x::Sources) at /home/samuel/.julia/v0.3/BinDeps/src/show.jl:8",
          "show(io::IO,x::Binaries) at /home/samuel/.julia/v0.3/BinDeps/src/show.jl:9",
          "show(io::IO,x::Autotools) at /home/samuel/.julia/v0.3/BinDeps/src/show.jl:10",
          "show(io::IO,err::GnuTLSException) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:45",
          "show(io::IO,c::Certificate) at /home/samuel/.julia/v0.3/GnuTLS/src/GnuTLS.jl:257",
          "show{T}(io::IO,a::List{T}) at /home/samuel/.julia/v0.3/Compose/src/list.jl:82",
          "show{S,T}(io::IO,a::Measure{S,T}) at /home/samuel/.julia/v0.3/Compose/src/measure.jl:121",
          "show(io::IO,c::CanvasTree) at /home/samuel/.julia/v0.3/Compose/src/canvas.jl:160",
          "show(io::IO,ss::SummaryStats{T<:FloatingPoint}) at /home/samuel/.julia/v0.3/StatsBase/src/scalarstats.jl:346",
          "show(io::IO,h::Histogram{T<:Real,N,E}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:95",
          "show(io::IO,ct::CoefTable) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:49",
          "show(io::IO,x::NAtype) at /home/samuel/.julia/v0.3/DataArrays/src/natype.jl:22",
          "show(io::IO,s::GZipStream) at /home/samuel/.julia/v0.3/GZip/src/GZip.jl:115",
          "show(io::IO,adf::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/show.jl:439",
          "show(io::IO,adf::AbstractDataFrame,splitchunks::Bool) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/show.jl:439",
          "show(io::IO,adf::AbstractDataFrame,splitchunks::Bool,rowlabel::Symbol) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/show.jl:439",
          "show(io::IO,adf::AbstractDataFrame,splitchunks::Bool,rowlabel::Symbol,displaysummary::Bool) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/show.jl:439",
          "show(io::IO,r::DataFrameRow{T<:AbstractDataFrame}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/show.jl:507",
          "show(io::IO,gd::GroupedDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/groupeddataframe/grouping.jl:74",
          "show(io::IO,f::Formula) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/formula.jl:51",
          "show(io::IO,model::Union(DataFrameRegressionModel{M,T},DataFrameStatisticalModel{M,T})) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:80",
          "show(io::IO,x::TimeType) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:263",
          "show(io::IO,x::Period) at /home/samuel/.julia/v0.3/Datetime/src/Datetime.jl:516",
          "show(io::IO,table::DiscreteDistributionTable) at /home/samuel/.julia/v0.3/Distributions/src/samplers/drawtable.jl:82",
          "show(io::IO,a::AliasTable) at /home/samuel/.julia/v0.3/Distributions/src/samplers/alias.jl:51",
          "show{T}(io::IO,t::HuffmanNode{T}) at /home/samuel/.julia/v0.3/Distributions/src/samplers/huffman.jl:25",
          "show(io::IO,d::Distribution{Univariate,S<:ValueSupport}) at /home/samuel/.julia/v0.3/Distributions/src/show.jl:45",
          "show(io::IO,d::Distribution{F<:VariateForm,S<:ValueSupport}) at /home/samuel/.julia/v0.3/Distributions/src/show.jl:2",
          "show(io::IO,e::PyError) at /home/samuel/.julia/v0.3/PyCall/src/exception.jl:28",
          "show(io::IO,o::PyObject) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:547",
          "show(io::IO,m::PyObjectMembers) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:661",
          "show{T<:OptionsChecking}(io::IO,o::Options{T<:OptionsChecking}) at /home/samuel/.julia/v0.3/Options/src/Options.jl:82",
          "show(io::IO,x::BasicVariable) at /home/samuel/.julia/v0.3/Calculus/src/symbolic.jl:31",
          "show(io::IO,t::OptimizationState) at /home/samuel/.julia/v0.3/Optim/src/types.jl:56",
          "show(io::IO,t::OptimizationTrace) at /home/samuel/.julia/v0.3/Optim/src/types.jl:76",
          "show(io::IO,r::MultivariateOptimizationResults{T}) at /home/samuel/.julia/v0.3/Optim/src/types.jl:89",
          "show(io::IO,z::Dual{T<:Real}) at /home/samuel/.julia/v0.3/DualNumbers/src/dual.jl:80",
          "show(io::IO,x::ExprNode) at /home/samuel/.julia/v0.3/ReverseDiffSparse/src/types.jl:35",
          "show(io::IO,v::ExVertex) at /home/samuel/.julia/v0.3/Graphs/src/show.jl:4",
          "show(io::IO,e::Union(ExEdge{V},Edge{V})) at /home/samuel/.julia/v0.3/Graphs/src/show.jl:12",
          "show(io::IO,graph::AbstractGraph{V,E}) at /home/samuel/.julia/v0.3/Graphs/src/show.jl:16",
          "show(io::IO,m::Model) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:138",
          "show(io::IO,v::Variable) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:311",
          "show(io::IO,a::GenericAffExpr{CoefType,VarType}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:318",
          "show(io::IO,q::GenericQuadExpr{CoefType,VarType}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:405",
          "show(io::IO,dict::JuMPDict{Variable}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:477",
          "show(io::IO,dict::JuMPDict{Float64}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:519",
          "show(io::IO,c::GenericRangeConstraint{TermsType}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:575",
          "show(io::IO,c::GenericQuadConstraint{GenericQuadExpr{Float64,Variable}}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:589",
          "show(io::IO,c::SOSConstraint) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:614",
          "show{T}(io::IO,c::ConstraintRef{T}) at /home/samuel/.julia/v0.3/JuMP/src/print.jl:623",
          "show(io::IO,x::ANY) at show.jl:7",
          "show(adf::AbstractDataFrame) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/show.jl:486",
          "show(adf::AbstractDataFrame,splitchunks::Bool) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/show.jl:486",
          "show(row::DataFrameRow{T<:AbstractDataFrame}) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/show.jl:530",
          "show(x) at show.jl:2"
        ]
      },
      {
        "name": "solve",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "solve(m::Model) at /home/samuel/.julia/v0.3/JuMP/src/solvers.jl:2"
        ]
      },
      {
        "name": "writeLP",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "writeLP(m::Model,fname::String) at /home/samuel/.julia/v0.3/JuMP/src/writers.jl:177"
        ]
      },
      {
        "name": "writeMPS",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "writeMPS(m::Model,fname::String) at /home/samuel/.julia/v0.3/JuMP/src/writers.jl:2"
        ]
      }
    ]
  },
  {
    "name": "Morsel",
    "items": 
    [
      {
        "name": "App",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DELETE",
        "summary": "Int64",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "GET",
        "summary": "Int64",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "HEAD",
        "summary": "Int64",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Morsel",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "OPTIONS",
        "summary": "Int64",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "POST",
        "summary": "Int64",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PUT",
        "summary": "Int64",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "UPDATE",
        "summary": "Int64",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "app",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "app() at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:52"
        ]
      },
      {
        "name": "delete",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "delete(h::Function,a::App,p::String) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:120"
        ]
      },
      {
        "name": "get",
        "summary": "Function",
        "help": "Base.get(collection, key, default)\n\n   Return the value stored for the given key, or the given default\n   value if no mapping for the key is present.\n\nBase.get(f::Function, collection, key)\n\n   Return the value stored for the given key, or if no mapping for the\n   key is present, return \"f()\".  Use \"get!\" to also store the\n   default value in the dictionary.\n\n   This is intended to be called using \"do\" block syntax:\n\n      get(dict, key) do\n          # default value calculated here\n          time()\n      end\n",
        "methods": 
        [
          "get(A::AbstractArray{T,N},i::Integer,default) at abstractarray.jl:464",
          "get(A::AbstractArray{T,N},I::(),default) at abstractarray.jl:465",
          "get(A::AbstractArray{T,N},I::(Int64...,),default) at abstractarray.jl:466",
          "get(A::AbstractArray{T,N},I::Range{T},default) at abstractarray.jl:476",
          "get(A::Array{T,N},B::Array{T,N},I,default) at deprecated.jl:26",
          "get(A::AbstractArray{T,N},I::Union(AbstractArray{Range{Int64},1},AbstractArray{UnitRange{Int64},1},AbstractArray{A<:AbstractArray{Int64,1},1},(Union(Range{T},AbstractArray{Int64,1})...,)),default) at abstractarray.jl:485",
          "get(t::ObjectIdDict,key::ANY,default::ANY) at dict.jl:172",
          "get{K,V}(h::Dict{K,V},key,deflt) at dict.jl:518",
          "get{K,V}(deflt::Function,h::Dict{K,V},key) at dict.jl:523",
          "get{K}(wkh::WeakKeyDict{K,V},key,def) at dict.jl:637",
          "get{K}(def::Function,wkh::WeakKeyDict{K,V},key) at dict.jl:638",
          "get(::EnvHash,k::String,def) at env.jl:76",
          "get{K,V}(pq::PriorityQueue{K,V},key,deflt) at collections.jl:213",
          "get{K,V}(h::HashDict{K,V,O<:Union(Nothing,Int64)},key,deflt) at /home/samuel/.julia/v0.3/DataStructures/src/hashdict.jl:416",
          "get(::OrderedDict{K,V},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "get(::DefaultDictBase{K,V,F,D<:Associative{K,V}},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "get(::DefaultDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "get(::DefaultOrderedDict{K,V,F},...) at /home/samuel/.julia/v0.3/DataStructures/src/delegate.jl:11",
          "get(t::Trie{T},key::String,notfound) at /home/samuel/.julia/v0.3/DataStructures/src/trie.jl:54",
          "get(uri::URI,data::String) at /home/samuel/.julia/v0.3/Requests/src/Requests.jl:570",
          "get(uri::String) at /home/samuel/.julia/v0.3/Requests/src/Requests.jl:575",
          "get(uri::URI) at /home/samuel/.julia/v0.3/Requests/src/Requests.jl:576",
          "get(df::AbstractDataFrame,key,default) at /home/samuel/.julia/v0.3/DataFrames/src/dataframe/dataframe.jl:649",
          "get{K,V}(d::PyDict{K,V},k,default) at /home/samuel/.julia/v0.3/PyCall/src/conversions.jl:464",
          "get(o::PyObject,returntype::Union(Type{T<:Top},NTuple{Type{T<:Top},T}),k,default) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:804",
          "get(o::PyObject,returntype::Union(Type{T<:Top},NTuple{Type{T<:Top},T}),k) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:813",
          "get(o::PyObject,k,default) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:817",
          "get(o::PyObject,k) at /home/samuel/.julia/v0.3/PyCall/src/PyCall.jl:818",
          "get{T,V}(::_GenUnit{T},g::AbstractGraph{V,E},u::V,v::V) at /home/samuel/.julia/v0.3/Graphs/src/gmatrix.jl:238",
          "get{V,E}(gen::_GenEdgeWeight{Weights},g::AbstractGraph{V,E},e::E) at /home/samuel/.julia/v0.3/Graphs/src/gmatrix.jl:255",
          "get(h::Function,a::App,p::String) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:116"
        ]
      },
      {
        "name": "match_route_handler",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "match_route_handler(table::Tree,parts::Array{T,N}) at /home/samuel/.julia/v0.3/Morsel/src/Routes.jl:183"
        ]
      },
      {
        "name": "namespace",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "namespace(thunk::Function,app::App,prefix::String) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:88",
          "namespace(thunk::Function,app::App,prefix::String,mid::Union(Midware,Array{Midware,1})...) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:95"
        ]
      },
      {
        "name": "param",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "param(req::MeddleRequest,key::String) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:150",
          "param(req::MeddleRequest,key::String,validator::Function) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:150",
          "param(req::MeddleRequest,key::Symbol) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:160",
          "param(req::MeddleRequest,key::Symbol,validator::Function) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:160"
        ]
      },
      {
        "name": "post",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "post(h::Function,a::App,p::String) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:117"
        ]
      },
      {
        "name": "put",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "put(h::Function,a::App,p::String) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:118"
        ]
      },
      {
        "name": "route",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "route(handler::Function,app::App,methods::Int64,path::String) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:73",
          "route(a::App,m::Int64,p::String,h::Function) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:85"
        ]
      },
      {
        "name": "routeparam",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "routeparam(req::MeddleRequest,key::String) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:147",
          "routeparam(req::MeddleRequest,key::String,validator::Function) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:147",
          "routeparam(req::MeddleRequest,key::Symbol) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:157",
          "routeparam(req::MeddleRequest,key::Symbol,validator::Function) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:157"
        ]
      },
      {
        "name": "start",
        "summary": "Function",
        "help": "Base.start(iter) -> state\n\n   Get initial iteration state for an iterable object\n",
        "methods": 
        [
          "start(app::App,port::Int64) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:189"
        ]
      },
      {
        "name": "unsafestring",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "unsafestring(input::String) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:139"
        ]
      },
      {
        "name": "update",
        "summary": "Function",
        "help": "Base.Pkg.update()\n\n   Update package the metadata repo – kept in\n   \"Pkg.dir(\"METADATA\")\" – then update any fixed packages that can\n   safely be pulled from their origin; then call \"Pkg.resolve()\" to\n   determine a new optimal set of packages versions.\n",
        "methods": 
        [
          "update(h::Function,a::App,p::String) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:119"
        ]
      },
      {
        "name": "urlparam",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "urlparam(req::MeddleRequest,key::String) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:144",
          "urlparam(req::MeddleRequest,key::String,validator::Function) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:144",
          "urlparam(req::MeddleRequest,key::Symbol) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:154",
          "urlparam(req::MeddleRequest,key::Symbol,validator::Function) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:154"
        ]
      },
      {
        "name": "with",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "with(thunk::Function,app::App,stack::Array{Midware,1}) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:98",
          "with(thunk::Function,app::App,mid::Midware...) at /home/samuel/.julia/v0.3/Morsel/src/Morsel.jl:109"
        ]
      }
    ]
  },
  {
    "name": "GLM",
    "items": 
    [
      {
        "name": "CauchitLink",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "CloglogLink",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DensePred",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DensePredChol",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "DensePredQR",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "GLM",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "GeneralizedLinearModel",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "GlmMod",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "GlmResp",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "IdentityLink",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "InverseLink",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "LinPred",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "LinPredModel",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "LinearModel",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Link",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "LmMod",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "LmResp",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "LogLink",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "LogitLink",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "ProbitLink",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SqrtLink",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "canonicallink",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "canonicallink(::Gamma) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:61",
          "canonicallink(::Normal) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:62",
          "canonicallink(::Binomial) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:63",
          "canonicallink(::Poisson) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:64"
        ]
      },
      {
        "name": "delbeta!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "delbeta!{T<:Union(Float64,Float32)}(p::DensePredQR{T<:Union(Float64,Float32)},r::Array{T<:Union(Float64,Float32),1}) at /home/samuel/.julia/v0.3/GLM/src/linpred.jl:29",
          "delbeta!{T<:Union(Float64,Float32)}(p::DensePredChol{T<:Union(Float64,Float32)},r::Array{T<:Union(Float64,Float32),1}) at /home/samuel/.julia/v0.3/GLM/src/linpred.jl:48",
          "delbeta!{T<:Union(Float64,Float32)}(p::DensePredChol{T<:Union(Float64,Float32)},r::Array{T<:Union(Float64,Float32),1},wt::Array{T<:Union(Float64,Float32),1},scr::Array{T<:Union(Float64,Float32),2}) at /home/samuel/.julia/v0.3/GLM/src/linpred.jl:53"
        ]
      },
      {
        "name": "deviance",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "deviance(::Union(DataFrameRegressionModel{M,T},DataFrameStatisticalModel{M,T}),...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:27",
          "deviance(m::GeneralizedLinearModel) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:101",
          "deviance(obj::StatisticalModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:8",
          "deviance(r::LmResp{V<:DenseArray{T<:FloatingPoint,1}}) at /home/samuel/.julia/v0.3/GLM/src/lm.jl:26",
          "deviance(r::GlmResp{V<:DenseArray{T<:FloatingPoint,1}}) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:32"
        ]
      },
      {
        "name": "df_residual",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "df_residual(x::LinPredModel) at /home/samuel/.julia/v0.3/GLM/src/linpred.jl:64",
          "df_residual(x::DensePred) at /home/samuel/.julia/v0.3/GLM/src/linpred.jl:65"
        ]
      },
      {
        "name": "fit",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "fit(::Type{Histogram{T<:Real,N,E}},v::AbstractArray{T,1},edg::AbstractArray{T,1}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:137",
          "fit(::Type{Histogram{T<:Real,N,E}},v::AbstractArray{T,1}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:139",
          "fit(::Type{Histogram{T<:Real,N,E}},v::AbstractArray{T,1},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:144",
          "fit{W}(::Type{Histogram{T<:Real,N,E}},v::AbstractArray{T,1},wv::WeightVec{W,Vec<:AbstractArray{T<:Real,1}},edg::AbstractArray{T,1}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:142",
          "fit{N}(::Type{Histogram{T<:Real,N,E}},vs::NTuple{N,AbstractArray{T,1}},edges::NTuple{N,AbstractArray{T,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:176",
          "fit{N}(::Type{Histogram{T<:Real,N,E}},vs::NTuple{N,AbstractArray{T,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:178",
          "fit{N}(::Type{Histogram{T<:Real,N,E}},vs::NTuple{N,AbstractArray{T,1}},wv::WeightVec{W<:Real,Vec<:AbstractArray{T<:Real,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:183",
          "fit{N,W}(::Type{Histogram{T<:Real,N,E}},vs::NTuple{N,AbstractArray{T,1}},wv::WeightVec{W,Vec<:AbstractArray{T<:Real,1}},edges::NTuple{N,AbstractArray{T,1}}) at /home/samuel/.julia/v0.3/StatsBase/src/hist.jl:181",
          "fit(m::GeneralizedLinearModel) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:105",
          "fit(m::GeneralizedLinearModel,y) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:132",
          "fit(obj::StatisticalModel,data...) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:13",
          "fit{T<:RegressionModel}(::Type{T<:RegressionModel},f::Formula,df::AbstractDataFrame,args...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:52",
          "fit{T<:StatisticalModel}(::Type{T<:StatisticalModel},f::Formula,df::AbstractDataFrame,args...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:52",
          "fit(::Type{Beta},x::Array{T,N}) at /home/samuel/.julia/v0.3/Distributions/src/univariate/beta.jl:119",
          "fit{T<:Real}(::Type{Cauchy},x::Array{T<:Real,N}) at /home/samuel/.julia/v0.3/Distributions/src/univariate/cauchy.jl:47",
          "fit{D<:Distribution{F<:VariateForm,S<:ValueSupport}}(dt::Type{D<:Distribution{F<:VariateForm,S<:ValueSupport}},x) at /home/samuel/.julia/v0.3/Distributions/src/fallbacks.jl:286",
          "fit{D<:Distribution{F<:VariateForm,S<:ValueSupport}}(dt::Type{D<:Distribution{F<:VariateForm,S<:ValueSupport}},args...) at /home/samuel/.julia/v0.3/Distributions/src/fallbacks.jl:287",
          "fit{LinPredT<:LinPred}(::Type{LinearModel{LinPredT<:LinPred}},X::Array{T,2},y::Array{T,1}) at /home/samuel/.julia/v0.3/GLM/src/lm.jl:37",
          "fit(::Type{LinearModel{T<:LinPred}},X::Array{T,2},y::Array{T,1}) at /home/samuel/.julia/v0.3/GLM/src/lm.jl:41",
          "fit{T<:FloatingPoint,V<:DenseArray{T<:FloatingPoint,1}}(::Type{GeneralizedLinearModel},X::Array{T<:FloatingPoint,2},y::V<:DenseArray{T<:FloatingPoint,1},d::Distribution{Univariate,S<:ValueSupport}) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:151",
          "fit{T<:FloatingPoint,V<:DenseArray{T<:FloatingPoint,1}}(::Type{GeneralizedLinearModel},X::Array{T<:FloatingPoint,2},y::V<:DenseArray{T<:FloatingPoint,1},d::Distribution{Univariate,S<:ValueSupport},l::Link) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:151",
          "fit(::Type{GeneralizedLinearModel},X::Array{T,2},y::AbstractArray{T,1},d::Distribution{Univariate,S<:ValueSupport}) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:166",
          "fit(::Type{GeneralizedLinearModel},X::Array{T,2},y::AbstractArray{T,1},d::Distribution{Univariate,S<:ValueSupport},l::Link) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:166"
        ]
      },
      {
        "name": "formula",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "formula(obj::LinPredModel) at /home/samuel/.julia/v0.3/GLM/src/linpred.jl:120"
        ]
      },
      {
        "name": "glm",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "glm(e::Expr,df,args...) at /home/samuel/.julia/v0.3/GLM/src/deprecated.jl:6",
          "glm(s::String,df,args...) at /home/samuel/.julia/v0.3/GLM/src/deprecated.jl:12",
          "glm(X,y,args...) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:170"
        ]
      },
      {
        "name": "linkfun!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "linkfun!{T<:FloatingPoint}(::IdentityLink,eta::Array{T<:FloatingPoint,1},mu::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:42",
          "linkfun!{T<:FloatingPoint}(::CauchitLink,eta::Array{T<:FloatingPoint,1},mu::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:55",
          "linkfun!{T<:FloatingPoint}(::CloglogLink,eta::Array{T<:FloatingPoint,1},mu::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:55",
          "linkfun!{T<:FloatingPoint}(::InverseLink,eta::Array{T<:FloatingPoint,1},mu::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:55",
          "linkfun!{T<:FloatingPoint}(::LogitLink,eta::Array{T<:FloatingPoint,1},mu::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:55",
          "linkfun!{T<:FloatingPoint}(::LogLink,eta::Array{T<:FloatingPoint,1},mu::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:55",
          "linkfun!{T<:FloatingPoint}(::ProbitLink,eta::Array{T<:FloatingPoint,1},mu::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:55",
          "linkfun!{T<:FloatingPoint}(::SqrtLink,eta::Array{T<:FloatingPoint,1},mu::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:55",
          "linkfun!(r::GlmResp{V<:DenseArray{T<:FloatingPoint,1}}) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:38"
        ]
      },
      {
        "name": "linkinv!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "linkinv!{T<:FloatingPoint}(::IdentityLink,mu::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:43",
          "linkinv!{T<:FloatingPoint}(::CauchitLink,mu::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:56",
          "linkinv!{T<:FloatingPoint}(::CloglogLink,mu::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:56",
          "linkinv!{T<:FloatingPoint}(::InverseLink,mu::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:56",
          "linkinv!{T<:FloatingPoint}(::LogitLink,mu::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:56",
          "linkinv!{T<:FloatingPoint}(::LogLink,mu::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:56",
          "linkinv!{T<:FloatingPoint}(::ProbitLink,mu::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:56",
          "linkinv!{T<:FloatingPoint}(::SqrtLink,mu::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:56",
          "linkinv!(r::GlmResp{V<:DenseArray{T<:FloatingPoint,1}}) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:41"
        ]
      },
      {
        "name": "linpred",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "linpred(p::LinPred) at /home/samuel/.julia/v0.3/GLM/src/linpred.jl:4",
          "linpred(p::LinPred,f::Real) at /home/samuel/.julia/v0.3/GLM/src/linpred.jl:4"
        ]
      },
      {
        "name": "lm",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "lm(e::Expr,df,args...) at /home/samuel/.julia/v0.3/GLM/src/deprecated.jl:6",
          "lm(s::String,df,args...) at /home/samuel/.julia/v0.3/GLM/src/deprecated.jl:12",
          "lm(X,y) at /home/samuel/.julia/v0.3/GLM/src/lm.jl:43"
        ]
      },
      {
        "name": "lmc",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "lmc(e::Expr,df,args...) at /home/samuel/.julia/v0.3/GLM/src/deprecated.jl:6",
          "lmc(s::String,df,args...) at /home/samuel/.julia/v0.3/GLM/src/deprecated.jl:12",
          "lmc(X,y) at /home/samuel/.julia/v0.3/GLM/src/lm.jl:44"
        ]
      },
      {
        "name": "mueta!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "mueta!{T<:FloatingPoint}(::IdentityLink,me::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:44",
          "mueta!{T<:FloatingPoint}(::CauchitLink,me::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:57",
          "mueta!{T<:FloatingPoint}(::CloglogLink,me::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:57",
          "mueta!{T<:FloatingPoint}(::InverseLink,me::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:57",
          "mueta!{T<:FloatingPoint}(::LogitLink,me::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:57",
          "mueta!{T<:FloatingPoint}(::LogLink,me::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:57",
          "mueta!{T<:FloatingPoint}(::ProbitLink,me::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:57",
          "mueta!{T<:FloatingPoint}(::SqrtLink,me::Array{T<:FloatingPoint,1},eta::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:57",
          "mueta!(r::GlmResp{V<:DenseArray{T<:FloatingPoint,1}}) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:44"
        ]
      },
      {
        "name": "mustart",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "mustart{T<:FloatingPoint}(::Binomial,y::Array{T<:FloatingPoint,1},wt::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:78",
          "mustart{T<:FloatingPoint}(::Gamma,y::Array{T<:FloatingPoint,1},::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:79",
          "mustart{T<:FloatingPoint}(::Normal,y::Array{T<:FloatingPoint,1},::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:80",
          "mustart{T<:FloatingPoint}(::Poisson,y::Array{T<:FloatingPoint,1},::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:81"
        ]
      },
      {
        "name": "nobs",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "nobs(::Union(DataFrameRegressionModel{M,T},DataFrameStatisticalModel{M,T}),...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:27",
          "nobs(obj::LinPredModel) at /home/samuel/.julia/v0.3/GLM/src/linpred.jl:121",
          "nobs(obj::StatisticalModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:10"
        ]
      },
      {
        "name": "predict",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "predict(::DataFrameRegressionModel{M,T},...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:27",
          "predict(mm::LinearModel{T<:LinPred},newx::Array{T,2}) at /home/samuel/.julia/v0.3/GLM/src/lm.jl:62",
          "predict(mm::LinPredModel) at /home/samuel/.julia/v0.3/GLM/src/linpred.jl:119",
          "predict(obj::RegressionModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:20"
        ]
      },
      {
        "name": "stderr",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "stderr(::Union(DataFrameRegressionModel{M,T},DataFrameStatisticalModel{M,T}),...) at /home/samuel/.julia/v0.3/DataFrames/src/statsmodels/statsmodel.jl:27",
          "stderr(x::LinPredModel) at /home/samuel/.julia/v0.3/GLM/src/linpred.jl:73",
          "stderr(obj::StatisticalModel) at /home/samuel/.julia/v0.3/StatsBase/src/statmodels.jl:11"
        ]
      },
      {
        "name": "updatemu!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "updatemu!{V<:DenseArray{T<:FloatingPoint,1}}(r::LmResp{V<:DenseArray{T<:FloatingPoint,1}},linPr::V<:DenseArray{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/lm.jl:16",
          "updatemu!{V<:DenseArray{T<:FloatingPoint,1}}(r::LmResp{V<:DenseArray{T<:FloatingPoint,1}},linPr) at /home/samuel/.julia/v0.3/GLM/src/lm.jl:20",
          "updatemu!{T<:DenseArray{T<:FloatingPoint,1}}(r::GlmResp{T<:DenseArray{T<:FloatingPoint,1}},linPr::T<:DenseArray{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:47",
          "updatemu!{T<:DenseArray{T<:FloatingPoint,1}}(r::GlmResp{T<:DenseArray{T<:FloatingPoint,1}},linPr) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:53"
        ]
      },
      {
        "name": "var!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "var!{T<:FloatingPoint}(::Binomial,v::Array{T<:FloatingPoint,1},mu::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:69",
          "var!{T<:FloatingPoint}(::Gamma,v::Array{T<:FloatingPoint,1},mu::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:70",
          "var!{T<:FloatingPoint}(::Normal,v::Array{T<:FloatingPoint,1},mu::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:71",
          "var!{T<:FloatingPoint}(::Poisson,v::Array{T<:FloatingPoint,1},mu::Array{T<:FloatingPoint,1}) at /home/samuel/.julia/v0.3/GLM/src/glmtools.jl:72",
          "var!(r::GlmResp{V<:DenseArray{T<:FloatingPoint,1}}) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:55"
        ]
      },
      {
        "name": "wrkresid!",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "wrkresid!(r::GlmResp{V<:DenseArray{T<:FloatingPoint,1}}) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:57"
        ]
      },
      {
        "name": "wrkresp",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "wrkresp(r::GlmResp{V<:DenseArray{T<:FloatingPoint,1}}) at /home/samuel/.julia/v0.3/GLM/src/glmfit.jl:60"
        ]
      }
    ]
  },
  {
    "name": "Winston",
    "items": 
    [
      {
        "name": "Curve",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "FillAbove",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "FillBelow",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "FillBetween",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "FramedPlot",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Histogram",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Image",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Legend",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "LineX",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "LineY",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Plot",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PlotInset",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "PlotLabel",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Points",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Slope",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Stems",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "SymmetricErrorBarsX",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "SymmetricErrorBarsX(x,y,err,args...) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:361"
        ]
      },
      {
        "name": "SymmetricErrorBarsY",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "SymmetricErrorBarsY(x,y,err,args...) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:367"
        ]
      },
      {
        "name": "Table",
        "summary": "DataType",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "Winston",
        "summary": "Module",
        "help": "No help information found.\n",
        "methods": 
        [

        ]
      },
      {
        "name": "closefig",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "closefig() at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:2680",
          "closefig(i::Integer) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:2690"
        ]
      },
      {
        "name": "colormap",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "colormap() at /home/samuel/.julia/v0.3/Winston/src/plot.jl:283",
          "colormap(c::Array{Uint32,1}) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:284",
          "colormap{C<:ColorValue}(cs::Array{C<:ColorValue,1}) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:285",
          "colormap(name::String) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:288",
          "colormap(name::String,n::Int64) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:288"
        ]
      },
      {
        "name": "data_to_device",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "data_to_device{T<:Real}(ctx::PlotContext,x::Union(AbstractArray{T<:Real,N},T<:Real),y::Union(AbstractArray{T<:Real,N},T<:Real)) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:217"
        ]
      },
      {
        "name": "device_to_data",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "device_to_data(ctx::PlotContext,x::Real,y::Real) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:213"
        ]
      },
      {
        "name": "errorbar",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "errorbar(p::FramedPlot,x::AbstractArray{T,1},y::AbstractArray{T,1}) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:459",
          "errorbar(args...) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:456"
        ]
      },
      {
        "name": "figure",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "figure() at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:2665",
          "figure(i::Integer) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:2672"
        ]
      },
      {
        "name": "file",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "file(self::PlotContainer,filename::String,args...) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:1833",
          "file{T<:PlotContainer}(plots::Array{T<:PlotContainer,1},filename::String,args...) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:1857",
          "file(fname::String,args...) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:15"
        ]
      },
      {
        "name": "fplot",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "fplot(f::Function,limits,args...) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:565"
        ]
      },
      {
        "name": "gcf",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "gcf() at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:2679"
        ]
      },
      {
        "name": "get_context",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "get_context(c::Canvas,pc::PlotContainer) at /home/samuel/.julia/v0.3/Winston/src/tk.jl:40",
          "get_context(pc::PlotContainer) at /home/samuel/.julia/v0.3/Winston/src/tk.jl:45"
        ]
      },
      {
        "name": "getattr",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "getattr(self::FramedPlot,name::Symbol) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:1035",
          "getattr(self::HasAttr,name::Symbol) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:2512",
          "getattr(self::HasAttr,name::Symbol,notfound) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:2517",
          "getattr(self::HasAttr,name::String) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:2527",
          "getattr(self::HasAttr,name::String,notfound) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:2528"
        ]
      },
      {
        "name": "hold",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "hold() at /home/samuel/.julia/v0.3/Winston/src/plot.jl:3",
          "hold(h::Bool) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:4"
        ]
      },
      {
        "name": "imagesc",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "imagesc{T<:Real}(xrange::(Real,Real),yrange::(Real,Real),data::AbstractArray{T<:Real,2},clims::(Real,Real)) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:297",
          "imagesc{T}(data::AbstractArray{T,2},clims::(Real,Real)) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:309",
          "imagesc(xrange,yrange,data) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:307",
          "imagesc(data) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:308"
        ]
      },
      {
        "name": "loglog",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "loglog(args::Union(AbstractArray{T,2},Real,AbstractArray{T,1},Function,String)...) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:249"
        ]
      },
      {
        "name": "oplot",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "oplot(args::Union(AbstractArray{T,2},Real,AbstractArray{T,1},Function,String)...) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:244"
        ]
      },
      {
        "name": "plot",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "plot(p::FramedPlot,args::Union(AbstractArray{T,2},Real,AbstractArray{T,1},Function,String)...) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:116",
          "plot(args::Union(AbstractArray{T,2},Real,AbstractArray{T,1},Function,String)...) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:241",
          "plot(p::FramedPlot,x::(Array{T<:Real,1},Array{S<:Real,1}),args...) at /home/samuel/.julia/v0.3/Winston/src/plot_interfaces.jl:17",
          "plot(p::FramedPlot,fs::(Function,Function),a::Real,b::Real,args...) at /home/samuel/.julia/v0.3/Winston/src/plot_interfaces.jl:26",
          "plot(fs::Array{Function,2},a::Real,b::Real,args...) at /home/samuel/.julia/v0.3/Winston/src/plot_interfaces.jl:37",
          "plot(f::Contourc) at /home/samuel/.julia/v0.3/Winston/src/contour.jl:165"
        ]
      },
      {
        "name": "plothist",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "plothist(p::FramedPlot,h::(Range{T},Array{T,1})) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:407",
          "plothist(p::FramedPlot,args...) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:421",
          "plothist(args...) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:422"
        ]
      },
      {
        "name": "plothist2d",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "plothist2d(p::FramedPlot,h::(Union(Array{T,1},Range{T}),Union(Array{T,1},Range{T}),Array{Int64,2})) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:436",
          "plothist2d(p::FramedPlot,args...) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:452",
          "plothist2d(args...) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:453"
        ]
      },
      {
        "name": "savefig",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "file(self::PlotContainer,filename::String,args...) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:1833",
          "file{T<:PlotContainer}(plots::Array{T<:PlotContainer,1},filename::String,args...) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:1857",
          "file(fname::String,args...) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:15"
        ]
      },
      {
        "name": "scatter",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "scatter{C<:Complex{T<:Real}}(z::Union(AbstractArray{C<:Complex{T<:Real},1},AbstractArray{C<:Complex{T<:Real},2})) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:335",
          "scatter(x::Union(AbstractArray{T,2},AbstractArray{T,1}),y::Union(AbstractArray{T,2},AbstractArray{T,1})) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:334",
          "scatter(x::Union(AbstractArray{T,2},AbstractArray{T,1}),y::Union(AbstractArray{T,2},AbstractArray{T,1}),spec::ASCIIString) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:334",
          "scatter{C<:Complex{T<:Real}}(z::Union(AbstractArray{C<:Complex{T<:Real},1},AbstractArray{C<:Complex{T<:Real},2}),spec::ASCIIString) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:335",
          "scatter(x::Union(AbstractArray{T,2},AbstractArray{T,1}),y::Union(AbstractArray{T,2},AbstractArray{T,1}),s::Real) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:338",
          "scatter(x::Union(AbstractArray{T,2},AbstractArray{T,1}),y::Union(AbstractArray{T,2},AbstractArray{T,1}),s::Real,spec::ASCIIString) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:338",
          "scatter(x::Union(AbstractArray{T,2},AbstractArray{T,1}),y::Union(AbstractArray{T,2},AbstractArray{T,1}),s::Union(AbstractArray{T,2},AbstractArray{T,1})) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:353",
          "scatter(x::Union(AbstractArray{T,2},AbstractArray{T,1}),y::Union(AbstractArray{T,2},AbstractArray{T,1}),s::Union(AbstractArray{T,2},AbstractArray{T,1}),spec::ASCIIString) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:353",
          "scatter(x::Union(AbstractArray{T,2},AbstractArray{T,1}),y::Union(AbstractArray{T,2},AbstractArray{T,1}),s::Union(Real,Union(AbstractArray{T,2},AbstractArray{T,1})),c::Union(AbstractArray{T,2},AbstractArray{T,1})) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:359",
          "scatter(x::Union(AbstractArray{T,2},AbstractArray{T,1}),y::Union(AbstractArray{T,2},AbstractArray{T,1}),s::Union(Real,Union(AbstractArray{T,2},AbstractArray{T,1})),c::Union(AbstractArray{T,2},AbstractArray{T,1}),spec::ASCIIString) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:359"
        ]
      },
      {
        "name": "semilogx",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "semilogx(args::Union(AbstractArray{T,2},Real,AbstractArray{T,1},Function,String)...) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:247"
        ]
      },
      {
        "name": "semilogy",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "semilogy(args::Union(AbstractArray{T,2},Real,AbstractArray{T,1},Function,String)...) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:248"
        ]
      },
      {
        "name": "setattr",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "setattr(self::_Alias,name::Symbol,value) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:976",
          "setattr(self::FramedPlot,name::Symbol,value) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:1045",
          "setattr(self::FramedArray,name::Symbol,value) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:1449",
          "setattr(self::HasAttr,name::Symbol,value) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:2522",
          "setattr(self::HasAttr,name::String,value) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:2529",
          "setattr(self::HasAttr) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:2530"
        ]
      },
      {
        "name": "spy",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "spy(S::SparseMatrixCSC{Tv,Ti<:Integer},nrS::Integer,ncS::Integer) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:312",
          "spy(S::SparseMatrixCSC{Tv,Ti<:Integer}) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:402",
          "spy(A::AbstractArray{T,2},nrS,ncS) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:403",
          "spy(A::AbstractArray{T,2}) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:404"
        ]
      },
      {
        "name": "stem",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "stem(y::Union(AbstractArray{T,2},AbstractArray{T,1})) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:383",
          "stem(y::Union(AbstractArray{T,2},AbstractArray{T,1}),spec::ASCIIString) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:383",
          "stem(x::Union(AbstractArray{T,2},AbstractArray{T,1}),y::Union(AbstractArray{T,2},AbstractArray{T,1})) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:385",
          "stem(x::Union(AbstractArray{T,2},AbstractArray{T,1}),y::Union(AbstractArray{T,2},AbstractArray{T,1}),spec::ASCIIString) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:385"
        ]
      },
      {
        "name": "style",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "style(self::HasStyle,args...) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:2585"
        ]
      },
      {
        "name": "svg",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "svg(self::PlotContainer,args...) at /home/samuel/.julia/v0.3/Winston/src/Winston.jl:1869"
        ]
      },
      {
        "name": "text",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "text(x::Real,y::Real,s::String) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:396"
        ]
      },
      {
        "name": "title",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "title(s::String) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:19"
        ]
      },
      {
        "name": "xlabel",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "xlabel(s::String) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:19"
        ]
      },
      {
        "name": "xlim",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "xlim(a,b) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:22",
          "xlim(a) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:23",
          "xlim() at /home/samuel/.julia/v0.3/Winston/src/plot.jl:24"
        ]
      },
      {
        "name": "ylabel",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "ylabel(s::String) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:19"
        ]
      },
      {
        "name": "ylim",
        "summary": "Function",
        "help": "No help information found.\n",
        "methods": 
        [
          "ylim(a,b) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:22",
          "ylim(a) at /home/samuel/.julia/v0.3/Winston/src/plot.jl:23",
          "ylim() at /home/samuel/.julia/v0.3/Winston/src/plot.jl:24"
        ]
      }
    ]
  }
]
